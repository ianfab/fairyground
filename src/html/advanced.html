<!doctype html>
<head>
  <meta charset="utf-8" />
  <title>Fairy-Stockfish playground</title>
  <!-- By curl https://data-url-maker-hiro18181.netlify.app/api/url/https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg -->
  <link
    rel="icon"
    href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+CiAgPGcgc3R5bGU9Im9wYWNpdHk6MTsgZmlsbDpub25lOyBmaWxsLW9wYWNpdHk6MTsgZmlsbC1ydWxlOmV2ZW5vZGQ7IHN0cm9rZTojMDAwMDAwOyBzdHJva2Utd2lkdGg6MS41OyBzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDsgc3Ryb2tlLWRhc2hhcnJheTpub25lOyBzdHJva2Utb3BhY2l0eToxOyI+CiAgICA8cGF0aAogICAgICBkPSJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4IgogICAgICBzdHlsZT0iZmlsbDojMDAwMDAwOyBzdHJva2U6IzAwMDAwMDsiIC8+CiAgICA8cGF0aAogICAgICBkPSJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMCIKICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDsgc3Ryb2tlOiMwMDAwMDA7IiAvPgogICAgPHBhdGgKICAgICAgZD0iTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHoiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHoiCiAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MykiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogIgogICAgICBzdHlsZT0iZmlsbDojZmZmZmZmOyBzdHJva2U6bm9uZTsiIC8+CiAgPC9nPgo8L3N2Zz4K"
  />
  <link rel="stylesheet" href="assets/chessground.css" />
  <link rel="stylesheet" href="assets/generated.css" />
  <link rel="stylesheet" href="assets/theme-backgrounds.css" />
  <link rel="stylesheet" href="assets/theme-default.css" />
  <base target="_blank" />
</head>

<!-- CSS -->

<style>
  :root {
    --console-font: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas,
      Liberation Mono, monospace;
  }

  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0;
    font: inherit;
  }

  @font-face {
    font-family: "FontAwesome";
    src:
      url("./assets/fonts/FontAwesome.woff2") format("woff2"),
      url("./assets/fonts/FontAwesome.woff") format("woff"),
      url("./assets/fonts/FontAwesome.ttf") format("truetype");
    font-weight: normal;
    font-style: normal;
  }

  html,
  body,
  #root {
    height: 100%;
    transition-property: background-color, color;
    transition-duration: 0.5s, 0.2s;
    transition-timing-function: linear, linear;
    transition-delay: 0s;
  }

  html {
    background: white;
    color: black;
  }

  #root {
    font-size: 16px;
  }

  main {
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }

  div {
    transition-property: background-color, color;
    transition-duration: 0.5s, 0.2s;
    transition-timing-function: linear, linear;
    transition-delay: 0s;
  }

  /* div.ripple-wrapper {
    background: #0000;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    pointer-events: none;
    overflow: hidden;
    opacity: 0.5;
    transition: opacity 1s ease;
  }

  div.ripple-wrapper.ripple-fade-out {
    opacity: 0;
  } */

  div.ripple-wrapper {
    display: none;
  }

  button:before {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 25px;
    height: 25px;
    background-color: #0078d7;
    color: white;
    font-family: FontAwesome;
    font-size: 14px;
    border: 2px solid #000;
  }

  /* span.ripple-effect {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: #fff;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    opacity: 1;
    transition: width 1s ease, height 1s ease;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    pointer-events: none;
  } */

  .backgroundimg {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-size: cover;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }

  .pagebackground {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: none;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: top left;
    overflow: hidden;
    z-index: -100;
  }

  .pagebackgroundcanvas {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: none;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: top left;
    overflow: hidden;
    z-index: -50;
  }

  .background-canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  .timer-active {
    box-shadow: 0px 0px 5px 5px #f00;
  }

  .time-exceeded {
    color: red;
  }

  .time-exceeded:before {
    content: "\f017";
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 35px;
    height: 35px;
    background-color: crimson;
    color: white;
    font-family: FontAwesome;
    font-size: 20px;
    border: 4px solid #000;
    transform: translate(-20%, -20%);
  }

  .position-display-label {
    cursor: pointer;
  }

  .position-display-label:hover {
    background-color: black;
    color: white;
  }

  .inaccessable {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    pointer-events: none;
  }

  .delete-piece:before {
    content: "\f1f8";
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 100px;
    height: 100px;
    background-color: crimson;
    color: white;
    font-family: FontAwesome;
    font-size: 60px;
    border: 10px solid #000;
  }

  .move-piece:before {
    content: "\f047";
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 100px;
    height: 100px;
    background-color: grey;
    color: white;
    font-family: FontAwesome;
    font-size: 60px;
    border: 10px solid #000;
  }

  .ripple {
    position: relative;
  }

  input[type="checkbox"] {
    display: inline-block;
    height: 20px;
    width: 20px;
    border: 2px solid #ddd;
    overflow: hidden;
    vertical-align: middle;
    text-align: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    font: normal normal normal 14px/1 FontAwesome;
    outline: 0;
    background: 0 0;
    background-color: white;
    margin-left: 5px;
  }

  input[type="checkbox"]:hover {
    color: #000;
    background-color: #ddd;
  }

  input[type="checkbox"]:checked {
    color: #fff;
    background-color: #000;
  }

  input[type="checkbox"]:hover:checked {
    color: #fff;
    background-color: #777;
  }

  input[type="checkbox"]:checked:after {
    content: "\f00c";
    font-size: 15px;
    text-align: center;
    line-height: 17px;
  }

  input[type="checkbox"]:disabled {
    color: #000;
    background-color: rgba(176, 176, 176, 0.2);
  }

  input[type="checkbox"]:disabled:hover {
    color: #000;
    background-color: rgba(176, 176, 176, 0.2);
  }

  #pagetitle {
    font-size: 40px;
    font-family: "Times New Roman", Times, serif, Arial;
    margin-bottom: 10px;
    font-style: oblique;
    font-weight: bold;
  }

  #input {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #input2 {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #input3 {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #visualeffects {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 5px;
    margin-bottom: 10px;
  }

  #visualeffects select {
    min-width: 120px;
    height: 25px;
    background: #eee;
  }

  #gamesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #gamesettings button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #gamesettings button:hover {
    background: #aaa;
  }

  #gamesettings button:disabled {
    background: #ccc;
    color: #000;
  }

  #gamesettings button:active {
    background: #000;
  }

  #input #fen {
    width: 50%;
    min-width: 450px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #input #move {
    width: 10%;
    min-width: 100px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #input2 #movetime {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #movetime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #depth {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #depth:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #nodes {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #nodes:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #threads {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #threads:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #hash {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #hash:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #multipv {
    width: 5%;
    min-width: 75px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #multipv:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #input button:hover {
    background: #aaa;
  }

  #input button:disabled {
    background: #ccc;
    color: #000;
  }

  #input button:active {
    background: #000;
  }

  #input2 button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #input2 button:hover {
    background: #aaa;
  }

  #input2 button:disabled {
    background: #ccc;
    color: #000;
  }

  #input2 button:active {
    background: #000;
  }

  #movecontrol button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    margin-top: 2px;
    cursor: pointer;
  }

  #movecontrol button:hover {
    background: #aaa;
  }

  #movecontrol button:disabled {
    background: #ccc;
    color: #000;
  }

  #movecontrol button:active {
    background: #000;
  }

  #movecontrol #gotomovenum {
    width: 200px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #movecontrol #gotomovenum:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #controls button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #controls button:hover {
    background: #aaa;
  }

  #controls button:disabled {
    background: #ccc;
    color: #000;
  }

  #controls button:active {
    background: #000;
  }

  #boardcoordinate {
    width: 300px;
    background: #eee;
    margin-left: 10px;
    margin-top: 5px;
  }

  #gamesettings #dropdown-quickpromotion {
    width: 120px;
    background: #eee;
    margin-left: 10px;
  }

  #dropdown-boardtheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #dropdown-piecetheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #dropdown-uitheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #misc {
    margin-bottom: 10px;
  }

  #misc button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #misc button:hover {
    background: #aaa;
  }

  #misc button:disabled {
    background: #ccc;
    color: #000;
  }

  #misc button:active {
    background: #000;
  }

  #outputs {
    display: flex;
    flex: 1 1 auto;
    margin-top: 10px;
    width: 100%;
    height: fit-content;
  }

  #outputs.vertical {
    position: static;
    flex-direction: column;
    flex-flow: column;
  }

  #movecontrol {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #binengineinput {
    margin-bottom: 10px;
  }

  #binengineinput button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #binengineinput button:hover {
    background: #aaa;
  }

  #binengineinput button:disabled {
    background: #ccc;
    color: #000;
  }

  #binengineinput button:active {
    background: #000;
  }

  #binengineinput input {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #binengineinput input:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #binengineinput #whiteenginesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #binengineinput #blackenginesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #binengineinput #analysisenginesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #posvariantdiv {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #posvariantdiv #dropdown-variant {
    width: 150px;
    min-height: 25px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-varianttype {
    width: 150px;
    min-height: 25px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-posvarianttype {
    min-width: 120px;
    max-width: 150px;
    min-height: 25px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-posvariantname {
    min-width: 120px;
    max-width: 150px;
    min-height: 25px;
    background: #eee;
    margin-left: 5px;
    margin-right: 5px;
  }

  #posvariantdiv button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #posvariantdiv button:hover {
    background: #aaa;
  }

  #posvariantdiv button:disabled {
    background: #ccc;
    color: #000;
  }

  #posvariantdiv button:active {
    background: #000;
  }

  #controls {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #info {
    padding: 10px;
    margin-left: 10px;
    font-size: 16px;
    height: fit-content;
  }

  #info #sannotation {
    background: #eee;
    margin-bottom: 5px;
    height: 25px;
  }

  #info #timecontrolduringplay {
    padding: 10px;
    margin-left: 20px;
    font-size: 16px;
    margin-bottom: 5px;
  }

  #info #timecontrolduringplay button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #info #timecontrolduringplay button:hover {
    background: #aaa;
  }

  #info #timecontrolduringplay button:disabled {
    background: #ccc;
    color: #000;
  }

  #info #timecontrolduringplay button:active {
    background: #000;
  }

  #currentboardfen {
    height: 60px;
    border: 1px solid #ddd;
    padding: 10px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #label-pgn {
    height: 120px;
    border: 1px solid #ddd;
    padding: 10px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #pgndiv {
    display: flex;
    flex-direction: row;
    flex-flow: row;
    gap: 10px 10px;
    flex-wrap: wrap;
  }

  #output2 {
    height: 420px;
    border: 1px solid #ddd;
    padding: 10px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #pocket-top {
    display: flex;
    margin-bottom: 20px;
  }

  #pocket-top.no-inital-pocket-piece {
    display: none;
  }

  #pocket-top.no-inital-pocket-piece.has-hidden-pocket-piece {
    display: flex;
  }

  #pocket-top-mini {
    display: flex;
  }

  #pocket-bottom {
    display: flex;
    margin-top: 20px;
  }

  #pocket-bottom.no-inital-pocket-piece {
    display: none;
  }

  #pocket-bottom.no-inital-pocket-piece.has-hidden-pocket-piece {
    display: flex;
  }

  #pocket-bottom-mini {
    display: flex;
  }

  #links a {
    margin: 20px;
    font-size: 20px;
    text-decoration: none;
  }

  #linkdivhr {
    border: 1px solid #aaa;
    margin-bottom: 5px;
  }

  #info #timers {
    width: 620px;
    height: 145px;
    border: 2px solid #eee;
    background-color: rgba(118, 118, 118, 0.3);
    overflow: hidden;
    margin-bottom: 5px;
    padding: 10px 10px 10px 10px;
  }

  #info #timers.vertical {
    width: 314px;
    height: 284px;
  }

  #info #timers #whitetimer {
    float: left;
    width: 290px;
    height: 120px;
    border: 2px solid #000;
    color: black;
    background-color: white;
    text-align: center;
    overflow: hidden;
  }

  #info #timers.vertical #whitetimer {
    float: none;
  }

  #info #timers #blacktimer {
    float: right;
    width: 290px;
    height: 120px;
    border: 2px solid #fff;
    color: white;
    background-color: black;
    text-align: center;
    overflow: hidden;
  }

  #info #timers.vertical #blacktimer {
    float: none;
    margin-top: 20px;
  }

  #info #checkcounts {
    margin-bottom: 5px;
  }

  #info #enginecmddiv {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #info #enginecmddiv #enginecmd {
    width: 500px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #info #enginecmddiv button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #info #enginecmddiv button:hover {
    background: #aaa;
  }

  #info #enginecmddiv button:disabled {
    background: #ccc;
    color: #000;
  }

  #info #enginecmddiv button:active {
    background: #000;
  }

  #info #enginecmddiv #targetengine {
    width: 150px;
    background: #eee;
  }

  #blacktime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #whitetime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #boardsetupsettings {
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange {
    display: flex;
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange #dropdown-setpiece {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings #boardpiecechange button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #boardsetupsettings #boardpiecechange button:hover {
    background: #aaa;
  }

  #boardsetupsettings #boardpiecechange button:disabled {
    background: #ccc;
    color: #000;
  }

  #boardsetupsettings #boardpiecechange button:active {
    background: #000;
  }

  #boardsetupsettings2 {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #boardsetupsettings2 #dropdown-sidetomove {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings2 #halfmoveclock {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #halfmoveclock:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #whiteremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #whiteremainingchecks:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #blackremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #blackremainingchecks:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #currentmovenum {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #boardsetupsettings2 #currentmovenum:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #enpassantfile {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #enpassantfile:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #enpassantrank {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #boardsetupsettings2 #enpassantrank:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #seirwangatingfiles {
    width: 60%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #enginematch {
    margin-bottom: 10px;
  }

  #enginematch button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    margin-bottom: 5px;
    cursor: pointer;
  }

  #enginematch button:hover {
    background: #aaa;
  }

  #enginematch button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginematch button:active {
    background: #000;
  }

  #enginematch #enginematchgamecount {
    min-width: 150px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #enginematch #enginematchgamecount:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #enginematch #enginematchsettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 5px;
    margin-bottom: 5px;
  }

  #enginematch #enginematchinfo {
    font-weight: bold;
  }

  #advancedtimesettings {
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings #dropdown-whitetimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #whitetimesettings #whitestarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #whitetimesettings #whitestarttime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitetimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitetimegain:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomitime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitetimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitetimemargin:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #advancedtimesettings #blacktimesettings #dropdown-blacktimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #blacktimesettings #blackstarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #blacktimesettings #blackstarttime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blacktimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blacktimegain:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomitime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blacktimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blacktimemargin:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #gamecontrol-start {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
    margin-bottom: 10px;
  }

  #advancedtimesettings #gamecontrol-start #gamestart {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    font-size: 24px;
    margin-right: 6px;
    cursor: pointer;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:hover {
    background: #aaa;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:disabled {
    background: #ccc;
    color: #000;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:active {
    background: #000;
  }

  #evalbar {
    width: 400px;
    height: 30px;
    overflow: hidden;
    border-radius: 10px;
    border-color: grey;
    border-width: 2px;
    border-style: solid;
    background-color: black;
    position: relative;
  }

  #evalbar.xiangqi {
    background-color: black;
  }

  #evalbar.shogi {
    background-color: white;
  }

  #evalbar.janggi {
    background-color: blue;
  }

  #evalbar.round {
    width: 90px;
    height: 90px;
    border-radius: 45px;
  }

  #evalbar #evalbarprogress {
    float: left;
    height: 100%;
    width: 50%;
    background-color: white;
  }

  #evalbar.xiangqi #evalbarprogress {
    background-color: red;
  }

  #evalbar.shogi #evalbarprogress {
    background-color: black;
  }

  #evalbar.janggi #evalbarprogress {
    background-color: red;
  }

  #evalbar #cp {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    color: orange;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 25px;
    font-weight: bold;
    font-family: Arial, "Times New Roman", Georgia, Serif;
  }

  #evalbar.shogi #cp {
    color: orange;
  }

  #evalbar.xiangqi #cp {
    color: white;
  }

  #evalbar.janggi #cp {
    color: white;
  }

  #evalbar.round #cp {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  #evalinfo {
    white-space: pre-line;
  }

  #pvinfo {
    white-space: pre-line;
    border-top: 4px solid black;
    border-left: 4px solid black;
    border-right: 4px solid black;
    border-bottom: 4px solid black;
    margin-top: 5px;
  }

  #pvinfo hr {
    border: 1px solid black;
  }

  .multipv-miniboard-pvline-moves {
    display: flex;
    flex-direction: row;
    flex-flow: row;
    gap: 10px 10px;
    flex-wrap: wrap;
  }

  evalnum {
    font-weight: 900;
    font-family: Arial, "Times New Roman", Georgia, Serif;
    color: orange;
  }

  evalnum:after {
    content: " \f061 ";
    font-family: FontAwesome;
    font-size: 16px;
    color: black;
  }

  #evaluation {
    margin-bottom: 10px;
  }

  spangameresult,
  spangameresultmini {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 1px;
    transition:
      font-size 0.5s linear,
      opacity 0.5s linear;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
    white-space: nowrap;
  }

  #moveselectiondialog {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 700px;
    padding: 10px;
    background-color: #000000;
    color: #ffffff;
    border: 2px solid #ddd;
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.6);
    z-index: 999;
  }

  #moveselectiondialog input[type="checkbox"] {
    border: 2px solid #ddd;
  }

  #moveselectiondialog button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    margin-bottom: 5px;
    cursor: pointer;
  }

  #moveselectiondialog button:hover {
    background: #aaa;
  }

  #moveselectiondialog button:disabled {
    background: #ccc;
    color: #000;
  }

  #moveselectiondialog button:active {
    background: #000;
  }

  #moveselectiondialog #moveslectdiv {
    display: flex;
    flex-direction: row;
  }

  #moveselectiondialog #movefilters {
    display: flex;
    flex-direction: column;
  }

  #moveselectiondialog #availablemovelist {
    width: 150px;
    background: #eee;
    margin-right: 5px;
  }

  #movesearchfilter {
    border: 1px solid #ddd;
    width: 150px;
  }

  #separatormoveselectiondialog {
    border: dashed #ffffff;
  }

  #separatorsearchresult {
    border: double #ffffff;
  }

  #fsfoutput {
    font-family: var(--console-font);
  }

  #whiteengineoutput {
    font-family: var(--console-font);
  }

  #whiteunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #blackengineoutput {
    font-family: var(--console-font);
  }

  #blackunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #analysisengineoutput {
    font-family: var(--console-font);
  }

  #analysisunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #enginesettingspopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginesettingspopup-background {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 2;
    background-color: #fff;
    overflow: hidden;
  }

  #enginesettingspopup div {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #enginesettingspopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginesettingspopup button:hover {
    background: #aaa;
  }

  #enginesettingspopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginesettingspopup button:active {
    background: #000;
  }

  #enginesettingspopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesettingspopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesettingspopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginemanagementpopup-background {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 2;
    background-color: #fff;
    overflow: hidden;
  }

  #enginemanagementpopup div {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #enginemanagementpopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginemanagementpopup button:hover {
    background: #aaa;
  }

  #enginemanagementpopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginemanagementpopup button:active {
    background: #000;
  }

  #enginemanagementpopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesetuppopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginesetuppopup-background {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 2;
    background-color: #fff;
    overflow: hidden;
  }

  #enginesetuppopup div {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #enginesetuppopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginesetuppopup button:hover {
    background: #aaa;
  }

  #enginesetuppopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginesetuppopup button:active {
    background: #000;
  }

  #enginesetuppopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
    min-width: 300px;
  }

  #enginesetuppopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
    min-width: 300px;
  }

  #enginesetuppopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #loadsavedgamespopup-background {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 2;
    background-color: #fff;
    overflow: hidden;
  }

  #loadsavedgamespopup div {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 5px 0px;
  }

  #loadsavedgamespopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    margin-top: 2px;
    margin-bottom: 2px;
    cursor: pointer;
  }

  #loadsavedgamespopup button:hover {
    background: #aaa;
  }

  #loadsavedgamespopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #loadsavedgamespopup button:active {
    background: #000;
  }

  #loadsavedgamespopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #moveselectiondialog input {
    border: 1px solid #ddd;
  }

  #chessground-mini {
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-flow: row;
    row-gap: 10px;
    top: -10000px;
    left: -10000px;
    z-index: 20;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    background: rgba(0, 0, 0, 0);
  }

  #chessground-mini-board-wrapper-div {
    padding: 10px;
    height: fit-content;
    width: fit-content;
    background-color: white;
    border: 2px solid black;
    touch-action: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  #chessground-mini-board-operation-div {
    display: flex;
    flex-direction: column;
    flex-flow: column;
  }

  #chessground-mini-container-div {
    pointer-events: none;
  }

  #chessground-mini-board-operation-div button {
    background: rgba(0, 0, 0, 0);
    display: block;
  }

  #chessground-mini-board-operation-div button:before {
    width: 50px;
    height: 50px;
    font-size: 28px;
    border: 4px solid black;
  }

  #boardsetuppieceidentifier {
    position: fixed;
    display: none;
    z-index: 19;
    opacity: 0.7;
    pointer-events: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  #fakewrap {
    width: 100px;
    height: 100px;
  }

  #fakepiece {
    width: 100px;
    height: 100px;
  }

  #setpos:before {
    content: "\f046";
  }

  #reset:before {
    content: "\f052";
  }

  #undo:before {
    content: "\f053";
  }

  #restart:before {
    content: "\f01e";
  }

  #go:before {
    content: "\f04b";
  }

  #stop:before {
    content: "\f04d";
  }

  #passmove:before {
    content: "\f021";
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
    -webkit-transform: scale(-1, 1);
    -ms-transform: scale(-1, 1);
    transform: scale(-1, 1);
  }

  #placewall:before {
    content: "\f067";
  }

  #initialposition:before {
    content: "\f049";
  }

  #currentposition:before {
    content: "\f050";
  }

  #previousposition:before {
    content: "\f048";
  }

  #nextposition:before {
    content: "\f051";
  }

  #specifiedposition:before {
    content: "\f06e";
  }

  #starthere:before {
    content: "\f044";
  }

  #button-flip:before {
    content: "\f079";
    -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
    -webkit-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
    transform: rotate(90deg);
  }

  #lockminiboard:before {
    background-color: #0078d7;
    content: "\f13e";
    cursor: pointer;
  }

  .locked #lockminiboard:before {
    background-color: orangered;
    content: "\f023";
  }

  #pinminiboard:before {
    background-color: forestgreen;
    content: "\f0f6";
    cursor: pointer;
  }

  .pinned #pinminiboard:before {
    background-color: rebeccapurple;
    content: "\f2d0";
  }

  #setpositiontomainboard:before {
    background-color: gold;
    content: "\f002";
    cursor: pointer;
  }

  #setpositiontomainboard:disabled:before {
    color: black;
  }

  #closeminiboard:before {
    background-color: crimson;
    content: "\f00d";
    cursor: pointer;
  }
</style>

<body>
  <div id="root"></div>
  <div id="pagebackground" class="pagebackground"></div>
  <div id="pagebackgroundcanvas" class="pagebackgroundcanvas"></div>
  <script>
    //Fairyground namespace for variable/function definition transfer
    window.fairyground = { super: window };
  </script>
  <script src="bundle.js" defer></script>

  <!--iframe src="./themes.html" onload="this.before((this.contentDocument.body || this.contentDocument).children[0]); this.remove();"--><!--/iframe-->

  <!-- Javascript -->

  <script src="./lib/stockfish.js"></script>
  <script src="./lib/mithril.min.js"></script>
  <script src="./lib/BinaryEngineFeature.js"></script>
  <script src="./lib/SavedGamesParsingFeature.js"></script>
  <script>
    //For quick access (Shortening the name)
    var fge = window.fairyground.BinaryEngineFeature;
    var fgs = window.fairyground.SavedGamesParsingFeature;
    let themes = [[], [], []];
    let themenames = [[], []];
    let variantsettings = [[], [], [], [], []];
    let allvariants = [];
    let uithemes = [[], []];
    let currentthemeobj = null;
    let currentuicss = null;

    //Feature loading status global variable
    var pageloaded = false;
    var uithemesparsed = false;
    var themesloaded = false;
    var positionvariantsloaded = false;
    var variantsettingsloaded = false;
    var variantsystemready = false;

    let previouschangeuitime = 0;
    const $ = (...args) => document.querySelector(...args);

    class UIThemeObject {
      constructor(ID, Name) {
        if (typeof ID != "string" || typeof Name != "string") {
          throw TypeError("UIThemeObject(ID:string, Name:string)");
        }
        this.Name = Name;
        this.ID = ID;
        this.StyleNodeList = [];
        this.StyleDurations = [];
        this.CurrentThemeIndex = 0;
        this.CurrentThemeRemainingTime = 0;
        this.Initialized = false;
        this.Timer = null;
        this.CanvasWorker = null;
        this.CanvasInstance = null;
        this.CanvasState = "Uninitialized";
        this.StyleDurationsLoaded = false;
        this.PendingCanvasReloading = false;
        this.CanvasFrameRate = 50;
        this.OnWindowResizeHandlerFunction = null;
      }

      destructor() {
        if (this.Timer != null) {
          clearTimeout(this.Timer);
        }
      }

      SetStyleDurations(StyleDurationsInSeconds) {
        if (!Array.isArray(StyleDurationsInSeconds)) {
          throw TypeError("SetStyleDurations(StyleDurations:number[])");
        }
        let i = 0;
        this.StyleDurations = [];
        this.StyleDurationsLoaded = true;
        for (i = 0; i < StyleDurationsInSeconds.length; i++) {
          if (typeof StyleDurationsInSeconds[i] != "number") {
            throw TypeError("SetStyleDurations(StyleDurations:number[])");
          }
          this.StyleDurations.push(StyleDurationsInSeconds[i] * 1000);
        }
      }

      SetCanvasWorker(CanvasWorkerName) {
        if (typeof CanvasWorkerName != "string") {
          throw TypeError("SetCanvasWorker(CanvasWorkerName:string)");
        }
        if (this.CanvasWorker != null) {
          return;
        }
        this.CanvasWorker = new Worker(
          `./lib/canvas/${CanvasWorkerName}.canvas.worker.js`,
        );
        this.CanvasWorker.onmessage = (event) => {
          const message = event.data;
          if (message.message == "CanvasHandlerDestroyed") {
            this.CanvasInstance.remove();
            this.CanvasInstance = null;
            this.CanvasState = "Uninitialized";
            if (this.PendingCanvasReloading) {
              this.PendingCanvasReloading = false;
              this.StartCanvasAnimation();
            }
          }
        };
        this.OnWindowResizeHandlerFunction =
          this.WindowResizeEventHandler.bind(this);
      }

      Initialize(OnInitializedCallback, OnErrorCallback) {
        if (
          typeof OnInitializedCallback != "function" ||
          typeof OnErrorCallback != "function"
        ) {
          throw TypeError(
            "Initialize(OnInitializedCallback:function(typeof this), OnErrorCallback:function(typeof this, Error))",
          );
        }
        if (!this.StyleDurationsLoaded) {
          throw Error(
            "Set style durations first. (Call SetStyleDurations(StyleDurations:number[]))",
          );
        }
        let received = 0;
        let totalreceives = 0;
        this.StyleNodeList = [];
        if (this.StyleDurations.length == 0) {
          this.CurrentThemeRemainingTime = -1;
          this.CurrentThemeIndex = 0;
          getFileFromServer(
            `./assets/theme-ui-${this.ID}.css`,
            (res) => {
              let element = document.createElement("style");
              element.style = "text/css";
              element.appendChild(document.createTextNode(res));
              this.StyleNodeList.push(element);
              this.Initialized = true;
              OnInitializedCallback(this);
            },
            (error) => {
              console.error(`UI theme CSS ${this.ID} fetch failed.`);
              OnErrorCallback(this, error);
            },
          );
        } else {
          let i = 0;
          this.CurrentThemeRemainingTime = this.StyleDurations[0];
          this.CurrentThemeIndex = 0;
          this.StyleNodeList = [];
          this.StyleNodeList.length = this.StyleDurations.length;
          totalreceives = this.StyleDurations.length;
          let HasError = false;
          for (i = 0; i < this.StyleDurations.length; i++) {
            ((index) => {
              getFileFromServer(
                `./assets/theme-ui-${this.ID}[${index}].css`,
                (res) => {
                  let element = document.createElement("style");
                  element.style = "text/css";
                  element.appendChild(document.createTextNode(res));
                  this.StyleNodeList[index] = element;
                  received++;
                  if (received >= totalreceives) {
                    if (HasError) {
                      OnErrorCallback(this, error);
                    } else {
                      this.Initialized = true;
                      OnInitializedCallback(this);
                    }
                  }
                },
                (error) => {
                  HasError = true;
                  console.error(
                    `UI theme CSS ${this.ID}[${index}] fetch failed.`,
                  );
                  received++;
                  if (received >= totalreceives) {
                    if (HasError) {
                      OnErrorCallback(this, error);
                    } else {
                      this.Initialized = true;
                      OnInitializedCallback(this);
                    }
                  }
                },
              );
            })(i);
          }
        }
      }

      StoredThemeCount() {
        return this.StyleNodeList.length;
      }

      CancelTimer() {
        if (this.Timer != null) {
          clearTimeout(this.Timer);
          this.Timer = null;
        }
      }

      CurrentTheme() {
        if (this.StyleDurations.length == 0) {
          return this.StyleNodeList[0];
        } else {
          return this.StyleNodeList[this.CurrentThemeIndex];
        }
      }

      SetCurrentTheme(ThemeIndex, SaveCurrentThemeIndexToLocalStorage) {
        if (
          typeof ThemeIndex != "number" ||
          typeof SaveCurrentThemeIndexToLocalStorage != "boolean"
        ) {
          throw TypeError(
            "SetCurrentTheme(ThemeIndex:number, SaveCurrentThemeIndexToLocalStorage:boolean)",
          );
        }
        if (ThemeIndex < 0 || ThemeIndex >= this.StyleNodeList.length) {
          throw RangeError(
            `Max index is ${this.StyleNodeList.length}, Min index is 0.`,
          );
        }
        this.CancelTimer();
        this.CurrentThemeIndex = ThemeIndex;
        this.CurrentThemeRemainingTime = this.StyleDurations[ThemeIndex];
        if (SaveCurrentThemeIndexToLocalStorage) {
          localStorage.setItem(
            `UITheme-${this.ID}-CurrentThemeIndex`,
            `${ThemeIndex}`,
          );
        }
      }

      NextTheme(
        OnNextThemeTimeOutFinishCallback,
        SaveCurrentThemeIndexToLocalStorage,
      ) {
        if (
          typeof OnNextThemeTimeOutFinishCallback != "function" ||
          typeof SaveCurrentThemeIndexToLocalStorage != "boolean"
        ) {
          throw TypeError(
            "Next(OnNextThemeTimeOutFinishCallback:function(HTMLStyleElement), SaveCurrentThemeIndexToLocalStorage:boolean)",
          );
        }
        if (this.StyleDurations.length == 0) {
          return;
        }
        if (this.Timer) {
          this.CancelTimer();
          this.CurrentThemeIndex++;
          if (this.CurrentThemeIndex >= this.StyleNodeList.length) {
            this.CurrentThemeIndex = 0;
          }
          this.CurrentThemeRemainingTime =
            this.StyleDurations[this.CurrentThemeIndex];
          if (SaveCurrentThemeIndexToLocalStorage) {
            localStorage.setItem(
              `UITheme-${this.ID}-CurrentThemeIndex`,
              `${this.CurrentThemeIndex}`,
            );
          }
          OnNextThemeTimeOutFinishCallback(this.CurrentTheme());
        }
        this.Timer = setTimeout(() => {
          this.CurrentThemeIndex++;
          if (this.CurrentThemeIndex >= this.StyleNodeList.length) {
            this.CurrentThemeIndex = 0;
          }
          this.CurrentThemeRemainingTime =
            this.StyleDurations[this.CurrentThemeIndex];
          if (SaveCurrentThemeIndexToLocalStorage) {
            localStorage.setItem(
              `UITheme-${this.ID}-CurrentThemeIndex`,
              `${this.CurrentThemeIndex}`,
            );
          }
          OnNextThemeTimeOutFinishCallback(this.CurrentTheme());
        }, this.CurrentThemeRemainingTime);
      }

      GetCurrentThemeIndexFromLocalStorage() {
        let ThemeIndex = localStorage.getItem(
          `UITheme-${this.ID}-CurrentThemeIndex`,
        );
        if (
          ThemeIndex != null &&
          parseInt(ThemeIndex) >= 0 &&
          parseInt(ThemeIndex) < this.StyleNodeList.length
        ) {
          this.SetCurrentTheme(parseInt(ThemeIndex), false);
        }
      }

      SetCanvasFrameRate(FrameRate) {
        if (typeof FrameRate != "number") {
          throw TypeError("SetCanvasFrameRate(FrameRate:number)");
        }
        this.CanvasFrameRate = FrameRate;
      }

      StartCanvasAnimation() {
        if (this.CanvasWorker == null) {
          return false;
        } else if (this.CanvasState != "Uninitialized") {
          this.PendingCanvasReloading = true;
          return true;
        }
        let canvas = document.createElement("canvas");
        let pagebackground = document.getElementById("pagebackgroundcanvas");
        canvas.setAttribute("width", `${window.innerWidth}`);
        canvas.setAttribute("height", `${window.innerHeight}`);
        canvas.classList.add("background-canvas");
        const offscreenCanvas = canvas.transferControlToOffscreen();
        pagebackground.appendChild(canvas);
        this.CanvasWorker.postMessage(
          {
            message: "Start",
            canvas: offscreenCanvas,
            framerate: this.CanvasFrameRate,
            id: 0,
          },
          [offscreenCanvas],
        );
        this.CanvasInstance = canvas;
        this.CanvasState = "Running";
        window.addEventListener("resize", this.OnWindowResizeHandlerFunction);
        return true;
      }

      PauseCanvasAnimation() {
        if (this.CanvasWorker == null || this.CanvasState != "Running") {
          return false;
        }
        this.CanvasWorker.postMessage({ message: "Stop" });
        this.CanvasState = "Stopped";
        return true;
      }

      ContinueCanvasAnimation() {
        if (this.CanvasWorker == null || this.CanvasState != "Stopped") {
          return false;
        }
        this.CanvasWorker.postMessage({ message: "Continue" });
        this.CanvasState = "Running";
        return true;
      }

      ResizeCanvas(Width, Height) {
        if (typeof Width != "number" || typeof Height != "number") {
          throw TypeError("ResizeCanvas(Width:number,Height:number)");
        }
        if (this.CanvasWorker == null) {
          return;
        }
        this.CanvasWorker.postMessage({
          message: "Resize",
          width: Width,
          height: Height,
        });
      }

      CloseCanvas() {
        if (this.CanvasWorker == null || this.CanvasState == "Uninitialized") {
          return false;
        }
        this.PendingCanvasReloading = false;
        this.CanvasWorker.postMessage({ message: "Terminate" });
        this.CanvasState = "Closing";
        window.removeEventListener(
          "resize",
          this.OnWindowResizeHandlerFunction,
        );
        return true;
      }

      WindowResizeEventHandler() {
        this.ResizeCanvas(window.innerWidth, window.innerHeight);
      }

      MoveCanvasToNewContainer(Container) {
        if (!(Container instanceof HTMLDivElement)) {
          throw TypeError("MoveCanvasToNewContainer(Container:HTMLDivElement)");
        }
        if (this.CanvasWorker == null || this.CanvasState == "Uninitialized") {
          return false;
        }
        this.CanvasInstance.remove();
        Container.appendChild(this.CanvasInstance);
        return true;
      }
    }

    document.addEventListener("onpageload", () => {
      pageloaded = true;
      if (uithemesparsed) {
        document.getElementById("setupuithemes").click();
        console.log(
          "%c UI Theme System %c READY %c UI theme subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
      }
      if (themesloaded && positionvariantsloaded && variantsettingsloaded) {
        document
          .getElementById("updatevarianttypedropdown")
          .dispatchEvent(new Event("click"));
        console.log(
          "%c Variant System %c READY %c Variant subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
        variantsystemready = true;
      }
      document
        .getElementById("dropdown-variant")
        .addEventListener("change", () => {
          setTimeout(() => {
            updateInfoDivWidth();
          }, 10);
        });
      document
        .getElementById("dropdown-uitheme")
        .addEventListener("change", () => {
          setTimeout(() => {
            updateInfoDivWidth();
          }, 10);
        });
      let chessgroundmini = document.getElementById("chessground-mini");
      let chessgroundminiboardwrapper = document.getElementById(
        "chessground-mini-board-wrapper-div",
      );
      let maindiv = document.getElementsByTagName("main")[0];
      let pgnlabel = document.getElementById("label-pgn");
      let pvinfo = document.getElementById("pvinfo");
      let lockminiboard = document.getElementById("lockminiboard");
      let operationdiv = document.getElementById(
        "chessground-mini-board-operation-div",
      );
      let startX, startY, initialX, initialY;
      chessgroundminiboardwrapper.style.cursor = "move";
      chessgroundmini.locked = false;
      chessgroundmini.pinned = false;
      window.addEventListener("resize", () => {
        updateInfoDivWidth();
        const maindivrect = maindiv.getBoundingClientRect();
        const chessgroundminirect = chessgroundmini.getBoundingClientRect();
        const scrollbarwidthright =
          window.innerWidth - maindivrect.right > 0
            ? window.innerWidth - maindivrect.right
            : 0;
        const padding = 10;
        if (chessgroundmini.pinned) {
          const windowwidth = window.innerWidth;
          if (chessgroundminirect.right > windowwidth) {
            chessgroundmini.style.left = `${windowwidth - chessgroundminirect.width - padding - scrollbarwidthright}px`;
          }
        } else {
          if (chessgroundminirect.left < maindivrect.left + padding) {
            chessgroundmini.style.left = `${maindivrect.left + padding}px`;
          } else if (chessgroundminirect.right > maindivrect.right - padding) {
            chessgroundmini.style.left = `${maindivrect.right - padding - chessgroundminirect.width}px`;
          }
        }
      });
      function onMouseMove(e) {
        chessgroundmini.style.left = `${startX + e.clientX - initialX}px`;
        chessgroundmini.style.top = `${startY + e.clientY - initialY}px`;
      }
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        chessgroundminiboardwrapper.style.cursor = "move";
        const maindivrect = maindiv.getBoundingClientRect();
        const chessgroundminirect = chessgroundmini.getBoundingClientRect();
        const padding = 10;
        const scrollbarwidthright =
          window.innerWidth - maindivrect.right > 0
            ? window.innerWidth - maindivrect.right
            : 0;
        const scrollbarwidthleft = maindivrect.left > 0 ? maindivrect.left : 0;
        if (chessgroundmini.pinned) {
          if (chessgroundminirect.left < padding + scrollbarwidthleft) {
            chessgroundmini.style.left = `${padding + scrollbarwidthleft}px`;
          } else if (
            chessgroundminirect.right >
            window.innerWidth - padding - scrollbarwidthright
          ) {
            chessgroundmini.style.left = `${window.innerWidth - chessgroundminirect.width - padding - scrollbarwidthright}px`;
          }
          if (chessgroundminirect.top < padding) {
            chessgroundmini.style.top = `${padding}px`;
          } else if (
            chessgroundminirect.bottom >
            window.innerHeight - padding
          ) {
            chessgroundmini.style.top = `${window.innerHeight - chessgroundminirect.height - padding}px`;
          }
        } else {
          chessgroundmini.style.left = `${chessgroundminirect.left - maindivrect.left}px`;
          chessgroundmini.style.top = `${chessgroundminirect.top - maindivrect.top}px`;
          chessgroundmini.style.position = "";
          if (chessgroundminirect.left < maindivrect.left + padding) {
            chessgroundmini.style.left = `${maindivrect.left + padding}px`;
          } else if (chessgroundminirect.right > maindivrect.right - padding) {
            chessgroundmini.style.left = `${maindivrect.right - padding - chessgroundminirect.width}px`;
          }
          if (chessgroundminirect.top < maindivrect.top + padding) {
            chessgroundmini.style.top = `${padding}px`;
          }
        }
      }
      function onTouchMove(e) {
        chessgroundmini.style.left = `${startX + e.touches[0].clientX - initialX}px`;
        chessgroundmini.style.top = `${startY + e.touches[0].clientY - initialY}px`;
      }
      function onTouchEnd() {
        document.removeEventListener("touchmove", onTouchMove);
        document.removeEventListener("touchend", onTouchEnd);
        document.removeEventListener("touchcancel", onTouchEnd);
        const maindivrect = maindiv.getBoundingClientRect();
        const chessgroundminirect = chessgroundmini.getBoundingClientRect();
        const padding = 10;
        const scrollbarwidthright =
          window.innerWidth - maindivrect.right > 0
            ? window.innerWidth - maindivrect.right
            : 0;
        const scrollbarwidthleft = maindivrect.left > 0 ? maindivrect.left : 0;
        if (chessgroundmini.pinned) {
          if (chessgroundminirect.left < padding + scrollbarwidthleft) {
            chessgroundmini.style.left = `${padding + scrollbarwidthleft}px`;
          } else if (
            chessgroundminirect.right >
            window.innerWidth - padding - scrollbarwidthright
          ) {
            chessgroundmini.style.left = `${window.innerWidth - chessgroundminirect.width - padding - scrollbarwidthright}px`;
          }
          if (chessgroundminirect.top < padding) {
            chessgroundmini.style.top = `${padding}px`;
          } else if (
            chessgroundminirect.bottom >
            window.innerHeight - padding
          ) {
            chessgroundmini.style.top = `${window.innerHeight - chessgroundminirect.height - padding}px`;
          }
        } else {
          chessgroundmini.style.left = `${chessgroundminirect.left - maindivrect.left}px`;
          chessgroundmini.style.top = `${chessgroundminirect.top - maindivrect.top}px`;
          chessgroundmini.style.position = "";
          if (chessgroundminirect.left < maindivrect.left + padding) {
            chessgroundmini.style.left = `${maindivrect.left + padding}px`;
          } else if (chessgroundminirect.right > maindivrect.right - padding) {
            chessgroundmini.style.left = `${maindivrect.right - padding - chessgroundminirect.width}px`;
          }
          if (chessgroundminirect.top < maindivrect.top + padding) {
            chessgroundmini.style.top = `${padding}px`;
          }
        }
      }
      document.addEventListener("click", (event) => {
        if (
          !event.isTrusted ||
          (event.button !== undefined && event.button !== 0)
        ) {
          return;
        }
        if (
          !chessgroundmini.locked &&
          !chessgroundmini.contains(event.target) &&
          !pgnlabel.contains(event.target) &&
          !pvinfo.contains(event.target)
        ) {
          chessgroundmini.style.display = "none";
        }
      });
      chessgroundminiboardwrapper.addEventListener("mousedown", (event) => {
        event.stopPropagation();
        if (
          !event.isTrusted ||
          (event.button !== undefined && event.button !== 0)
        ) {
          return;
        }
        const chessgroundminirect = chessgroundmini.getBoundingClientRect();
        if (!chessgroundmini.pinned) {
          chessgroundmini.style.left = `${chessgroundminirect.left}px`;
          chessgroundmini.style.top = `${chessgroundminirect.top}px`;
          chessgroundmini.style.position = "fixed";
        }
        startX = chessgroundminirect.left;
        startY = chessgroundminirect.top;
        initialX = event.clientX;
        initialY = event.clientY;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        chessgroundminiboardwrapper.style.cursor = "grabbing";
      });
      chessgroundminiboardwrapper.addEventListener("touchstart", (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (event.touches && event.touches.length > 1) {
          return;
        }
        const chessgroundminirect = chessgroundmini.getBoundingClientRect();
        if (!chessgroundmini.pinned) {
          chessgroundmini.style.left = `${chessgroundminirect.left}px`;
          chessgroundmini.style.top = `${chessgroundminirect.top}px`;
          chessgroundmini.style.position = "fixed";
        }
        startX = chessgroundminirect.left;
        startY = chessgroundminirect.top;
        initialX = event.touches[0].clientX;
        initialY = event.touches[0].clientY;
        document.addEventListener("touchmove", onTouchMove);
        document.addEventListener("touchend", onTouchEnd);
        document.addEventListener("touchcancel", onTouchEnd);
      });

      setTimeout(() => {
        document.dispatchEvent(new Event("initializeripples"));
      }, 10);

      /*pgnlabel.addEventListener("mousemove", Throttle((event) => {
            event.stopPropagation();
            if (chessgroundmini.style.display != "none") {
                const rect = maindiv.getBoundingClientRect();
                const chessgroundministyle = window.getComputedStyle(chessgroundmini);
                const chessgroundminiwidth = parseFloat(chessgroundministyle.width);
                const chessgroundminiheight = parseFloat(chessgroundministyle.height);
                const padding = 10;
                const maindivwidth = rect.width;
                const maindivheight = rect.height;
                const offsetX = event.clientX - rect.left;
                const offsetY = event.clientY - rect.top;
                let finalX = offsetX;
                let finalY = offsetY + 40;
                if (finalX + chessgroundminiwidth > maindivwidth - 2 * padding) {
                    finalX -= chessgroundminiwidth;
                }
                chessgroundmini.style.left = `${finalX}px`;
                chessgroundmini.style.top = `${finalY}px`;
            }
        }, 50));*/
    });

    document.addEventListener("uithemesparsed", () => {
      uithemesparsed = true;
      if (pageloaded) {
        document.getElementById("setupuithemes").click();
        console.log(
          "%c UI Theme System %c READY %c UI theme subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
      }
    });

    document.addEventListener("positionvariantsloaded", () => {
      positionvariantsloaded = true;
      if (pageloaded && themesloaded && variantsettingsloaded) {
        document
          .getElementById("updatevarianttypedropdown")
          .dispatchEvent(new Event("click"));
        console.log(
          "%c Variant System %c READY %c Variant subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
        variantsystemready = true;
      }
    });

    document.addEventListener("themesloaded", () => {
      themesloaded = true;
      if (pageloaded && positionvariantsloaded && variantsettingsloaded) {
        document
          .getElementById("updatevarianttypedropdown")
          .dispatchEvent(new Event("click"));
        console.log(
          "%c Variant System %c READY %c Variant subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
        variantsystemready = true;
      }
    });

    document.addEventListener("variantsettingsloaded", () => {
      variantsettingsloaded = true;
      if (pageloaded && positionvariantsloaded && themesloaded) {
        document
          .getElementById("updatevarianttypedropdown")
          .dispatchEvent(new Event("click"));
        console.log(
          "%c Variant System %c READY %c Variant subsystem is ready.",
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #4bc729",
          "",
        );
        variantsystemready = true;
      }
    });

    document.addEventListener("uilayoutchange", (event) => {
      if (currentthemeobj instanceof UIThemeObject) {
        if (event.detail.message == null) {
          currentthemeobj.MoveCanvasToNewContainer(
            document.getElementById("pagebackgroundcanvas"),
          );
        } else if (typeof event.detail.message == "string") {
          let element = document.getElementById(event.detail.message);
          currentthemeobj.MoveCanvasToNewContainer(
            element == null
              ? document.getElementById("pagebackgroundcanvas")
              : element,
          );
        }
      }
    });

    document.addEventListener("visibilitychange", () => {
      if (currentthemeobj instanceof UIThemeObject) {
        if (document.visibilityState === "hidden") {
          currentthemeobj.PauseCanvasAnimation();
        } else if (document.visibilityState === "visible") {
          currentthemeobj.ContinueCanvasAnimation();
        }
      }
    });

    document.addEventListener("initializeripples", () => {
      let list = document.querySelectorAll(".ripple");
      let val = null;
      let i = 0;
      for (i = 0; i < list.length; i++) {
        val = list.item(i);
        if (val instanceof HTMLElement) {
          if (!Array.isArray(val.rippleelements)) {
            val.rippleelements = [];
            val.addEventListener("mousedown", function (event) {
              if (!event.isTrusted) {
                return;
              }
              const targetrect = this.getBoundingClientRect();
              const x = event.clientX - targetrect.left;
              const y = event.clientY - targetrect.top;
              const mx = targetrect.right - event.clientX;
              const my = targetrect.bottom - event.clientY;
              let radius = Math.ceil(
                2 *
                  Math.sqrt(
                    Math.max(
                      x * x + y * y,
                      x * x + my * my,
                      mx * mx + y * y,
                      mx * mx + my * my,
                    ),
                  ),
              );
              let ripplewrapper = document.createElement("div");
              ripplewrapper.classList.add("ripple-wrapper");
              ripplewrapper.style.top = `${this.scrollTop}px`;
              ripplewrapper.style.left = `${this.scrollLeft}px`;
              let rippleelem = document.createElement("span");
              rippleelem.classList.add("ripple-effect");
              rippleelem.style.left = `${x}px`;
              rippleelem.style.top = `${y}px`;
              ripplewrapper.appendChild(rippleelem);
              this.appendChild(ripplewrapper);
              this.rippleelements.push(ripplewrapper);
              setTimeout(() => {
                rippleelem.style.width =
                  rippleelem.style.height = `${radius}px`;
              }, 10);
            });
            val.addEventListener("mouseleave", function (event) {
              if (!event.isTrusted) {
                return;
              }
              let i = 0;
              if (Array.isArray(this.rippleelements)) {
                let style = null;
                for (i = 0; i < this.rippleelements.length; i++) {
                  style = window.getComputedStyle(this.rippleelements[i]);
                  if (
                    parseFloat(style.opacity) == 0 ||
                    style.display == "none"
                  ) {
                    this.rippleelements[i].remove();
                    this.rippleelements.splice(i, 1);
                    i--;
                  } else {
                    this.rippleelements[i].classList.add("ripple-fade-out");
                  }
                }
              }
            });
            val.addEventListener("mouseup", function (event) {
              if (!event.isTrusted) {
                return;
              }
              let i = 0;
              if (Array.isArray(this.rippleelements)) {
                let style = null;
                for (i = 0; i < this.rippleelements.length; i++) {
                  style = window.getComputedStyle(this.rippleelements[i]);
                  if (
                    parseFloat(style.opacity) == 0 ||
                    style.display == "none"
                  ) {
                    this.rippleelements[i].remove();
                    this.rippleelements.splice(i, 1);
                    i--;
                  } else {
                    this.rippleelements[i].classList.add("ripple-fade-out");
                  }
                }
              }
            });
            val.addEventListener("scroll", function (event) {
              let i = 0;
              if (Array.isArray(this.rippleelements)) {
                for (i = 0; i < this.rippleelements.length; i++) {
                  this.rippleelements[i].style.top = `${this.scrollTop}px`;
                  this.rippleelements[i].style.left = `${this.scrollLeft}px`;
                }
              }
            });
          }
        }
      }
    });

    //Remove duplicated elements
    function uniqArr(arr) {
      var newArr = new Set(arr);
      return Array.from(newArr);
    }

    //Throttle function, used to prevent lag when operating DOM objects.
    function Throttle(func, wait) {
      let timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(() => {
            func.apply(this, arguments);
            timer = null;
          }, wait);
          func.apply(this, arguments);
        }
      };
    }

    function OpenURL(url) {
      let link = document.createElement("a");
      link.href = url;
      link.id = "tmplink";
      link.target = "_blank";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function getFileFromServer(url, doneCallback, errorCallback) {
      if (
        typeof url != "string" ||
        typeof doneCallback != "function" ||
        (typeof errorCallback != "function" && errorCallback != undefined)
      ) {
        throw TypeError(
          "getFileFromServer(url:string, doneCallback:function(string), errorCallback:function(Error) | undefined)",
        );
      }
      fetch(url)
        .then((response) => {
          if (!response.ok) {
            throw new Error(
              `Network response error: Code ${response.status} (${response.statusText})`,
            );
          }
          return response.text();
        })
        .then((content) => {
          doneCallback(content);
        })
        .catch((error) => {
          console.error(
            `There has been a problem when fetching "${url}":`,
            error,
          );
          if (typeof errorCallback == "function") {
            errorCallback(error);
          }
        });
    }

    function setVariantStylesheet(variant) {
      document.getElementById("current-variant-stylesheet").href =
        `./assets/theme-variant-${variant}.css`;
    }

    function LinearTransition(
      start,
      end,
      step,
      interval,
      operation,
      doneCallBack,
    ) {
      if (
        typeof start != "number" ||
        typeof end != "number" ||
        typeof step != "number" ||
        typeof interval != "number" ||
        typeof operation != "function" ||
        typeof doneCallBack != "function"
      ) {
        throw TypeError(
          "FadeInOut(start:number, end:number, step:number, interval:number, operation:function(number), doneCallBack:function())",
        );
      }
      let i = start;
      const operate = () => {
        operation(i);
        if ((step > 0 && i >= end) || (step < 0 && i <= end)) {
          doneCallBack();
        } else {
          setTimeout(operate, interval);
        }
        i += step;
      };
      setTimeout(operate, interval);
    }

    const copyText = async (val) => {
      if (navigator.clipboard && navigator.permissions) {
        await navigator.clipboard.writeText(val);
      } else {
        const textArea = document.createElement("textArea");
        textArea.value = val;
        textArea.style.width = 0;
        textArea.style.position = "fixed";
        textArea.style.left = "-999px";
        textArea.style.top = "10px";
        textArea.setAttribute("readonly", "readonly");
        document.body.appendChild(textArea);

        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
      }
    };

    const formatMB = (n) => {
      return (n ? (n / 1e6).toPrecision(3) : "?") + "MB";
    };

    const isSupported = () => {
      if (typeof WebAssembly !== "object") return false;
      const source = Uint8Array.from([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 7, 8,
        1, 4, 116, 101, 115, 116, 0, 0, 10, 15, 1, 13, 0, 65, 0, 253, 17, 65, 0,
        253, 17, 253, 186, 1, 11,
      ]);
      if (
        typeof WebAssembly.validate !== "function" ||
        !WebAssembly.validate(source)
      )
        return false;
      if (typeof Atomics !== "object") return false;
      if (typeof SharedArrayBuffer !== "function") {
        console.log("SharedArrayBuffer not enabled!");
        return false;
      }
      if (typeof FileReader === "undefined") {
        return false;
      }
      if (typeof WebSocket === "undefined") {
        return false;
      }
      return true;
    };

    const RequestProgress = ({ attrs: { url, onFinishDownload } }) => {
      let state = "INIT"; // 'LOADING', 'DONE', 'FAILED'
      let loaded = 0;
      let total = 0;

      const oninit = () => {
        state = "LOADING";
        m.request({
          url: url,
          method: "GET",
          responseType: "arraybuffer",
          headers: { Accept: "*/*" },
          config: (xhr) => {
            xhr.onprogress = (e) => {
              // TODO:
              // When gzip compressed, the value of "loaded/total" gets messed up.
              // On Chrome, "loaded" is the value after decompression, but on the other hand,
              // On Firefox, "loaded" is the value before decompression.
              loaded = e.loaded;
              total =
                e.total ||
                Number(
                  e.target.getResponseHeader("x-decompressed-content-length"),
                );
              m.redraw();
            };
          },
        }).then(
          (response) => {
            state = "DONE";
            onFinishDownload(response);
          },
          (e) => {
            console.error(e);
            state = "FAILED";
            onFinishDownload(null);
          },
        );
      };

      const view = () => {
        const fraction =
          total == -1 ? `?MB/?MB` : `${formatMB(loaded)}/${formatMB(total)}`;
        return m("span", [
          `${fraction} [${state}] `,
          m(
            "span",
            {
              style: "cursor: pointer;",
              onclick: () =>
                window.alert(
                  "On some browsers, download size might look contradictory due to file compression.",
                ),
            },
            "[?]",
          ),
        ]);
      };

      return { oninit, view };
    };

    const LoadVariantSettings = (side, clientdata) => {
      function StartLoad(data, dispatchevent) {
        if (typeof data == "string") {
          let rawText = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n");
          let i = 0;
          let variantdescriptionitem = [];
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            variantdescriptionitem = rawText[i].split("|");
            if (variantdescriptionitem.length != 5) {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Syntax error.`,
              );
              continue;
            }
            if (variantsettings[0].includes(variantdescriptionitem[0])) {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant ${variantdescriptionitem[0]} already exists.`,
              );
              continue;
            }
            if (variantdescriptionitem[0] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant ID must not be null.`,
              );
              continue;
            }
            if (variantdescriptionitem[1] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant type must not be null.`,
              );
              continue;
            }
            if (variantdescriptionitem[2] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant name must not be null.`,
              );
              continue;
            }
            variantsettings[0].push(variantdescriptionitem[0]);
            variantsettings[1].push(variantdescriptionitem[1]);
            variantsettings[2].push(variantdescriptionitem[2]);
            variantsettings[3].push(variantdescriptionitem[3]);
            variantsettings[4].push(variantdescriptionitem[4]);
          }
          //console.log(variantsettings);
        } else {
          console.error(
            `Bad data type from variantsettings.txt: ${typeof data}`,
          );
        }
        if (dispatchevent) {
          document.dispatchEvent(new Event("variantsettingsloaded"));
        }
      }
      if (side == "server") {
        this.getFileFromServer("./variantsettings.txt", (res) => {
          console.log("res3:", res);
          StartLoad(res, true);
        });
      } else if (side == "client") {
        StartLoad(clientdata, false);
      }
    };

    const LoadThemes = () => {
      themes = [[], [], []];
      themenames = [[], []];
      function StartLoad(data, namedata) {
        if (typeof data == "string") {
          data = data.replace(/\r\n/g, "\n");
          data = data.replace(/\r/g, "\n");
          let rawText = data.split("\n");
          console.log("theme data:", rawText);
          let i = 0;
          let j = 0;
          let css_name = "";
          let index = 0;
          let require_list = [];
          let themesettings = [];
          let apply_to_all_list = [];
          let loaded_css_list = [];
          let require_board_list = [];
          let board_apply_to_all_list = [];
          let themeavailable = [];
          let boardthemeavailable = [];
          let link = null;
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 3) {
              console.warn(`At line ${i + 1} in themes.txt: Bad syntax\n`);
              continue;
            }
            themeavailable = themesettings[1].split(",");
            boardthemeavailable = themesettings[2].split(",");
            if (themeavailable.length == 1 && themeavailable[0] == "") {
              themeavailable = [];
            }
            if (
              boardthemeavailable.length == 1 &&
              boardthemeavailable[0] == ""
            ) {
              boardthemeavailable = [];
            }
            if (
              (themesettings[1].length < 1 && themesettings[2].length < 1) ||
              themeavailable.includes("") ||
              boardthemeavailable.includes("")
            ) {
              console.warn(
                `At line ${i + 1} in themes.txt: Piece and Board style names must not be both null or contain null element\n`,
              );
              continue;
            }
            if (themesettings[1].length > 0) {
              require_list = themeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              themeavailable = themeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_list.length; j++) {
                if (themes[0].includes(require_list[j].substring(1))) {
                  index = themes[0].indexOf(require_list[j].substring(1));
                  themeavailable = themeavailable.concat(themes[1][index]);
                } else {
                  console.warn(
                    `At line ${i + 1} in themes.txt: Variant ${require_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              themeavailable = uniqArr(themeavailable);
            }
            if (themesettings[2].length > 0) {
              require_board_list = boardthemeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              boardthemeavailable = boardthemeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_board_list.length; j++) {
                if (themes[0].includes(require_board_list[j].substring(1))) {
                  index = themes[0].indexOf(require_board_list[j].substring(1));
                  boardthemeavailable = boardthemeavailable.concat(
                    themes[2][index],
                  );
                } else {
                  console.warn(
                    `At line ${i + 1} in themes.txt: Variant ${require_board_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              boardthemeavailable = uniqArr(boardthemeavailable);
            }
            if (themesettings[0] == "*") {
              if (themesettings[1].length > 0) {
                apply_to_all_list = apply_to_all_list.concat(themeavailable);
              }
              if (themesettings[2].length > 0) {
                board_apply_to_all_list =
                  board_apply_to_all_list.concat(boardthemeavailable);
              }
            } else if (themes[0].includes(themesettings[0])) {
              if (themesettings[1].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[1][index] = uniqArr(
                  themes[1][index].concat(themeavailable),
                );
              }
              if (themesettings[2].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[2][index] = uniqArr(
                  themes[2][index].concat(boardthemeavailable),
                );
              }
            } else {
              themeavailable = uniqArr(
                themeavailable.concat(apply_to_all_list),
              );
              boardthemeavailable = uniqArr(
                boardthemeavailable.concat(board_apply_to_all_list),
              );
              themes[0].push(themesettings[0]);
              themes[1].push(themeavailable);
              themes[2].push(boardthemeavailable);
            }
          }
          for (i = 0; i < themes[0].length; i++) {
            for (j = 0; j < themes[1][i].length; j++) {
              css_name = "theme-piece-" + themes[1][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
            for (j = 0; j < themes[2][i].length; j++) {
              css_name = "theme-board-" + themes[2][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
          }

          // Needs to be after piece and board stylesheets to override them.
          css_name = "theme-variant-";
          if (!loaded_css_list.includes(css_name)) {
            loaded_css_list.push(css_name);
            link = document.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("href", "./assets/" + css_name + ".css");
            link.setAttribute("id", "current-variant-stylesheet");
            document.head.appendChild(link);
          }

          console.log(themes);
        } else {
          console.error(`Bad data type from themes.txt: ${typeof data}`);
        }

        if (typeof namedata == "string") {
          namedata = namedata.replace(/\r\n/g, "\n");
          namedata = namedata.replace(/\r/g, "\n");
          rawText = namedata.split("\n");
          console.log("theme name:", rawText);
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 2) {
              console.warn(`At line ${i + 1} in themename.txt: Bad syntax\n`);
              continue;
            }
            themenames[0].push(themesettings[0]);
            themenames[1].push(themesettings[1]);
          }

          console.log(themenames);
        } else {
          console.error(`Bad data type from themename.txt: ${typeof namedata}`);
        }

        document.dispatchEvent(new Event("themesloaded"));
      }
      this.getFileFromServer("./themes.txt", (res) => {
        console.log("res:", res);
        this.getFileFromServer(
          "./themenames.txt",
          (res2) => {
            console.log("res2:", res2);
            StartLoad(res, res2);
          },
          () => {
            console.warn("themes.txt load failed.");
            this.getFileFromServer("./themenames.txt", (res2) => {
              console.log("res2:", res2);
              StartLoad("", res2);
            });
          },
        );
      });
    };

    const LoadUIThemes = () => {
      let received = 0;
      let totalreceives = 0;
      function ClearInvalid() {
        let i = 0;
        for (i = 0; i < uithemes[0].length; i++) {
          if (!uithemes[1][i].Initialized) {
            uithemes[0].splice(i, 1);
            uithemes[1].splice(i, 1);
            i--;
          }
        }
      }
      function StartLoad(data) {
        if (typeof data == "string") {
          let i = 0;
          let j = 0;
          let rawText = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n");
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i] == "" || rawText[i].startsWith("#")) {
              continue;
            }
            let uithemesettings = rawText[i].split("|");
            if (uithemesettings.length < 2 && uithemesettings.length > 4) {
              console.warn(`At line ${i + 1} in uithemes.txt: Bad syntax\n`);
              continue;
            }
            if (uithemesettings[0] == "" || uithemesettings[1] == "") {
              console.warn(
                `At line ${i + 1} in uithemes.txt: ID and display name must not be empty.\n`,
              );
              continue;
            }
            if (uithemes[0].indexOf(uithemesettings[0]) >= 0) {
              console.warn(
                `At line ${i + 1} in uithemes.txt: Theme ${uithemesettings[0]} already exists.\n`,
              );
              continue;
            }
            let multiuithemedurations = [];
            let canvasjs = "";
            let canvasframerate = 50;
            if (uithemesettings.length == 3 || uithemesettings.length == 4) {
              let durations = uithemesettings[2].split(",");
              if (uithemesettings[2] == "" && uithemesettings.length == 3) {
                console.warn(
                  `At line ${i + 1} in uithemes.txt: Bad syntax for sub-theme duration.\n`,
                );
                continue;
              }
              let haserror = false;
              if (uithemesettings[2] != "") {
                for (j = 0; j < durations.length; j++) {
                  if (isNaN(parseInt(durations[j]))) {
                    console.warn(
                      `At token ${j + 1} of sub-theme in line ${i + 1} in uithemes.txt: Sub-theme duration must be a positive integer.\n`,
                    );
                    haserror = true;
                    break;
                  } else {
                    let durationlength = parseInt(durations[j]);
                    if (durationlength < 1) {
                      console.warn(
                        `At token ${j + 1} of sub-theme in line ${i + 1} in uithemes.txt: Sub-theme duration must be a positive integer.\n`,
                      );
                      haserror = true;
                      break;
                    }
                    multiuithemedurations.push(durationlength);
                  }
                }
              }
              if (haserror) {
                continue;
              }
              if (uithemesettings.length == 4) {
                let canvasoption = uithemesettings[3].split(",");
                if (canvasoption.length != 2) {
                  console.warn(
                    `At line ${i + 1} in uithemes.txt: Bad syntax for canvas settings.\n`,
                  );
                  continue;
                }
                if (canvasoption[0] == "") {
                  console.warn(
                    `At line ${i + 1} in uithemes.txt: Canvas worker name must not be null.\n`,
                  );
                  continue;
                } else {
                  canvasjs = canvasoption[0];
                }
                let frameratenum = parseInt(canvasoption[1]);
                if (isNaN(frameratenum) || frameratenum < 1) {
                  console.warn(
                    `At line ${i + 1} in uithemes.txt: Frame rate must be a positive integer.\n`,
                  );
                  continue;
                } else {
                  canvasframerate = frameratenum;
                }
              }
            }
            let uithemeobj = new UIThemeObject(
              uithemesettings[0],
              uithemesettings[1],
            );
            uithemeobj.SetStyleDurations(multiuithemedurations);
            if (canvasjs != "") {
              try {
                uithemeobj.SetCanvasWorker(canvasjs);
              } catch (error) {
                console.error("Error loading worker:", error);
                console.warn(
                  `At line ${i + 1} in uithemes.txt: Unable to initialize worker.\n`,
                );
                continue;
              }
              uithemeobj.SetCanvasFrameRate(canvasframerate);
            }
            uithemes[0].push(uithemesettings[0]);
            uithemes[1].push(uithemeobj);
          }
          totalreceives = uithemes[0].length;
          for (i = 0; i < uithemes[0].length; i++) {
            ((index) => {
              uithemes[1][index].Initialize(
                () => {
                  received++;
                  uithemes[1][index].GetCurrentThemeIndexFromLocalStorage();
                  if (received >= totalreceives) {
                    ClearInvalid();
                    document.dispatchEvent(new Event("uithemesparsed"));
                  }
                },
                () => {
                  received++;
                  if (received >= totalreceives) {
                    ClearInvalid();
                    document.dispatchEvent(new Event("uithemesparsed"));
                  }
                },
              );
            })(i);
          }
        } else {
          console.error(`Bad data type from uithemes.txt: ${typeof data}`);
        }
      }
      getFileFromServer(
        "./uithemes.txt",
        (res) => {
          StartLoad(res);
        },
        () => {
          console.error(
            "Failed to load uithemes.txt. UI themes are not available.",
          );
        },
      );
    };

    function ApplyUIThemeStyleNode(HTMLStyleElementObject) {
      if (HTMLStyleElementObject instanceof HTMLStyleElement) {
        let chi = document.getElementsByClassName("bg-animation");
        let i = 0;
        for (i = 0; i < chi.length; i++) {
          chi[i].style.display = "none";
        }
        const pagebackground = document.getElementById("pagebackground");
        const htmlComputedStyle = window.getComputedStyle(pagebackground);
        const BGBefore = htmlComputedStyle.backgroundImage;
        const BGBeforeSize = htmlComputedStyle.backgroundSize;
        const BGBeforeRepeat = htmlComputedStyle.backgroundRepeat;
        const BGBeforePosition = htmlComputedStyle.backgroundPosition;
        const BGBeforeAttachment = htmlComputedStyle.backgroundAttachment;
        if (currentuicss != null) {
          document.head.removeChild(currentuicss);
        }
        currentuicss = HTMLStyleElementObject;
        document.head.appendChild(currentuicss);
        const htmlComputedStyleAfter = window.getComputedStyle(pagebackground);
        const BGAfter = htmlComputedStyleAfter.backgroundImage;
        const BGAfterSize = htmlComputedStyleAfter.backgroundSize;
        const BGAfterRepeat = htmlComputedStyleAfter.backgroundRepeat;
        const BGAfterPosition = htmlComputedStyleAfter.backgroundPosition;
        const BGAfterAttachment = htmlComputedStyleAfter.backgroundAttachment;

        const tmpbg = document.createElement("div");
        const tmpbg2 = document.createElement("div");

        if (BGBefore != "none") {
          tmpbg.className = "bg-animation";
          tmpbg.style.backgroundImage = BGBefore;
          tmpbg.style.backgroundSize = BGBeforeSize;
          tmpbg.style.backgroundRepeat = BGBeforeRepeat;
          tmpbg.style.backgroundPosition = BGBeforePosition;
          tmpbg.style.backgroundAttachment = BGBeforeAttachment;
          tmpbg.className = "backgroundimg";
          tmpbg.style.opacity = "1";
          tmpbg.style.zIndex = "-51";
          document.body.appendChild(tmpbg);
        }
        if (BGAfter != "none") {
          tmpbg2.className = "bg-animation";
          tmpbg2.style.backgroundImage = BGAfter;
          tmpbg2.style.backgroundSize = BGAfterSize;
          tmpbg2.style.backgroundRepeat = BGAfterRepeat;
          tmpbg2.style.backgroundPosition = BGAfterPosition;
          tmpbg2.style.backgroundAttachment = BGAfterAttachment;
          tmpbg2.className = "backgroundimg";
          tmpbg2.style.opacity = "0";
          tmpbg2.style.zIndex = "-52";
          document.body.appendChild(tmpbg2);
        }
        if (BGBefore != "none" && BGAfter != "none") {
          pagebackground.style.opacity = "0";
          LinearTransition(
            1,
            0,
            -0.02,
            10,
            (val) => {
              tmpbg.style.opacity = `${val}`;
              tmpbg2.style.opacity = `${1 - val}`;
            },
            () => {
              pagebackground.style.opacity = "1";
              document.body.removeChild(tmpbg);
              document.body.removeChild(tmpbg2);
            },
          );
        } else if (BGBefore != "none") {
          LinearTransition(
            1,
            0,
            -0.02,
            10,
            (val) => {
              tmpbg.style.opacity = `${val}`;
            },
            () => {
              document.body.removeChild(tmpbg);
            },
          );
        } else if (BGAfter != "none") {
          pagebackground.style.opacity = "0";
          LinearTransition(
            0,
            1,
            0.02,
            10,
            (val) => {
              tmpbg2.style.opacity = `${val}`;
            },
            () => {
              pagebackground.style.opacity = "1";
              document.body.removeChild(tmpbg2);
            },
          );
        }
      } else {
        throw TypeError(
          "ApplyUIThemeStyleNode(HTMLStyleElementObject:HTMLStyleElement)",
        );
      }
    }

    function getThemeName(themeid) {
      if (typeof themeid != "string") {
        return null;
      }
      let index = themenames[0].indexOf(themeid);
      if (index < 0) {
        return themeid + " ⚠";
      } else {
        return themenames[1][index];
      }
    }

    function getVariantType(variant) {
      if (typeof variant != "string") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        return "<|NC|>";
      } else {
        return variantsettings[1][index];
      }
    }

    function getVariantName(variant, useplaceholder, showid) {
      if (
        typeof variant != "string" ||
        typeof useplaceholder != "boolean" ||
        typeof showid != "boolean"
      ) {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return variant;
        } else {
          return undefined;
        }
      } else {
        if (showid) {
          return variantsettings[2][index] + ` (${variant})`;
        } else {
          return variantsettings[2][index];
        }
      }
    }

    function getVariantDescription(variant, useplaceholder) {
      if (typeof variant != "string" || typeof useplaceholder != "boolean") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return variant;
        } else {
          return undefined;
        }
      } else {
        return variantsettings[3][index];
      }
    }

    function getVariantWikiPageURL(variant, useplaceholder) {
      if (typeof variant != "string" || typeof useplaceholder != "boolean") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return "";
        } else {
          return undefined;
        }
      } else {
        return variantsettings[4][index];
      }
    }

    function updateInfoDivWidth() {
      let cutoffwidth = 65;
      let rootdiv = document.getElementById("root");
      let rootdivstyle = window.getComputedStyle(rootdiv);
      let rootwidth = parseFloat(rootdivstyle.width);
      let rootpadding =
        parseFloat(rootdivstyle.paddingLeft) +
        parseFloat(rootdivstyle.paddingRight);
      let boardrect = document
        .getElementById("chessground-board")
        .getBoundingClientRect();
      let toppocketrect = document
        .getElementById("pocket-top")
        .getBoundingClientRect();
      let bottompocketrect = document
        .getElementById("pocket-bottom")
        .getBoundingClientRect();
      let boardwidth = Math.max(
        boardrect.width,
        toppocketrect.width,
        bottompocketrect.width,
      );
      let infodiv = document.getElementById("info");
      let infodivstyle = window.getComputedStyle(infodiv);
      let infodivmargin =
        parseFloat(infodivstyle.marginLeft) +
        parseFloat(infodivstyle.marginRight);
      let finalwidth =
        rootwidth - boardwidth - infodivmargin - rootpadding - cutoffwidth;
      if (finalwidth < 240) {
        if (finalwidth < 20) {
          document.body.style.overflowX = "scroll";
        } else {
          document.body.style.overflowX = "hidden";
        }
        document.getElementById("timers").classList.remove("vertical");
        document.getElementById("evalbar").classList.remove("round");
        document.getElementById("outputs").classList.add("vertical");
        let finalwidth2 = rootwidth - infodivmargin - rootpadding - cutoffwidth;
        document.getElementById("output2").style.width =
          document.getElementById("currentboardfen").style.width =
          document.getElementById("label-pgn").style.width =
          document.getElementById("enginecmddiv").style.width =
          document.getElementById("positioninfo").style.width =
          document.getElementById("evalinfo").style.width =
          document.getElementById("pvinfo").style.width =
          document.getElementById("sannotation").style.maxWidth =
            `${finalwidth2}px`;
      } else {
        document.body.style.overflowX = "hidden";
        document.getElementById("outputs").classList.remove("vertical");
        if (finalwidth < 420) {
          document.getElementById("evalbar").classList.add("round");
        } else {
          document.getElementById("evalbar").classList.remove("round");
        }
        if (finalwidth < 640) {
          document.getElementById("timers").classList.add("vertical");
        } else {
          document.getElementById("timers").classList.remove("vertical");
        }
        document.getElementById("output2").style.width =
          document.getElementById("currentboardfen").style.width =
          document.getElementById("label-pgn").style.width =
          document.getElementById("enginecmddiv").style.width =
          document.getElementById("positioninfo").style.width =
          document.getElementById("evalinfo").style.width =
          document.getElementById("pvinfo").style.width =
          document.getElementById("sannotation").style.maxWidth =
            `${finalwidth}px`;
      }
    }

    const App = () => {
      let stockfish = null;
      let stockfish_state = "INIT"; // 'READY', 'FAILED'
      let engineoutput = "";
      let first_engine_output = "";
      let second_engine_output = "";
      let analysis_engine_output = "";
      let show_dests = true;
      let adjudicate = true;
      let analysis_mode = false;
      let play_white = false;
      let play_black = false;
      let play_move = false;
      let review_mode = false;
      let board_setup_mode = false;
      let advanced_time_control = false;
      let during_play = false;
      let select_move_dialog = false;
      let in_browser_fsf_hash = 16;
      let random_mover_white = false;
      let random_mover_black = false;
      let white_start_time = 0;
      let black_start_time = 0;
      let white_remaining_time = 0;
      let black_remaining_time = 0;
      let white_moving_time_list = [];
      let black_moving_time_list = [];
      let white_time_gain = 0;
      let black_time_gain = 0;
      let white_timer_type = "infinite";
      let black_timer_type = "infinite";
      let timer_interval = 100;
      let white_byoyomi_time_per_period = 0;
      let black_byoyomi_time_per_period = 0;
      let white_byoyomi_period_count = 0;
      let black_byoyomi_period_count = 0;
      let white_remaining_byoyomi_periods = 0;
      let black_remaining_byoyomi_periods = 0;
      let white_time_margin = 0;
      let black_time_margin = 0;
      let timeout_margin = 500;
      let previous_mover = "";
      let white_time_exceeded = false;
      let black_time_exceeded = false;
      let previous_reality_time = -1;
      let move_finish_timer_updating = false;
      let changing_variant_type = false;
      let clear_log = true;
      let game_list = [];
      let throttle_threshold = 400; //in milliseconds, increase this if the GUI lags
      let engine_match_mode = false;
      let fischer_random_mode = false;
      let during_engine_match = false;
      let engine_match_total_game_count = 0;
      let engine_match_played_game_count = 0;
      let engine_match_white_wins = 0;
      let engine_match_black_wins = 0;
      let engine_match_draws = 0;
      let engine_match_game_list = [];
      let timer;

      let variants = [];
      let varianttypes = [];

      let engine_list = [];

      document.addEventListener("gameend", (event) => {
        if (engine_match_mode && during_engine_match) {
          if (event.detail.result == "1-0") {
            engine_match_white_wins++;
          } else if (event.detail.result == "0-1") {
            engine_match_black_wins++;
          } else if (event.detail.result == "1/2-1/2") {
            engine_match_draws++;
          }
          engine_match_played_game_count++;
          document.getElementById("enginematchinfo").innerText =
            `Games played: ${engine_match_played_game_count} | Total games to play: ${engine_match_total_game_count} | First engine (WHITE) wins: ${engine_match_white_wins} | Second engine (BLACK) wins: ${engine_match_black_wins} | Draws: ${engine_match_draws}`;
          if (fgs) {
            let info = fgs.GetCurrentGameInformation(window.ffishlib);
            engine_match_game_list.push(
              new fgs.Game(
                info.Variant,
                info.FEN,
                info.UCIMoves,
                info.Result,
                "Fairy-Stockfish Playground engine match",
                info.Site,
                info.Date,
                engine_match_played_game_count,
                info.FirstPlayerName,
                info.SecondPlayerName,
                0,
                0,
                "0000",
                "0000",
                0.0,
                info.Termination,
                fischer_random_mode,
              ),
            );
          }
          if (engine_match_played_game_count < engine_match_total_game_count) {
            setTimeout(() => {
              document.getElementById("restart").click();
              play_white = true;
              play_black = true;
              if (advanced_time_control) {
                setTimeout(() => {
                  document.getElementById("gamestart").click();
                }, 500);
              } else {
                setTimeout(() => {
                  document.getElementById("set").click();
                }, 500);
              }
            }, 500);
          } else {
            setTimeout(() => {
              document.getElementById("stop").click();
            }, 500);
          }
        }
      });

      const checkconnectionnumber = parseInt(Math.random() * 100000);
      let wsport = window.location.port;
      if (wsport == "") {
        wsport = 5001;
      } else {
        wsport = +wsport + 1;
      }

      const connectToWebSocketServer = (port, callbackfn) => {
        let i = 0;
        for (i = 0; i < fge.WebSocketReconnectionTime; i++) {
          try {
            fge.WebSocketStatus = "CONNECTING";
            fge.ws = new WebSocket("ws://localhost:" + port.toString());

            fge.ws.addEventListener("open", function (event) {
              fge.ws.send(`CONNECT\x10${checkconnectionnumber}`);
            });

            fge.ws.addEventListener("message", function (event) {
              if (typeof event.data != "string") {
                console.error(
                  `%c WebSocket %c ERROR %c Received bad data type from server: ${typeof event.data}`,
                  "color: #fff; background: #5f5f5f",
                  "color: #fff; background: #f03a17",
                  "",
                );
                fge.ws.close();
                fge.WebSocketStatus = "ERROR";
                const binenginediv = document.getElementById("binengineinput");
                if (binenginediv) {
                  binenginediv.style.display = "none";
                }
                fge.first_engine = null;
                fge.second_engine = null;
                fge.analysis_engine = null;
                return;
              }
              let msg = event.data.split("|");
              if (fge.WebSocketStatus == "CONNECTING") {
                if (event.data == `${checkconnectionnumber}`) {
                  console.log(
                    `%c WebSocket %c CONNECTED %c WebSocket connection established.`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                  fge.WebSocketStatus = "CONNECTED";
                  fge.ws.send("READYOK");
                  const binenginediv =
                    document.getElementById("binengineinput");
                  if (binenginediv) {
                    binenginediv.hidden = false;
                    binenginediv.style.display = "";
                  }
                } else {
                  console.error(
                    `%c WebSocket %c ERROR %c WebSocket Server connection failed: Server returns bad verification code.`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #f03a17",
                    "",
                  );
                  fge.ws.close();
                  fge.WebSocketStatus = "ERROR";
                  const binenginediv =
                    document.getElementById("binengineinput");
                  if (binenginediv) {
                    binenginediv.style.display = "none";
                  }
                  fge.first_engine = null;
                  fge.second_engine = null;
                  fge.analysis_engine = null;
                }
              } else if (fge.WebSocketStatus == "CONNECTED") {
                if (msg[0] == "UPDATE_DATA") {
                  fge.GetEngineList((data) => {
                    engine_list = data;
                  }, fge.ws);
                  console.log(engine_list);
                }
              }
            });

            fge.ws.addEventListener("close", function (event) {
              let { code, reason, wasClen } = event;
              if (fge.WebSocketStatus == "ERROR") {
                return;
              }
              console.error(
                `%c WebSocket %c CLOSED %c WebSocket Connection Closed.`,
                "color: #fff; background: #5f5f5f",
                "color: #fff; background: #f03a17",
                "",
              );
              console.error(event);
              fge.WebSocketStatus = "CLOSED";
              const binenginediv = document.getElementById("binengineinput");
              if (binenginediv) {
                binenginediv.style.display = "none";
              }
              fge.first_engine = null;
              fge.second_engine = null;
              fge.analysis_engine = null;
              window.alert(
                "WebSocket connection has closed. You will be unable to use binary engines. Try reloading this page to fix this.",
              );
            });

            fge.ws.addEventListener("error", function (event) {
              fge.WebSocketStatus = "ERROR";
              console.error(
                `%c WebSocket %c ERROR %c Errors occurred during establishing WebSocket connection.`,
                "color: #fff; background: #5f5f5f",
                "color: #fff; background: #f03a17",
                "",
              );
              console.error(event);
              const binenginediv = document.getElementById("binengineinput");
              if (binenginediv) {
                binenginediv.style.display = "none";
              }
              fge.first_engine = null;
              fge.second_engine = null;
              fge.analysis_engine = null;
              window.alert(
                `Errors occurred in WebSocket connection ws://localhost:${port}`,
              );
            });

            break;
          } catch {
            console.warn(
              `%c WebSocket %c WARNING %c Cannot initiate WebSocket connection. Retrying... (${i + 1}/${fge.WebSocketReconnectionTime})`,
              "color: #fff; background: #5f5f5f",
              "color: #fff; background: #ffc83d",
              "",
            );
            continue;
          }
        }
        if (i == fge.WebSocketReconnectionTime) {
          console.error(
            `%c WebSocket %c ERROR %c Cannot initiate WebSocket connection. Binary engine loading feature will be disabled.`,
            "color: #fff; background: #5f5f5f",
            "color: #fff; background: #f03a17",
            "",
          );
          fge.WebSocketStatus = "ERROR";
          window.alert(
            `Cannot initiate WebSocket connection to ws://localhost:${port}. Binary engine loading feature will be disabled.`,
          );
          const binenginediv = document.getElementById("binengineinput");
          if (binenginediv) {
            binenginediv.style.display = "none";
          }
          fge.first_engine = null;
          fge.second_engine = null;
          fge.analysis_engine = null;
        }
      };

      if (window.location.hostname == "localhost") {
        connectToWebSocketServer(wsport);
      } else {
        console.log(
          `%c WebSocket %c PENDING %c Cannot automatically initiate WebSocket connection in online versions. Waiting user action...`,
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #3f48cc",
          "",
        );
        fge.ws = null;
        fge.WebSocketStatus = "Unestablished";
        const binenginediv = document.getElementById("binengineinput");
        if (binenginediv) {
          binenginediv.style.display = "none";
        }
        fge.first_engine = null;
        fge.second_engine = null;
        fge.analysis_engine = null;
      }

      const getVariants = () => {
        stockfish.postMessage(`uci`);
      };

      const setVariant = () => {
        play_move = false;
        stop(true);
        const variant = $("#dropdown-variant").value;
        stockfish.postMessage(`ucinewgame`);
        if (variant == "") {
          stockfish.postMessage(`setoption name UCI_Variant value chess`);
        } else {
          stockfish.postMessage(`setoption name UCI_Variant value ${variant}`);
        }
        stockfish.postMessage(
          `setoption name UCI_Chess960 value ${fischer_random_mode}`,
        );
        stockfish.postMessage(`position startpos`);
        if (fge.WebSocketStatus == "CONNECTED") {
          if (fge.first_engine) {
            if (fge.first_engine.SetVariant(variant, fischer_random_mode)) {
              document.getElementById("whiteunsupportedvariant").hidden = true;
            } else {
              document.getElementById("whiteunsupportedvariant").hidden = false;
            }
          }
          if (fge.second_engine) {
            if (fge.second_engine.SetVariant(variant, fischer_random_mode)) {
              document.getElementById("blackunsupportedvariant").hidden = true;
            } else {
              document.getElementById("blackunsupportedvariant").hidden = false;
            }
          }
          if (fge.analysis_engine) {
            if (fge.analysis_engine.SetVariant(variant, fischer_random_mode)) {
              document.getElementById("analysisunsupportedvariant").hidden =
                true;
            } else {
              document.getElementById("analysisunsupportedvariant").hidden =
                false;
            }
          }
        }
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();

        setVariantStylesheet(variant);
      };

      const setFen = (
        interrupt_ponder,
        automatically_start_engine_thinking,
      ) => {
        stop(interrupt_ponder);
        const fen = $("#fen").value.trim();
        const moves = $("#move").value.trim();
        const movelist = moves.split(" ");
        let i = 0;
        let count = 0;
        for (i = 0; i < movelist.length; i++) {
          if (movelist[i].length == 0) {
            continue;
          }
          count++;
        }
        $("#gotomovenum").value = count;

        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${moves}`);
        }
        const stm = $("#label-stm").innerText;
        if (fge.WebSocketStatus == "CONNECTED") {
          if (fge.analysis_engine) {
            fge.analysis_engine.SetPosition(
              fen,
              moves,
              fge.GetBoardWidth(),
              fge.GetBoardHeight(),
            );
          }
          if (
            interrupt_ponder ||
            !advanced_time_control ||
            (advanced_time_control && !during_play)
          ) {
            if (fge.first_engine) {
              fge.first_engine.SetPosition(
                fen,
                moves,
                fge.GetBoardWidth(),
                fge.GetBoardHeight(),
              );
            }
            if (fge.second_engine) {
              fge.second_engine.SetPosition(
                fen,
                moves,
                fge.GetBoardWidth(),
                fge.GetBoardHeight(),
              );
            }
          } else {
            if (stm == "white") {
              if (fge.first_engine) {
                if (fge.first_engine.Ponder && advanced_time_control) {
                  if (
                    fge.first_engine.PonderMove != "0000" &&
                    fge.first_engine.PonderMove !=
                      $("#move").value.trim().split(" ").at(-1)
                  ) {
                    fge.first_engine.SetPonderMiss();
                    fge.first_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                    console.log(
                      `%c Ponder %c MISS %c WHITE Ponder misses`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #f03a17",
                      "",
                    );
                  } else if (fge.first_engine.PonderMove == "0000") {
                    fge.first_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                  }
                } else {
                  fge.first_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
              if (fge.second_engine) {
                if (
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove != "0000" &&
                  advanced_time_control
                ) {
                  fge.second_engine.SetPosition(
                    fen,
                    moves + ` ${fge.second_engine.PonderMove}`,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                } else {
                  if (fge.second_engine.Ponder && fge.second_engine.IsUsing) {
                    console.log(
                      `%c Ponder %c WARNING %c BLACK makes no ponder move but Ponder=true`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #ffc83d",
                      "",
                    );
                  }
                  fge.second_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
            } else if (stm == "black") {
              if (fge.second_engine) {
                if (fge.second_engine.Ponder && advanced_time_control) {
                  if (
                    fge.second_engine.PonderMove != "0000" &&
                    fge.second_engine.PonderMove !=
                      $("#move").value.trim().split(" ").at(-1)
                  ) {
                    fge.second_engine.SetPonderMiss();
                    fge.second_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                    console.log(
                      `%c Ponder %c MISS %c BLACK Ponder misses`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #f03a17",
                      "",
                    );
                  } else if (fge.second_engine.PonderMove == "0000") {
                    fge.second_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                  }
                } else {
                  fge.second_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
              if (fge.first_engine) {
                if (
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove != "0000" &&
                  advanced_time_control
                ) {
                  fge.first_engine.SetPosition(
                    fen,
                    moves + ` ${fge.first_engine.PonderMove}`,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                } else {
                  if (fge.first_engine.Ponder && fge.first_engine.IsUsing) {
                    console.log(
                      `%c Ponder %c WARNING %c WHITE makes no ponder move but Ponder=true`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #ffc83d",
                      "",
                    );
                  }
                  fge.first_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
            }
          }
        }
        updateTimerOnMove();

        if (
          automatically_start_engine_thinking &&
          stm != "undefined" &&
          ((play_white && stm == "white") ||
            (play_black && stm == "black") ||
            analysis_mode)
        ) {
          setTimeout(go(false, false), 10);
        } else if (automatically_start_engine_thinking) {
          if (fge.first_engine) {
            if (
              fge.first_engine.IsUsing &&
              fge.first_engine.Ponder &&
              stm != "undefined" &&
              play_white
            ) {
              setTimeout(go(true, false), 10);
            }
          }
          if (fge.second_engine) {
            if (
              fge.second_engine.IsUsing &&
              fge.second_engine.Ponder &&
              stm != "undefined" &&
              play_black
            ) {
              setTimeout(go(false, true), 10);
            }
          }
          if (
            (random_mover_white && !play_white && stm == "white") ||
            (random_mover_black && !play_black && stm == "black")
          ) {
            setTimeout(() => {
              if (random_mover_white || random_mover_black)
                document.getElementById("randommovergo").click();
            }, 200);
          }
        }
      };

      const sendCommandToEngine = () => {
        let cmd = $("#enginecmd")
          .value.split(" ")
          .filter(function (item) {
            return item != null && item != undefined && item != "";
          });
        if (cmd[0] == "quit") {
          window.alert(
            "Cannot send this command: Quitting engine will cause the engine to not work.",
          );
          return;
        }
        if (cmd[0] == "position") {
          window.alert(
            "Cannot send this command: Setting position will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "flip") {
          window.alert(
            "Cannot send this command: Flipping the side will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "go") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "stop") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ucinewgame") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ponderhit") {
          window.alert(
            "Cannot send this command: Engine ponder hit is only allowed to be sent by the GUI.",
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          cmd[2] == "VariantPath"
        ) {
          window.alert(
            'Cannot send this command: To select variants.ini, select the ini file by clicking the "Select File" button of variants.ini at the top of the page.',
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          (cmd[2] == "UCI_Variant" ||
            cmd[2] == "USI_Variant" ||
            cmd[2] == "UCCI_Variant")
        ) {
          window.alert(
            "Cannot send this command: To change the variant, select the items in the variants dropdown.",
          );
          return;
        }
        if (cmd[0] == "setoption" && cmd[1] == "name" && cmd[2] == "Ponder") {
          window.alert(
            "Cannot send this command: Setting this value manually does not make sense.",
          );
          return;
        }
        if (cmd[0] == "usi") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucci") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "xboard") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucicyclone") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "uci") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        const targetengine = document.getElementById("targetengine");
        if (targetengine[targetengine.selectedIndex].value == "WHITE") {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.first_engine) {
              fge.first_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("1st engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (targetengine[targetengine.selectedIndex].value == "BLACK") {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.second_engine) {
              fge.second_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("2nd engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (
          targetengine[targetengine.selectedIndex].value == "ANALYSIS"
        ) {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.analysis_engine) {
              fge.analysis_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("Analysis engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (
          targetengine[targetengine.selectedIndex].value == "DEFAULT"
        ) {
          stockfish.postMessage($("#enginecmd").value.trim());
        }
      };

      const totalMoveNumber = () => {
        let listlength = 0;
        let i = 0;
        moves_split = $("#move").value.split(" ");
        for (i = 0; i < moves_split.length; i++) {
          if (moves_split[i].length == 0) {
            continue;
          }
          listlength++;
        }
        return listlength;
      };

      const displayMove = (movenum, is_force_stop, interrupt_pondering) => {
        if (
          $("#displayready").value.length > 0 &&
          $("#displayready").value > 0
        ) {
          //$("#displayready").value = 0, displayMove() is ready
          return;
        }
        $("#displayready").value = 2; //2 = displayMove() working
        let i = 0;
        let j = 0;
        moves_split = $("#move").value.split(" ");
        if (movenum == -1) {
          if (is_force_stop) {
            force_stop();
          } else {
            stop(interrupt_pondering);
          }
          $("#displaymoves").value = $("#move").value;
          review_mode = false;
          $("#isreviewmode").value = 0;
          document.getElementById("setpositiontomainboard").disabled = false;
        } else if (movenum > totalMoveNumber() || movenum < -1) {
          console.log(`${movenum} is out of range for move number.`);
          return;
        } else {
          if (is_force_stop) {
            force_stop();
          } else {
            stop(interrupt_pondering);
          }
          if ($("#showmovediv").checked) {
            $("#showmovediv").click();
          }
          review_mode = true;
          $("#isreviewmode").value = 1;
          document.getElementById("setpositiontomainboard").disabled = true;
          $("#displaymoves").value = "";
          for (i = 0, j = 0; j < movenum; i++, j++) {
            if (moves_split[i].length == 0) {
              j--;
              continue;
            }
            $("#displaymoves").value = $("#displaymoves").value.concat(
              moves_split[i],
            );
            if (j < movenum - 1) {
              $("#displaymoves").value = $("#displaymoves").value.concat(" ");
            }
          }
        }
        const fen = $("#fen").value.trim();
        const display_moves = $("#displaymoves").value.trim();
        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${display_moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${display_moves}`);
        }
        if (fge.first_engine) {
          fge.first_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        if (fge.second_engine) {
          fge.second_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        //console.log(`${display_moves}`);
        $("#displayready").value = 1; //1 = updateChessBoardToPosition() working
      };

      const displayNextMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value < 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value >= totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value++;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const displayPreviousMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value <= 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value > totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value--;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const displayInitialPosition = () => {
        $("#gotomovenum").value = 0;
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove(0, true, true);
      };

      const displayCurrentPosition = () => {
        $("#gotomovenum").value = totalMoveNumber();
        console.log(`Current: ${!during_play}`);
        displayMove(-1, false, false);
      };

      const displaySpecifiedPosition = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#gotomovenum").value < 0) {
          $("#gotomovenum").value = 0;
        } else if ($("#gotomovenum").value > totalMoveNumber()) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const reset = () => {
        review_mode = false;
        if (board_setup_mode) {
          board_setup_mode = false;
          triggerBoardSetupPieceIdentifier(false);
        }
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();
        stockfish.postMessage(`stop`);
        stockfish.postMessage(`ucinewgame`);
        if (fge.first_engine) {
          fge.first_engine.NewGame();
        }
        if (fge.second_engine) {
          fge.second_engine.NewGame();
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.NewGame();
        }
        play_move = false;
        setFen(true, false);
        $("#currentposition").click();
      };

      const undo = () => {
        if (review_mode || board_setup_mode) {
          return;
        }
        const moves = $("#move").value;
        $("#move").value = moves.substring(0, moves.lastIndexOf(" "));
        stockfish.postMessage(`stop`);
        stockfish.postMessage(`ucinewgame`);
        if (fge.first_engine) {
          fge.first_engine.NewGame();
        }
        if (fge.second_engine) {
          fge.second_engine.NewGame();
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.NewGame();
        }
        resetTimer();
        play_move = false;
        setFen(true, analysis_mode);
      };

      const go = (
        white_engine_ponder_and_human_black,
        black_engine_ponder_and_human_white,
      ) => {
        if (board_setup_mode) {
          return;
        }
        return_early = play_move;
        console.log(`return early: ${return_early}`);
        if (return_early) return; // avoid race condition
        let args = "";
        let wargs = "";
        let bargs = "";
        const movetime = $("#movetime").value;
        const depth = $("#depth").value;
        const nodes = $("#nodes").value;
        const threadnum = $("#threads").value;
        const hashsize = $("#hash").value;
        const multipleprincipalvariation = $("#multipv").value;
        const whiteengineoutput = document.getElementById("whiteengineoutput");
        const blackengineoutput = document.getElementById("blackengineoutput");
        const analysisengineoutput = document.getElementById(
          "analysisengineoutput",
        );
        let whitedepthv = parseInt($("#whitedepth").value);
        let whitemovetimev = parseInt($("#whitemovetime").value);
        let whitenodesv = parseInt($("#whitenodes").value);
        let blackdepthv = parseInt($("#blackdepth").value);
        let blackmovetimev = parseInt($("#blackmovetime").value);
        let blacknodesv = parseInt($("#blacknodes").value);
        let winf = false;
        let binf = false;
        let wtime = 0;
        let btime = 0;
        let winc = 0;
        let binc = 0;
        if (analysis_mode) {
          args += " infinite";
        } else if (advanced_time_control) {
          if (
            white_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "white"
          ) {
            args += "infinite";
            wargs += "infinite";
            winf = true;
            console.log("wtime infinite");
          } else if (
            black_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "black"
          ) {
            args += "infinite";
            bargs += "infinite";
            binf = true;
            console.log("btime infinite");
          }
          if (white_timer_type == "time per move") {
            wtime += +white_moving_time_list[0].remaining_time;
            winc += +white_moving_time_list[0].remaining_time;
          } else if (white_timer_type == "tournament") {
            wtime += +(+white_remaining_time);
            winc += +white_time_gain;
          } else if (white_timer_type == "hourglass") {
            //How to tell that it's hourglass to engine?
            wtime += +white_remaining_time;
          } else if (white_timer_type == "byoyomi") {
            wtime += +white_remaining_time;
            if (
              white_remaining_time < white_byoyomi_time_per_period &&
              white_remaining_byoyomi_periods > 0
            ) {
              winc += +white_byoyomi_time_per_period;
            }
            if (white_remaining_byoyomi_periods == white_byoyomi_period_count) {
              wtime += +white_byoyomi_time_per_period;
              winc = 0;
            }
          }
          if (black_timer_type == "time per move") {
            btime += +black_moving_time_list[0].remaining_time;
            binc += +black_moving_time_list[0].remaining_time;
          } else if (black_timer_type == "tournament") {
            btime += +(+black_remaining_time);
            binc = +black_time_gain;
          } else if (black_timer_type == "hourglass") {
            //How to tell that it's hourglass to engine?
            btime += +black_remaining_time;
          } else if (black_timer_type == "byoyomi") {
            btime += +black_remaining_time;
            if (
              black_remaining_time < black_byoyomi_time_per_period &&
              black_remaining_byoyomi_periods > 0
            ) {
              binc += +black_byoyomi_time_per_period;
            }
            if (black_remaining_byoyomi_periods == black_byoyomi_period_count) {
              btime += +black_byoyomi_time_per_period;
              binc = 0;
            }
          }
          console.log(
            `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`,
          );
          args += `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
          stockfish.postMessage(
            `setoption name Move Overhead value ${timer_interval}`,
          );
        } else {
          if (!analysis_mode && $("#depth").validity.valid && depth > 0) {
            args += ` depth ${depth}`;
          }
          if (!analysis_mode && $("#movetime").validity.valid && movetime > 0) {
            args += ` movetime ${movetime}`;
          }
          if (!analysis_mode && $("#nodes").validity.valid && nodes > 0) {
            args += ` nodes ${nodes}`;
          }
          if (!($("#whitedepth").validity.valid && whitedepthv > 0)) {
            whitedepth = -1;
          }
          if (!($("#whitemovetime").validity.valid && whitemovetimev > 0)) {
            whitemovetime = -1;
          }
          if (!($("#whitenodes").validity.valid && whitenodesv > 0)) {
            whitenodes = -1;
          }
          if (!($("#blackdepth").validity.valid && blackdepthv > 0)) {
            blackdepth = -1;
          }
          if (!($("#blackmovetime").validity.valid && blackmovetimev > 0)) {
            blackmovetime = -1;
          }
          if (!($("#blacknodes").validity.valid && blacknodesv > 0)) {
            blacknodes = -1;
          }
        }

        if (threadnum.length <= 0 || threadnum < 1) {
          stockfish.postMessage(`setoption name Threads value 1`);
        } else if (threadnum > 512) {
          stockfish.postMessage(`setoption name Threads value 512`);
        } else {
          stockfish.postMessage(`setoption name Threads value ${threadnum}`);
        }
        if (hashsize.length <= 0 || hashsize < 1) {
          if (in_browser_fsf_hash != 16) {
            stockfish.postMessage(`setoption name Hash value 16`);
            in_browser_fsf_hash = 16;
            console.log(`sethash: 16`);
          }
        } else if (hashsize > 33554432) {
          if (in_browser_fsf_hash != 33554432) {
            stockfish.postMessage(`setoption name Hash value 33554432`);
            in_browser_fsf_hash = 33554432;
            console.log(`sethash: 33554432`);
          }
        } else if (in_browser_fsf_hash != hashsize) {
          stockfish.postMessage(`setoption name Hash value ${hashsize}`);
          in_browser_fsf_hash = hashsize;
          console.log(`sethash: ${hashsize}`);
        }
        if (
          multipleprincipalvariation.length <= 0 ||
          multipleprincipalvariation < 1
        ) {
          stockfish.postMessage(`setoption name MultiPV value 1`);
        } else if (multipleprincipalvariation > 500) {
          stockfish.postMessage(`setoption name MultiPV value 500`);
        } else {
          stockfish.postMessage(
            `setoption name MultiPV value ${multipleprincipalvariation}`,
          );
        }
        stockfish.postMessage(`isready`);

        const stm = $("#label-stm").innerText;
        play_move =
          (play_white && stm == "white") ||
          (play_black && stm == "black") ||
          analysis_mode;
        if (fge.WebSocketStatus == "CONNECTED") {
          if (analysis_mode) {
            if (fge.analysis_engine) {
              if (fge.analysis_engine.IsUsing) {
                if (clear_log) {
                  analysisengineoutput.textContent = "";
                  analysis_engine_output = "";
                }
                fge.analysis_engine.IsAnalysisEngine = true;
                fge.analysis_engine.StartThinking(
                  stm,
                  true,
                  false,
                  false,
                  false,
                  false,
                  -1,
                  -1,
                  -1,
                  wtime,
                  winc,
                  btime,
                  binc,
                  white_byoyomi_time_per_period,
                );
              } else {
                stockfish.postMessage(`go ${args}`);
              }
            } else {
              stockfish.postMessage(`go ${args}`);
            }
          } else if (stm == "white") {
            if (fge.first_engine) {
              if (fge.first_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove ==
                    $("#move").value.trim().split(" ").at(-1)
                ) {
                  fge.first_engine.StartThinking(
                    stm,
                    false,
                    true,
                    false,
                    true,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  console.log(
                    `%c Ponder %c HIT %c WHITE Ponder Hits`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                } else {
                  if (clear_log) {
                    whiteengineoutput.textContent = "";
                    first_engine_output = "";
                  }
                  fge.first_engine.StartThinking(
                    stm,
                    winf,
                    advanced_time_control,
                    false,
                    false,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  //console.log("WHITE: go " + wargs);
                }
              } else if (!black_engine_ponder_and_human_white) {
                engineoutput = "";
                stockfish.postMessage(`go ${args}`);
              }
            } else if (!black_engine_ponder_and_human_white) {
              engineoutput = "";
              stockfish.postMessage(`go ${args}`);
            }
            if (fge.second_engine) {
              if (fge.second_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove != "0000"
                ) {
                  if (clear_log) {
                    blackengineoutput.textContent = "";
                    second_engine_output = "";
                  }
                  fge.second_engine.StartThinking(
                    stm,
                    false,
                    true,
                    true,
                    false,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    black_byoyomi_time_per_period,
                  );
                }
              }
            }
          } else if (stm == "black") {
            if (fge.second_engine) {
              if (fge.second_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove ==
                    $("#move").value.trim().split(" ").at(-1)
                ) {
                  fge.second_engine.StartThinking(
                    stm,
                    false,
                    true,
                    false,
                    true,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    black_byoyomi_time_per_period,
                  );
                  console.log(
                    `%c Ponder %c HIT %c BLACK Ponder Hits`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                } else {
                  if (clear_log) {
                    blackengineoutput.textContent = "";
                    second_engine_output = "";
                  }
                  fge.second_engine.StartThinking(
                    stm,
                    binf,
                    advanced_time_control,
                    false,
                    false,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  //console.log("BLACK: go " + bargs);
                }
              } else if (!white_engine_ponder_and_human_black) {
                engineoutput = "";
                stockfish.postMessage(`go ${args}`);
              }
            } else if (!white_engine_ponder_and_human_black) {
              engineoutput = "";
              stockfish.postMessage(`go ${args}`);
            }
            if (fge.first_engine) {
              if (fge.first_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove != "0000"
                ) {
                  if (clear_log) {
                    whiteengineoutput.textContent = "";
                    first_engine_output = "";
                  }
                  fge.first_engine.StartThinking(
                    stm,
                    false,
                    true,
                    true,
                    false,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                }
              }
            }
          }
        } else {
          engineoutput = "";
          stockfish.postMessage(`go ${args}`);
        }
      };

      const setupTimer = () => {
        $("#timeoutside").value = 0;
        white_timer_type = $("#dropdown-whitetimemode").value;
        black_timer_type = $("#dropdown-blacktimemode").value;
        white_remaining_time = parseInt($("#whitestarttime").value);
        black_remaining_time = parseInt($("#blackstarttime").value);
        if (
          isNaN(white_remaining_time) ||
          white_remaining_time.length < 1 ||
          white_remaining_time < 1
        ) {
          white_remaining_time = play_white ? 20000 : 600000;
        }
        if (
          isNaN(black_remaining_time) ||
          black_remaining_time.length < 1 ||
          black_remaining_time < 1
        ) {
          black_remaining_time = play_black ? 20000 : 600000;
        }
        white_time_gain = parseInt($("#whitetimegain").value);
        black_time_gain = parseInt($("#blacktimegain").value);
        if (
          isNaN(white_time_gain) ||
          white_time_gain.length < 1 ||
          white_time_gain < 0
        ) {
          white_time_gain = 0;
        }
        if (
          isNaN(black_time_gain) ||
          black_time_gain.length < 1 ||
          black_time_gain < 0
        ) {
          black_time_gain = 0;
        }
        white_byoyomi_time_per_period = parseInt($("#whitebyoyomitime").value);
        black_byoyomi_time_per_period = parseInt($("#blackbyoyomitime").value);
        if (
          isNaN(white_byoyomi_time_per_period) ||
          white_byoyomi_time_per_period.length < 1 ||
          white_byoyomi_time_per_period < 1
        ) {
          white_byoyomi_time_per_period = 30000;
        }
        if (
          isNaN(black_byoyomi_time_per_period) ||
          black_byoyomi_time_per_period.length < 1 ||
          black_byoyomi_time_per_period < 1
        ) {
          black_byoyomi_time_per_period = 30000;
        }
        white_byoyomi_period_count = parseInt(
          $("#whitebyoyomiperiodcount").value,
        );
        black_byoyomi_period_count = parseInt(
          $("#blackbyoyomiperiodcount").value,
        );
        if (
          isNaN(white_byoyomi_period_count) ||
          white_byoyomi_period_count.length < 1 ||
          white_byoyomi_period_count < 1
        ) {
          white_byoyomi_period_count = 1;
        }
        if (
          isNaN(black_byoyomi_period_count) ||
          black_byoyomi_period_count.length < 1 ||
          black_byoyomi_period_count < 1
        ) {
          black_byoyomi_period_count = 1;
        }
        white_remaining_byoyomi_periods = white_byoyomi_period_count;
        black_remaining_byoyomi_periods = black_byoyomi_period_count;
        white_time_margin = parseInt($("#whitetimemargin").value);
        black_time_margin = parseInt($("#blacktimemargin").value);
        if (
          isNaN(white_time_margin) ||
          white_time_margin.length < 1 ||
          white_time_margin < 0
        ) {
          white_time_margin = timeout_margin;
        }
        if (
          isNaN(black_time_margin) ||
          black_time_margin.length < 1 ||
          black_time_margin < 0
        ) {
          black_time_margin = timeout_margin;
        }
        white_moving_time_list = [];
        black_moving_time_list = [];
        const now = Date.now();
        white_moving_time_list.push({
          remaining_time: white_remaining_time,
          time_stamp: now,
        }); //Start time white
        black_moving_time_list.push({
          remaining_time: black_remaining_time,
          time_stamp: now,
        }); //Start time black
        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
        if (white_timer_type == "infinite") {
          $("#whitetime").innerHTML = "∞";
        }
        if (black_timer_type == "infinite") {
          $("#blacktime").innerHTML = "∞";
        }
        previous_mover = "";
      };

      const resetTimer = () => {
        $("#whitetime").innerHTML = "--";
        $("#blacktime").innerHTML = "--";
        previous_mover = "";
        $("#timeoutside").value = 0;
        white_time_exceeded = false;
        black_time_exceeded = false;
        document.getElementById("whitetimer").classList.remove("timer-active");
        document.getElementById("blacktimer").classList.remove("timer-active");
        document.getElementById("whitetime").classList.remove("time-exceeded");
        document.getElementById("blacktime").classList.remove("time-exceeded");
      };

      function updateTimerOnMove() {
        if (!during_play) {
          return;
        }
        move_finish_timer_updating = true;
        const stm = document.getElementById("label-stm").innerText;
        console.log(`${$("#gamestatus").innerText}`);
        //console.log(white_moving_time_list);
        //console.log(white_moving_time_list);
        const realtimenow = Date.now();
        if (stm == "white") {
          if (previous_mover == "") {
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            }
            white_moving_time_list.push({
              remaining_time: white_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for white's turn begin
          } else {
            black_moving_time_list.push({
              remaining_time:
                black_remaining_time < 0 ? 0 : black_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for black's turn end
            if (white_remaining_time < 0) {
              white_remaining_time = 0;
            }
            //white_remaining_time = (+white_moving_time_list.at(-1).remaining_time) + ((+white_moving_time_list.at(-1).time_stamp) - (+now));
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            } else if (white_timer_type == "time per move") {
              white_remaining_time =
                +white_moving_time_list[0].remaining_time + +timer_interval;
            } else if (white_timer_type == "byoyomi") {
              if (
                white_remaining_byoyomi_periods < white_byoyomi_period_count
              ) {
                white_remaining_time =
                  +white_byoyomi_time_per_period + +timer_interval;
              } else {
                white_remaining_time = +white_remaining_time + +timer_interval;
              }
            }
            if (black_timer_type == "hourglass") {
              white_remaining_time =
                +white_remaining_time +
                +black_moving_time_list.at(-2).remaining_time -
                +black_moving_time_list.at(-1).remaining_time;
            }
            white_moving_time_list.push({
              remaining_time: white_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for white's turn begin
          }
          previous_mover = "WHITE";
          document.getElementById("whitetimer").classList.add("timer-active");
          document
            .getElementById("blacktimer")
            .classList.remove("timer-active");
        } else if (stm == "black") {
          if (previous_mover == "") {
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            }
            black_moving_time_list.push({
              remaining_time: black_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for black's turn begin
          } else {
            white_moving_time_list.push({
              remaining_time:
                white_remaining_time < 0 ? 0 : white_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for white's turn end
            if (black_remaining_time < 0) {
              black_remaining_time = 0;
            }
            //black_remaining_time = (+black_moving_time_list.at(-1).remaining_time) + ((+black_moving_time_list.at(-1).time_stamp) - (+now));
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            } else if (black_timer_type == "time per move") {
              black_remaining_time =
                +black_moving_time_list[0].remaining_time + +timer_interval;
            } else if (black_timer_type == "byoyomi") {
              if (
                black_remaining_byoyomi_periods < black_byoyomi_period_count
              ) {
                black_remaining_time =
                  +black_byoyomi_time_per_period + +timer_interval;
              } else {
                black_remaining_time = +black_remaining_time + +timer_interval;
              }
            }
            if (white_timer_type == "hourglass") {
              black_remaining_time =
                +black_remaining_time +
                +white_moving_time_list.at(-2).remaining_time -
                +white_moving_time_list.at(-1).remaining_time;
            }
            black_moving_time_list.push({
              remaining_time: black_remaining_time,
              time_stamp: realtimenow,
            }); //Time stamp for black's turn begin
          }
          previous_mover = "BLACK";
          document
            .getElementById("whitetimer")
            .classList.remove("timer-active");
          document.getElementById("blacktimer").classList.add("timer-active");
        } else {
          document
            .getElementById("whitetimer")
            .classList.remove("timer-active");
          document
            .getElementById("blacktimer")
            .classList.remove("timer-active");
        }
        if (white_time_exceeded) {
          document
            .getElementById("whitetime")
            .classList.remove("time-exceeded");
        }
        if (black_time_exceeded) {
          document
            .getElementById("blacktime")
            .classList.remove("time-exceeded");
        }
        white_time_exceeded = false;
        black_time_exceeded = false;
        move_finish_timer_updating = false;
      }

      function updateTimer() {
        const gamestatus = document.getElementById("gamestatus");
        if (gamestatus.innerText == "END") {
          deleteTimer();
          gameEnd();
          return;
        }
        if (move_finish_timer_updating) {
          //avoid race condition
          return;
        }
        let deltatimereality = 0;
        let realitytimenow = Date.now();
        if (previous_reality_time >= 0) {
          deltatimereality = realitytimenow - previous_reality_time;
        }
        previous_reality_time = realitytimenow;
        gamestatus.click();
        const whitetimelabel = document.getElementById("whitetime");
        const blacktimelabel = document.getElementById("blacktime");
        if (gamestatus.innerText == "PLAYING_WHITE") {
          if (white_timer_type == "infinite") {
            previous_mover = "WHITE";
            return;
          }
          white_remaining_time = white_remaining_time - deltatimereality;
          if (white_timer_type == "byoyomi" && white_remaining_time <= 0) {
            if (white_remaining_byoyomi_periods == 0) {
            } else {
              white_remaining_byoyomi_periods--;
              white_remaining_time = +white_byoyomi_time_per_period;
              console.log(
                "WHITE byoyomi remaining periods: " +
                  white_remaining_byoyomi_periods,
              );
            }
          }
          if (white_remaining_time < -white_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 1;
            timeIsUpFor("WHITE");
            whitetimelabel.classList.remove("time-exceeded");
            return;
          }
          if (white_timer_type == "infinite") {
            whitetimelabel.innerText = "∞";
          } else if (white_remaining_time >= 10000) {
            whitetimelabel.innerText = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            whitetimelabel.innerText = `${(
              parseInt(white_remaining_time / 100) / 10
            ).toFixed(1)}`;
            if (white_remaining_time <= 0 && !white_time_exceeded) {
              white_time_exceeded = true;
              whitetimelabel.classList.add("time-exceeded");
            }
          }
          if (black_timer_type == "infinite") {
            blacktimelabel.innerText = "∞";
          } else if (black_remaining_time >= 10000) {
            blacktimelabel.innerText = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            blacktimelabel.innerText = `${(
              parseInt(black_remaining_time / 100) / 10
            ).toFixed(1)}`;
            if (black_remaining_time <= 0 && !black_time_exceeded) {
              black_time_exceeded = true;
              blacktimelabel.classList.add("time-exceeded");
            }
          }
          if (white_timer_type == "byoyomi") {
            whitetimelabel.innerText += ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            blacktimelabel.innerText += ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "WHITE";
        } else if (gamestatus.innerText == "PLAYING_BLACK") {
          if (black_timer_type == "infinite") {
            previous_mover = "BLACK";
            return;
          }
          black_remaining_time = black_remaining_time - deltatimereality;
          if (black_timer_type == "byoyomi" && black_remaining_time <= 0) {
            if (black_remaining_byoyomi_periods == 0) {
            } else {
              black_remaining_byoyomi_periods--;
              black_remaining_time = +black_byoyomi_time_per_period;
              console.log(
                "BLACK byoyomi remaining periods: " +
                  black_remaining_byoyomi_periods,
              );
            }
          }
          if (black_remaining_time < -black_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 2;
            timeIsUpFor("BLACK");
            blacktimelabel.classList.remove("time-exceeded");
            return;
          }
          if (white_timer_type == "infinite") {
            whitetimelabel.innerText = "∞";
          } else if (white_remaining_time >= 10000) {
            whitetimelabel.innerText = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            whitetimelabel.innerText = `${(
              parseInt(white_remaining_time / 100) / 10
            ).toFixed(1)}`;
            if (white_remaining_time <= 0 && !white_time_exceeded) {
              white_time_exceeded = true;
              whitetimelabel.classList.add("time-exceeded");
            }
          }
          if (black_timer_type == "infinite") {
            blacktimelabel.innerText = "∞";
          } else if (black_remaining_time >= 10000) {
            blacktimelabel.innerText = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            blacktimelabel.innerText = `${(
              parseInt(black_remaining_time / 100) / 10
            ).toFixed(1)}`;
            if (black_remaining_time <= 0 && !black_time_exceeded) {
              black_time_exceeded = true;
              blacktimelabel.classList.add("time-exceeded");
            }
          }
          if (white_timer_type == "byoyomi") {
            whitetimelabel.innerText += ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            blacktimelabel.innerText += ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "BLACK";
        }
      }

      const createTimer = () => {
        timer = setInterval(() => {
          updateTimer();
        }, timer_interval);
        console.log(`${timer}`);
      };

      const deleteTimer = () => {
        console.log("Timer delete!");
        clearInterval(timer);
      };

      const timeIsUpFor = (side) => {
        force_stop();
        if (side == "WHITE") {
          white_remaining_time = 0;
          $("#timeoutside").value = 1;
          $("#whitetime").innerHTML = "Out Of Time";
          document.dispatchEvent(
            new CustomEvent("gameend", { detail: { result: "0-1" } }),
          );
        } else if (side == "BLACK") {
          black_remaining_time = 0;
          $("#timeoutside").value = 2;
          $("#blacktime").innerHTML = "Out Of Time";
          document.dispatchEvent(
            new CustomEvent("gameend", { detail: { result: "1-0" } }),
          );
        }
        $("#gamestatus").click();
        gameEnd();
      };

      const gameEnd = () => {
        during_play = false;
        //advanced_time_control = false;
        force_stop();
        $("#currentposition").click();
        $("#input").style.display = "";
        $("#input2").style.display = "";
        $("#input3").style.display = "";
        $("#posvariantdiv").style.display = "";
      };

      const gameAbort = () => {
        deleteTimer();
        $("#gamestatus").innerText = "END";
        gameEnd();
      };

      const goWithTimeControl = () => {
        if ($("#gamestatus").innerText != "END") {
          return;
        }
        //We need to prevent user from doing unnecessary actions during countdown, so we'll hide these divs
        $("#input").style.display = "none"; //These divs are unable to be hidden by {hidden: during_play}
        $("#input2").style.display = "none";
        $("#input3").style.display = "none";
        $("#posvariantdiv").style.display = "none";
        //$("#movecontrol").style.display = "none";
        resetTimer();
        setupTimer();
        $("#gamestatus").click();
        during_play = true;
        $("#currentposition").click();
        if (fge.first_engine) {
          fge.first_engine.PonderMove = "0000";
          fge.first_engine.PonderMiss = false;
        }
        if (fge.second_engine) {
          fge.second_engine.PonderMove = "0000";
          fge.second_engine.PonderMiss = false;
        }
        updateTimerOnMove();
        createTimer();
        const stm = $("#label-stm").innerText;
        console.log(
          `white: ${play_white} black: ${play_black} move: ${
            (play_white && stm == "white") || (play_black && stm == "black")
          }`,
        );
        console.log("Go!");
        previous_reality_time = -1;
        setFen(false, true);
      };

      const stop = (interrupt_pondering) => {
        stockfish.postMessage(`stop`);
        if (fge.first_engine) {
          fge.first_engine.StopThinking(
            interrupt_pondering,
            advanced_time_control,
          );
        }
        if (fge.second_engine) {
          fge.second_engine.StopThinking(
            interrupt_pondering,
            advanced_time_control,
          );
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.StopThinking(true, false);
        }
      };

      const force_stop = () => {
        play_white =
          play_black =
          random_mover_white =
          random_mover_black =
            false;
        play_move = false;
        stop(true);
      };

      const changePieces = (onlyChangeWhenInvalid) => {
        let index = 0;
        let themename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        const chessgroundmini = document.getElementById(
          "chessground-mini-container-div",
        );
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          themename = "default";
        } else {
          classes = themes[1][index];
          if (classes.length < 1) {
            classes = themes[1][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[1]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change piece.");
              updateThemeDropdowns(DOMListValue[1], null);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          themename = classes[index];
        } else {
          themename = "default";
        }
        DOMListValue[1] = themename;
        chessgroundmini.classList.value = el.classList.value =
          DOMListValue.join(" ");
        console.log(`Piece theme: ${themename}`);
        updateThemeDropdowns(themename, null);
        if (board_setup_mode) {
          triggerBoardSetupPieceIdentifier(false);
        }
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const changeBoard = (onlyChangeWhenInvalid) => {
        let index = 0;
        let boardthemename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        const chessgroundmini = document.getElementById(
          "chessground-mini-container-div",
        );
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          boardthemename = "defaultboard";
        } else {
          classes = themes[2][index];
          if (classes.length < 1) {
            classes = themes[2][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[0]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change board.");
              updateThemeDropdowns(null, DOMListValue[0]);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          boardthemename = classes[index];
        } else {
          boardthemename = "defaultboard";
        }
        DOMListValue[0] = boardthemename;
        chessgroundmini.classList.value = el.classList.value =
          DOMListValue.join(" ");
        console.log(`Board theme: ${boardthemename}`);
        updateThemeDropdowns(null, boardthemename);
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const setupThemeDropdowns = () => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        while (piecethemedropdown.options.length > 0) {
          piecethemedropdown.remove(0);
        }
        while (boardthemedropdown.options.length > 0) {
          boardthemedropdown.remove(0);
        }
        let index = 0;
        let piececlasses = [];
        let boardclasses = [];
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          null;
        } else {
          piececlasses = themes[1][index];
          if (piececlasses.length < 1) {
            piececlasses = themes[1][themes[0].indexOf("")];
          }
          boardclasses = themes[2][index];
          if (boardclasses.length < 1) {
            boardclasses = themes[2][themes[0].indexOf("")];
          }
        }
        if (piececlasses.length > 0) {
          piececlasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            piecethemedropdown.add(newOption);
            //console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Pieces";
          newOption.value = "default";
          piecethemedropdown.add(newOption);
          newOption = document.createElement("option");
          newOption.text = getThemeName("userdefined");
          newOption.value = "userdefined";
          piecethemedropdown.add(newOption);
        }
        if (boardclasses.length > 0) {
          boardclasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            boardthemedropdown.add(newOption);
            //console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Board";
          newOption.value = "defaultboard";
          boardthemedropdown.add(newOption);
        }
      };

      const updateThemeDropdowns = (piecethemeid, boardthemeid) => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        let i = 0;
        if (piecethemeid) {
          for (i = 0; i < piecethemedropdown.options.length; i++) {
            if (piecethemedropdown[i].value == piecethemeid) {
              piecethemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == piecethemedropdown.options.length) {
            piecethemedropdown.selectedIndex = -1;
          }
        }
        if (boardthemeid) {
          for (i = 0; i < boardthemedropdown.options.length; i++) {
            if (boardthemedropdown[i].value == boardthemeid) {
              boardthemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == boardthemedropdown.options.length) {
            boardthemedropdown.selectedIndex = -1;
          }
        }
      };

      const updateVariantDropdownTitles = () => {
        const variantdropdown = $("#dropdown-variant");
        let i = 0;
        let index = 0;
        for (i = 0; i < variantdropdown.children.length; i++) {
          index = variantsettings[0].indexOf(variantdropdown.children[i].value);
          if (index < 0) {
            continue;
          }
          variantdropdown.children[i].title = variantsettings[2][index];
        }
      };

      const updateVariantDropdown = () => {
        const varianttypedropdown = $("#dropdown-varianttype");
        const variantdropdown = $("#dropdown-variant");
        const selectedtype =
          varianttypedropdown[varianttypedropdown.selectedIndex].value;
        if (selectedtype == "") {
          variants = [""].concat(allvariants);
        } else if (selectedtype == "<|NC|>") {
          let tmpvariants = [""];
          allvariants.forEach((val) => {
            if (!variantsettings[0].includes(val)) {
              tmpvariants.push(val);
            }
          });
          variants = tmpvariants;
        } else {
          let tmpvariants = [];
          allvariants.forEach((val) => {
            if (getVariantType(val) == selectedtype) {
              tmpvariants.push(val);
            }
          });
          variants = tmpvariants;
        }
        while (variantdropdown.children.length > 0) {
          variantdropdown.removeChild(variantdropdown[0]);
        }
        variants.forEach((val) => {
          let option = document.createElement("option");
          let name = "(default)";
          let title = getVariantDescription(val, true);
          if (val != "") {
            name = getVariantName(val, true, true);
          }
          option.value = val;
          option.text = name;
          if (title != "") {
            option.title = title;
          }
          variantdropdown.appendChild(option);
        });
        variantdropdown.selectedIndex = 0;
        //updateVariantDropdownTitles();
      };

      const updateVariantTypeDropdown = () => {
        const varianttypedropdown = $("#dropdown-varianttype");
        while (varianttypedropdown.children.length > 2) {
          varianttypedropdown.removeChild(varianttypedropdown[2]);
        }
        let varianttypevariantcount = [[], []];
        variantsettings[1].forEach((val) => {
          if (varianttypevariantcount[0].includes(val)) {
            return;
          }
          varianttypevariantcount[0].push(val);
          varianttypevariantcount[1].push(0);
        });
        console.log(allvariants);
        variantsettings[0].forEach((val, ind) => {
          if (allvariants.includes(val)) {
            let index = varianttypevariantcount[0].indexOf(
              variantsettings[1][ind],
            );
            if (index >= 0) {
              varianttypevariantcount[1][index]++;
            }
          }
        });
        console.log(varianttypevariantcount);
        varianttypevariantcount[0].forEach((val, ind) => {
          if (varianttypevariantcount[1][ind] > 0) {
            if (!varianttypes.includes(val)) {
              varianttypes.push(val);
            }
          }
        });
        varianttypes.sort();
        varianttypes.forEach((val) => {
          let option = document.createElement("option");
          option.text = val;
          option.value = val;
          varianttypedropdown.appendChild(option);
        });
        varianttypedropdown.selectedIndex = 0;
        changing_variant_type = true;
        $("#dropdown-variant").dispatchEvent(new Event("change"));
      };

      const updateUIThemeDropdown = (ui_id) => {
        const uithemedropdown = document.getElementById("dropdown-uitheme");
        uithemedropdown.selectedIndex = uithemes[0].indexOf(ui_id);
      };

      const setupUIThemeDropdown = () => {
        const uithemedropdown = document.getElementById("dropdown-uitheme");
        let i = 0;
        if (uithemes[0].length > 0) {
          while (uithemedropdown[0]) {
            uithemedropdown.removeChild(uithemedropdown[0]);
          }
          for (i = 0; i < uithemes[0].length; i++) {
            let option = document.createElement("option");
            option.value = uithemes[0][i];
            option.text = uithemes[1][i].Name;
            uithemedropdown.appendChild(option);
          }
        }
      };

      const scrollOutput = () => {
        //Modern browsers will automatically create a variable for an element that has ID, with its name the same as the ID
        output2.scrollTo({
          top: output2.scrollHeight,
          behavior: "smooth",
        });
      };

      const displayGameResult = () => {
        if (review_mode || board_setup_mode) {
          return;
        }
        let elem = document.getElementById("gameresultcontainermain");
        while (elem) {
          document.body.removeChild(elem);
          elem = document.getElementById("gameresultcontainermain");
        }
        let div = document.createElement("div");
        div.id = "gameresultcontainermain";
        div.classList.add("inaccessble");
        div.style.position = "fixed";
        div.style.display = "flex";
        div.style.overflow = "hidden";
        div.style.top = "0";
        div.style.bottom = "0";
        div.style.left = "0";
        div.style.right = "0";
        div.style.justifyContent = "center";
        div.style.alignItems = "center";
        div.style.zIndex = "1000";
        div.style.background = "rgba(0,0,0,0)";
        div.style.pointerEvents = "none";
        let span = document.createElement("spangameresult");
        span.innerText = $("#gameresult").value;
        div.appendChild(span);
        setTimeout(() => {
          span.style.opacity = "1";
          span.style.fontSize = "400px";
        }, 100);
        setTimeout(() => {
          span.style.opacity = "0";
          span.style.fontSize = "1px";
        }, 2600);
        document.body.appendChild(div);
      };

      const onMouseMoveBoardSetupIdentifier = (event) => {
        let identifier = document.getElementById("boardsetuppieceidentifier");
        identifier.style.left = `${event.clientX + 60}px`;
        identifier.style.top = `${event.clientY + 60}px`;
      };

      const triggerBoardSetupPieceIdentifier = (moveidentifier) => {
        let identifier = document.getElementById("boardsetuppieceidentifier");
        let fakeboard = document.getElementById("fakeboard");
        let fakewrap = document.getElementById("fakewrap");
        let fakeboardclasses = fakeboard.classList.value.split(" ");
        let chessgrounddiv = document.getElementById("chessground-board");
        let chessgroundcontainer = document.getElementById(
          "chessground-container-div",
        );
        fakeboardclasses[1] = chessgroundcontainer.classList[1];
        if (chessgrounddiv.classList.contains("orientation-white")) {
          fakewrap.classList.remove("orientation-black");
          fakewrap.classList.add("orientation-white");
        } else if (chessgrounddiv.classList.contains("orientation-black")) {
          fakewrap.classList.remove("orientation-white");
          fakewrap.classList.add("orientation-black");
        }
        fakeboard.classList.value = fakeboardclasses.join(" ");
        if (board_setup_mode) {
          if (moveidentifier) {
            let isboardsetuprect = document
              .getElementById("isboardsetup")
              .getBoundingClientRect();
            identifier.style.top = `${isboardsetuprect.top + 60}px`;
            identifier.style.left = `${isboardsetuprect.left + 60}px`;
          }
          document
            .getElementById("dropdown-setpiece")
            .dispatchEvent(new Event("change"));
          identifier.style.display = "block";
          document.addEventListener(
            "mousemove",
            onMouseMoveBoardSetupIdentifier,
          );
        } else {
          identifier.style.display = "";
          document.removeEventListener(
            "mousemove",
            onMouseMoveBoardSetupIdentifier,
          );
        }
      };

      // Make error catchable
      const loadStockfish = async (params) => {
        return await Stockfish(params);
      };

      const onFinishDownload = (data) => {
        if (!data) {
          stockfish_state = "FAILED";
          m.redraw();
          return;
        }

        loadStockfish({ wasmBinary: data })
          .then(
            (_stockfish) => {
              stockfish = _stockfish;
              window.stockfish = _stockfish;
              stockfish_state = "READY";
              stockfish.addMessageListener((line) => {
                if (line.startsWith("option")) {
                  if (line.startsWith("option name UCI_Variant")) {
                    allvariants = line
                      .replace(
                        "option name UCI_Variant type combo default chess var ",
                        "",
                      )
                      .replace(/ var /g, " ")
                      .split(" ")
                      .sort();
                    console.log(
                      "Detected UCI_Variant parameter from Fairy-Stockfish. Updating variants and dropdowns...",
                    );
                    if (variantsystemready) {
                      updateVariantTypeDropdown();
                    } else {
                      console.log(
                        "Note: Fairy-Stockfish loaded before variant subsystem.",
                      );
                    }
                  }
                } else if (line.startsWith(" ")) {
                } else {
                  if (
                    !review_mode &&
                    line.startsWith("bestmove") &&
                    play_move
                  ) {
                    play_move = false;
                    if (analysis_mode) {
                      return;
                    }
                    $("#move").value += " " + line.split(" ")[1];
                    $("#set").click();
                  }
                  engineoutput += line + "\n";
                  if (fge.analysis_engine) {
                    if (!fge.analysis_engine.IsUsing) {
                      $("#engineoutputline").value = line;
                      $("#engineoutputline").click();
                    }
                  } else {
                    $("#engineoutputline").value = line;
                    $("#engineoutputline").click();
                  }
                }
                m.redraw();
              });
              getVariants();
            },
            (err) => {
              console.error(err);
              throw err;
            },
          )
          .catch((e) => {
            stockfish_state = "FAILED";
            window.alert(
              "There is something wrong with in browser Fairy-Stockfish. Press Ctrl+Shift+I to see more details.",
            );
            throw e;
          })
          .finally(() => m.redraw());
      };

      const onSelectNnueFile = async (e) => {
        const selected = e.currentTarget.files[0];
        if (selected) {
          //
          // TODO:
          // On Archlinux Chromium 92.0.4515.107, most of times this code fails with the error saying:
          //   TypeError: Failed to execute 'decode' on 'TextDecoder': The provided ArrayBufferView value must not be shared.
          // On the other hand, either Chrome with the same version or Firefox never fail.
          //
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`setoption name EvalFile value ${filename}`);
          // Automatically set variant
          const variant = selected.name.split(/[_.-]+/)[0];
          $("#dropdown-variant").value = variant;
          $("#dropdown-variant").dispatchEvent(new Event("change"));
        }
      };

      const onSelectVariantsFile = async (e) => {
        const selected = e.currentTarget.files[0];
        //console.log(`${selected}`);
        if (selected) {
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`check ${filename}`);
          stockfish.postMessage(`load ${filename}`);
          getVariants();
        }
      };

      function isLetter(str) {
        return str.length === 1 && str.match(/[a-z]/i);
      }

      function changePieceSet(piece_set) {
        const el = $("#chessground-container-div");
        const chessgroundmini = document.getElementById(
          "chessground-mini-container-div",
        );
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[1] = piece_set;
        chessgroundmini.classList.value = el.classList.value =
          DOMListValue.join(" ");
        updateThemeDropdowns(piece_set, null);
        if (board_setup_mode) {
          triggerBoardSetupPieceIdentifier(false);
        }
      }

      function changeBoardSet(board_set) {
        const el = $("#chessground-container-div");
        const chessgroundmini = document.getElementById(
          "chessground-mini-container-div",
        );
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[0] = board_set;
        chessgroundmini.classList.value = el.classList.value =
          DOMListValue.join(" ");
        updateThemeDropdowns(null, board_set);
      }

      function changeUI(ui_id, save_to_local_storage, change_canvas) {
        if (uithemes[0].indexOf(ui_id) < 0) {
          return;
        }
        let index = uithemes[0].indexOf(ui_id);
        if (currentthemeobj) {
          currentthemeobj.CancelTimer();
          if (change_canvas) {
            currentthemeobj.CloseCanvas();
          }
        }
        currentthemeobj = uithemes[1][index];
        ApplyUIThemeStyleNode(uithemes[1][index].CurrentTheme());
        uithemes[1][index].NextTheme(() => {
          changeUI(ui_id, false, false);
        }, true);
        if (change_canvas) {
          uithemes[1][index].StartCanvasAnimation();
        }
        updateUIThemeDropdown(ui_id);
        if (save_to_local_storage) {
          localStorage.setItem("UserSelectedUITheme", ui_id);
        }
      }

      const onSelectUserGraphics = async (e) => {
        var files_count = e.currentTarget.files.length;
        var files = [];

        if (!e.currentTarget.files.length) {
        } else {
          style = document.createElement("style");

          // See what files are being loaded.
          for (let i = 0; i < files_count; i++) {
            const selected = e.currentTarget.files[i];
            var filename = e.currentTarget.files[i].name.toLowerCase();

            files[files.length] = e.currentTarget.files[i];
          }

          console.log("File count: " + files.length);

          for (let i = 0; i < files.length; i++) {
            const selected = files[i];
            var bloburl = URL.createObjectURL(selected);
            var filename = files[i].name.split(".")[0].toLowerCase();
            var piececolor = filename.substr(0, 1);
            var pieceletter = filename.substr(1, 2).replace("+", "p");
            // Skip the file if it does not match the naming convention.
            if (piececolor == "b") {
              piececolor = "black";
            } else if (piececolor == "w") {
              piececolor = "white";
            } else {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length != 2 && filename.length != 3) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 2 && !isLetter(filename.substr(1, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && filename.substr(1, 1) != "+") {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && !isLetter(filename.substr(2, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            //console.log(filename);
            //console.log(piececolor);
            //console.log(pieceletter);
            console.log(`${bloburl}`);
            //console.log(`${selected}`);
            if (selected) {
              style.textContent =
                style.textContent +
                `.userdefined .cg-wrap piece.${pieceletter}-piece.${piececolor} { background-image: url('${bloburl}');} `;
            }
          }

          //console.log(`${style.textContent}`);
          document.head.appendChild(style);

          changePieceSet("userdefined");
        }
      };

      const onSelectVariantSettings = async (e) => {
        const selected = e.currentTarget.files[0];
        if (selected) {
          let reader = new FileReader();
          reader.readAsText(selected);
          reader.onload = function () {
            console.log(reader.result);
            LoadVariantSettings("client", reader.result);
            updateVariantTypeDropdown();
          };
        }
      };

      const oninit = () => {
        stockfish_state = "LOADING";
      };

      const view = () => {
        const is_ready = stockfish_state == "READY";

        return m("main", [
          m("div#pageheader", [
            m("p#pagetitle", "Advanced analysis"),
            m("div#misc", { hidden: during_play }, [
              m("div", [
                `Fairy-Stockfish: ${stockfish_state} - download: `,
                m(RequestProgress, {
                  url: "./lib/stockfish.wasm",
                  onFinishDownload,
                }),
              ]),
              m("div", { hidden: during_play }, [
                "- nnue file: ",
                m("input", {
                  type: "file",
                  disabled: !is_ready,
                  onchange: onSelectNnueFile,
                }),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "You can upload a Fairy-Stockfish compatible .nnue file. Downloads: https://fairy-stockfish.github.io/nnue/#current-best-nnue-networks.",
                      ),
                  },
                  "[?]",
                ),
              ]),
              m("div", { hidden: during_play }, [
                "- variants.ini: ",
                m("input#variants-ini", {
                  type: "file",
                  disabled: !is_ready || review_mode || board_setup_mode,
                  onchange: onSelectVariantsFile,
                }),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "You can upload a Fairy-Stockfish compatible variants.ini file. See here for details: https://github.com/ianfab/Fairy-Stockfish/wiki/Variant-configuration.",
                      ),
                  },
                  "[?]",
                ),
              ]),
              m("div", { hidden: during_play }, [
                "- positionvariants.txt: ",
                m("input#posvariant-txt", {
                  type: "file",
                  disabled: !is_ready || review_mode || board_setup_mode,
                }),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "You can select a Position Variant file to load different positions for different variants. Contents will be appended to the position variants provided by the server.",
                      ),
                  },
                  "[?]",
                ),
              ]),
              m("div", { hidden: during_play }, [
                "- User Piece Graphics: ",
                m("input#user-graphics", {
                  type: "file",
                  multiple: true,
                  disabled: !is_ready || review_mode || board_setup_mode,
                  onchange: onSelectUserGraphics,
                }),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "You can upload user defined piece graphics. They must be named as follows [piece colour][+][piece letter].svg.",
                      ),
                  },
                  "[?]",
                ),
              ]),
              m("div", { hidden: during_play }, [
                "- variantsettings.txt: ",
                m("input#variantsettings-txt", {
                  type: "file",
                  disabled: !is_ready || review_mode || board_setup_mode,
                  onchange: onSelectVariantSettings,
                }),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "You can upload a Variant Settings file to load settings for the variants including classification, names and descriptions. Contents will be appended to the variant descriptions provided by the server.",
                      ),
                  },
                  "[?]",
                ),
              ]),
              m("div#divconnectserver", { hidden: during_play }, [
                "- External binary engine feature: ",
                m(
                  "button.ripple",
                  {
                    disabled: !is_ready,
                    onclick: () => {
                      if (!is_ready) {
                        return;
                      }
                      if (fge.WebSocketStatus == "CONNECTED") {
                        window.alert("You are already connected.");
                        return;
                      } else if (fge.WebSocketStatus == "CONNECTING") {
                        window.alert(
                          "Connection is during establishment process.",
                        );
                        return;
                      }
                      let port = window.prompt(
                        "Please enter the WebSocket port of local fairyground server:",
                        "5016",
                      );
                      if (port) {
                        connectToWebSocketServer(port);
                      }
                    },
                  },
                  "CONNECT",
                ),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        "If you are using online version of fairyground, external binary engine loading feature will not be enabled automatically. You need to provide the port of local (i.e. offline version) fairyground server in order to make it work.",
                      ),
                  },
                  "[?]",
                ),
              ]),
            ]),
          ]),
          m("div#posvariantdiv", [
            m("p", "Variant Type:"),
            m(
              "select#dropdown-varianttype",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "The available types or categories of variants are shown in this list. Select one to see available variants in next dropdown.",
                onchange: (e) => {
                  changing_variant_type = true;
                  $("#dropdown-variant").dispatchEvent(new Event("change"));
                },
              },
              [
                m("option", { value: "" }, "(all)"),
                m("option", { value: "<|NC|>" }, "(not classified)"),
              ],
            ),
            m("p", "Name:"),
            m(
              "select#dropdown-variant",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "The available variants of the selected type are shown in this list. Select one to start a game of that variant.",
                onchange: (e) => {
                  if (changing_variant_type) {
                    updateVariantDropdown();
                    changing_variant_type = false;
                  }
                  window.setTimeout(setVariant, 10);
                },
              },
              [
                m("option", { value: "" }, "(default)"),
                //...variants.map((ex, index) => m("option", { value: ex, title: getVariantDescription(ex, true) }, getVariantName(ex,true,true))),
              ],
            ),
            m("p", "Custom Position Type:"),
            m(
              "select#dropdown-posvarianttype",
              {
                disabled: !is_ready || review_mode,
                title:
                  "The available types or categories of custom positions of this variant are shown in this list. Select one to see available positions in next dropdown.",
              },
              [m("option", { value: "(default)" }, "(default)")],
            ),
            m("p", "Name:"),
            m(
              "select#dropdown-posvariantname",
              {
                disabled: !is_ready || review_mode,
                title:
                  "The available custom positions of the selected type are shown in this list. Select one to set the position.",
              },
              [],
            ),
            m(
              "button#aboutposition.ripple",
              {
                disabled: !is_ready || review_mode,
                title:
                  "Click to show the information of current selected custom position (position variant).",
              },
              "Position INFO",
            ),
            m(
              "button#aboutvariant.ripple",
              {
                disabled: !is_ready || review_mode,
                title:
                  "Click to show the information and the wiki page (if it has, otherwise not shown) of current variant.",
                onclick: () => {
                  let name = getVariantName(
                    $("#dropdown-variant").value,
                    true,
                    false,
                  );
                  let description = getVariantDescription(
                    $("#dropdown-variant").value,
                    false,
                  );
                  let wiki = getVariantWikiPageURL(
                    $("#dropdown-variant").value,
                    false,
                  );
                  if (description) {
                    if (wiki) {
                      if (
                        window.confirm(
                          `Variant ${name} (ID: ${$("#dropdown-variant").value}):\n${description}\n\nWiki: ${wiki}\n\nDo you want to visit the wiki page?`,
                        )
                      ) {
                        OpenURL(wiki);
                      }
                    } else {
                      window.alert(
                        `Variant ${name} (ID: ${$("#dropdown-variant").value}):\n${description}`,
                      );
                    }
                  } else {
                    window.alert(
                      "This variant does not provide a description. You can upload a variantsettings.txt yourself to add a description for it.",
                    );
                  }
                },
              },
              "Variant INFO",
            ),
            m(
              "button.ripple",
              {
                disabled: !is_ready || review_mode,
                title: "Click to open PGN file and EPD file parser.",
                onclick: () => {
                  if (!is_ready || review_mode) {
                    return;
                  }
                  if (fgs) {
                    if (window.ffishlib) {
                      fgs.ShowPGNOrEPDFileUI(game_list, window.ffishlib);
                    }
                  }
                },
              },
              "PGN/EPD Parser",
            ),
          ]),
          m("div#input", { hidden: during_play }, [
            m("p", "Position:"),
            m("input[type=text]#fen", {
              placeholder: "Input FEN Here",
              title:
                "Input the Forsyth-Edwards Notation (FEN) of the position you want to load. Leave it blank to use default position.",
              maxlength: 9999,
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen(true, false);
              },
            }),
            m("input[type=text]#move", {
              placeholder: "Input Move Here",
              title:
                "Input the moves in UCI format based on the FEN. Leave it blank to indicate no move.",
              maxlength: 9999,
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen(true, false);
              },
            }),
            m(
              "button#setpos.ripple",
              {
                disabled: !is_ready || review_mode,
                title: "Click to set the FEN and the moves to the board.",
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  resetTimer();
                  stockfish.postMessage(`stop`);
                  stockfish.postMessage(`ucinewgame`);
                  if (fge.first_engine) {
                    fge.first_engine.NewGame();
                  }
                  if (fge.second_engine) {
                    fge.second_engine.NewGame();
                  }
                  if (fge.analysis_engine) {
                    fge.analysis_engine.NewGame();
                  }
                  window.setTimeout(() => {
                    setFen(true, false);
                  }, 10);
                  $("#currentposition").click();
                },
              },
              "Set",
            ),
            m(
              "button#reset.ripple",
              {
                disabled: !is_ready,
                title: "Click to reset the position to default position.",
                onclick: reset,
              },
              "Reset",
            ),
            m(
              "button#restart.ripple",
              {
                disabled: !is_ready || review_mode,
                title:
                  "Click to clear the moves and set the position to initial position.",
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  document.getElementById("move").value = "";
                  document.getElementById("setpos").click();
                },
              },
              "Restart",
            ),
            m(
              "button#undo.ripple",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title: "Click to undo last move.",
                hidden: review_mode,
                onclick: undo,
              },
              "Undo",
            ),
          ]),
          m(
            "div#binengineinput",
            { hidden: during_play || fge.WebSocketStatus != "CONNECTED" },
            [
              m(
                "button.ripple",
                {
                  title: "Click to enter binary engine management UI.",
                  onclick: () => {
                    fge.ShowEngineManagementUI(engine_list, fge.ws);
                  },
                },
                "Engine Management",
              ),
              m("div#whiteenginesettings", [
                m("p", "1st binary engine settings:"),
                m("input[type=number]#whitedepth", {
                  placeholder: "Depth",
                  title:
                    "The maximum depth that the engine is allowed to search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m("input[type=number]#whitemovetime", {
                  placeholder: "Movetime",
                  title:
                    "The time in milliseconds that the engine can think at most.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 0,
                }),
                m("input[type=number]#whitenodes", {
                  placeholder: "Nodes",
                  title: "The number of moves that the engine should search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m(
                  "p#whiteunsupportedvariant",
                  { hidden: true },
                  "1st engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
              m("div#blackenginesettings", [
                m("p", "2nd binary engine settings:"),
                m("input[type=number]#blackdepth", {
                  placeholder: "Depth",
                  title:
                    "The maximum depth that the engine is allowed to search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m("input[type=number]#blackmovetime", {
                  placeholder: "Movetime",
                  title:
                    "The time in milliseconds that the engine can think at most.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 0,
                }),
                m("input[type=number]#blacknodes", {
                  placeholder: "Nodes",
                  title: "The number of moves that the engine should search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m(
                  "p#blackunsupportedvariant",
                  { hidden: true },
                  "2nd engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
              m("div#analysisenginesettings", [
                m(
                  "p#analysisunsupportedvariant",
                  { hidden: true },
                  "Analysis engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
            ],
          ),
          m("div#input2", { hidden: during_play }, [
            m("p", "Settings:"),
            m("input[type=number]#depth", {
              placeholder: "Depth",
              title:
                "The maximum depth in browser Fairy-Stockfish is allowed to search.",
              disabled: !is_ready || analysis_mode,
              min: 1,
              max: 255,
            }),
            m("input[type=number]#movetime", {
              placeholder: "Movetime",
              title:
                "The time in milliseconds that in browser Fairy-Stockfish can think at most.",
              disabled: !is_ready || analysis_mode,
              min: 0,
            }),
            m("input[type=number]#nodes", {
              placeholder: "Nodes",
              title:
                "The number of moves that in browser Fairy-Stockfish should search.",
              disabled: !is_ready || analysis_mode,
              min: 1,
            }),
            m("input[type=number]#threads", {
              placeholder: "Threads",
              title:
                "The number of parallel searching threads of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 512,
            }),
            m("input[type=number]#hash", {
              placeholder: "Hash",
              title:
                "The size in megabytes of the hash table of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 33554432,
            }),
            m("input[type=number]#multipv", {
              placeholder: "MultiPV",
              title:
                "The number of principal variations (engine lines, PV) of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 500,
            }),
            m(
              "button#go.ripple",
              {
                disabled: !is_ready,
                title:
                  "Click to tell the corresponding engine to start thinking.",
                onclick: () => {
                  if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                  }
                  if (board_setup_mode) {
                    return;
                  }
                  setTimeout(() => {
                    if (!review_mode) {
                      setFen(true, false);
                    }
                    go(false, false);
                  }, 10);
                },
              },
              "Go",
            ),
            m(
              "button#stop.ripple",
              {
                disabled: !is_ready,
                title: "Click to immediately stop all engines from thinking.",
                onclick: () => {
                  force_stop();
                  if (fge.first_engine) {
                    fge.first_engine.ForceStop();
                  }
                  if (fge.second_engine) {
                    fge.second_engine.ForceStop();
                  }
                  if (fge.analysis_engine) {
                    fge.analysis_engine.ForceStop();
                  }
                  if (during_engine_match) {
                    during_engine_match = false;
                    setTimeout(() => {
                      if (
                        window.confirm(
                          `Played games: ${engine_match_played_game_count}\nFirst engine (WHITE) wins: ${engine_match_white_wins}\nSecond engine (BLACK) wins: ${engine_match_black_wins}\nDraws: ${engine_match_draws}\n\nDo you want to save the PGN of played games?`,
                        )
                      ) {
                        document.getElementById("saveenginematchgames").click();
                      }
                    }, 500);
                  }
                },
              },
              "Stop",
            ),
            m(
              "label#label-analysis",
              {
                title:
                  "When checked, interactive analysis mode is enabled and will use analysis binary engine (if loaded, otherwise in browser Fairy-Stockfish) to think on the position infinitely.",
              },
              m("input[type=checkbox]#analysis", {
                checked: analysis_mode,
                disabled:
                  play_white ||
                  play_black ||
                  advanced_time_control ||
                  board_setup_mode ||
                  random_mover_white ||
                  random_mover_black ||
                  engine_match_mode,
                onclick: () => {
                  analysis_mode = !analysis_mode;
                },
              }),
              "Analysis",
            ),
            m(
              "label",
              {
                title: "When checked, engine will play as first mover (white).",
              },
              m("input[type=checkbox]#playwhite", {
                checked: play_white,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  random_mover_white,
                onclick: () => {
                  play_white = !play_white;
                },
              }),
              "Engine white",
            ),
            m(
              "label",
              {
                title:
                  "When checked, engine will play as second mover (black).",
              },
              m("input[type=checkbox]#playblack", {
                checked: play_black,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  random_mover_black,
                onclick: () => {
                  play_black = !play_black;
                },
              }),
              "Engine black",
            ),
            m(
              "label",
              {
                title:
                  "When checked, random moves will be made when it's first mover (white) to move.",
              },
              m("input[type=checkbox]#randommoverwhite", {
                checked: random_mover_white,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  play_white ||
                  engine_match_mode,
                onclick: () => {
                  random_mover_white = !random_mover_white;
                },
              }),
              "Random mover white",
            ),
            m(
              "label",
              {
                title:
                  "When checked, random moves will be made when it's second mover (black) to move.",
              },
              m("input[type=checkbox]#randommoverblack", {
                checked: random_mover_black,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  play_black ||
                  engine_match_mode,
                onclick: () => {
                  random_mover_black = !random_mover_black;
                },
              }),
              "Random mover black",
            ),
            m("p#label-stm", { hidden: true }),
            m("input#displaymoves", {
              placeholder: "Moves displayed on board for analysis",
              hidden: true,
            }),
            m("input[type=number]#displayready", {
              placeholder: "Board display update ready status",
              hidden: true,
            }),
            m("input[type=number]#isreviewmode", {
              placeholder: "Stores value to judge whether it is in review mode",
              hidden: true,
            }),
            m("input#gameresult", {
              placeholder: "The game result",
              hidden: true,
              onclick: () => {
                displayGameResult();
              },
            }),
            m(
              "p#gamestatus",
              {
                hidden: true,
              },
              "END",
            ),
            m("input#engineoutputline", { hidden: true }),
            m("input[type=number]#timeoutside", {
              placeholder: "Stores value that the side that run out of time",
              hidden: true,
            }),
            m(
              "p#set",
              {
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  play_move = false;
                  //console.log(Error());
                  window.setTimeout(() => {
                    setFen(false, true);
                  }, 10);
                },
                hidden: true,
              },
              "Set position (internal)",
            ),
            m(
              "p#loadthemes",
              {
                hidden: true,
                onclick: () => {
                  LoadThemes();
                  LoadVariantSettings("server", null);
                  LoadUIThemes();
                },
              },
              "Load Themes (internal)",
            ),
            m(
              "p#initializethemes",
              {
                hidden: true,
                onclick: () => {
                  setupThemeDropdowns();
                  changePieces(true);
                  changeBoard(true);
                },
              },
              "Initialize Themes (internal)",
            ),
            m(
              "p#setupuithemes",
              {
                hidden: true,
                onclick: () => {
                  setupUIThemeDropdown();
                  let UserSelectedUITheme = localStorage.getItem(
                    "UserSelectedUITheme",
                  );
                  if (UserSelectedUITheme) {
                    changeUI(UserSelectedUITheme, false, true);
                  } else {
                    changeUI(
                      $("#dropdown-uitheme")[
                        $("#dropdown-uitheme").selectedIndex
                      ].value,
                      false,
                      true,
                    );
                  }
                },
              },
              "Initialize UI Themes (internal)",
            ),
            m(
              "p#updatevarianttypedropdown",
              {
                hidden: true,
                onclick: () => {
                  updateVariantTypeDropdown();
                },
              },
              "Update Variant Type Dropdown (internal)",
            ),
            m(
              "p#copysetfen",
              {
                hidden: true,
                onclick: () => {
                  copyText($("#fen").value);
                },
              },
              "Copy Set FEN (internal)",
            ),
            m(
              "p#randommovergo",
              {
                hidden: true,
              },
              "Random Mover Go (internal)",
            ),
            m(
              "p#binengineoutputinit",
              {
                hidden: true,
                onclick: () => {
                  if (fge.first_engine) {
                    const target = document.getElementById("whiteengineoutput");
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      target.textContent += first_engine_output;
                      first_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.first_engine.OutputUpdateCallBack = (color, msg) => {
                      first_engine_output += "◀◀ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.first_engine.SendMessageCallBack = (msg) => {
                      first_engine_output += "\n▶▶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.first_engine.OnErrorMessageCallBack = (msg) => {
                      if (during_play) {
                        window.alert(msg);
                      }
                    };
                  }
                  if (fge.second_engine) {
                    const target = document.getElementById("blackengineoutput");
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      target.textContent += second_engine_output;
                      second_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.second_engine.OutputUpdateCallBack = (color, msg) => {
                      second_engine_output += "◀◀ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.second_engine.SendMessageCallBack = (msg) => {
                      second_engine_output += "\n▶▶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.second_engine.OnErrorMessageCallBack = (msg) => {
                      if (during_play) {
                        window.alert(msg);
                      }
                    };
                  }
                  if (fge.analysis_engine) {
                    const target = document.getElementById(
                      "analysisengineoutput",
                    );
                    const outputline =
                      document.getElementById("engineoutputline");
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      target.textContent += analysis_engine_output;
                      analysis_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.analysis_engine.OutputUpdateCallBack = (color, msg) => {
                      analysis_engine_output += "◀◀ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.analysis_engine.EvaluationUpdateCallBack = (msg) => {
                      outputline.value = msg;
                      outputline.click();
                    };
                    fge.analysis_engine.SendMessageCallBack = (msg) => {
                      analysis_engine_output += "\n▶▶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                  }
                  scrollOutput();
                },
              },
              "Binary Engine Output Event Handler Initialization (internal)",
            ),
          ]),
          m("div#input3", { hidden: during_play }, [
            m("p", "Additional Features: "),
            m(
              "label#label-advtimectrl",
              {
                title:
                  "When checked, advanced timing system is used to play time controlled games.",
              },
              m("input[type=checkbox]#advtimectrl", {
                checked: advanced_time_control,
                disabled: analysis_mode || review_mode || board_setup_mode,
                onclick: () => {
                  advanced_time_control = !advanced_time_control;
                },
              }),
              "Advanced Time Control",
            ),
            m(
              "label#label-boardsetup",
              {
                title:
                  "When checked, the board will enter setup mode where you can edit the position. Uncheck to exit this mode.",
              },
              m("input[type=checkbox]#isboardsetup", {
                checked: board_setup_mode,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  advanced_time_control ||
                  select_move_dialog ||
                  engine_match_mode,
                onclick: () => {
                  board_setup_mode = !board_setup_mode;
                  triggerBoardSetupPieceIdentifier(true);
                },
              }),
              "Board Setup",
            ),
            m(
              "label#label-advpgnmode",
              {
                title:
                  "(Experimental) When checked, a mini board is shown which displays the position at that time when you click the move in the move list (PV line or move history). Uncheck to exit this mode. Note that enabling this mode might make the page become slower, and only enable it if you need it as it's an experimental feature.",
              },
              m("input[type=checkbox]#isadvpgnmode", {
                disabled: !is_ready,
              }),
              "Move Visualization",
            ),
            m(
              "label#label-enginematchmode",
              {
                title:
                  "When checked, the first engine and the second engine will play against each other continuously for some times specified.",
              },
              m("input[type=checkbox]#isenginematchmode", {
                checked: engine_match_mode,
                disabled:
                  !is_ready ||
                  during_engine_match ||
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  random_mover_white ||
                  random_mover_black,
                onclick: () => {
                  engine_match_mode = !engine_match_mode;
                },
              }),
              "Engine Match",
            ),
            m(
              "label#label-isfischerrandommode",
              {
                title:
                  "When checked, enable fischer random (chess960) mode, which enables fischer random castling rules. This has no effect to variants that do not have castling.",
              },
              m("input[type=checkbox]#isfischerrandommode", {
                checked: fischer_random_mode,
                disabled:
                  !is_ready ||
                  during_engine_match ||
                  during_play ||
                  review_mode ||
                  board_setup_mode,
                onclick: () => {
                  fischer_random_mode = !fischer_random_mode;
                  document
                    .getElementById("dropdown-variant")
                    .dispatchEvent(new Event("change"));
                },
              }),
              "Fischer Random",
            ),
          ]),
          m(
            "div#enginematch",
            {
              hidden:
                !engine_match_mode || (!during_engine_match && during_play),
            },
            [
              m("div#enginematchsettings", [
                m("p", "Game count to self play:"),
                m("input[type=number]#enginematchgamecount", {
                  placeholder: "Game count",
                  min: 1,
                  title:
                    "The count of the games to let the engines play against each other.",
                }),
                m(
                  "button#saveenginematchgames.ripple",
                  {
                    title:
                      "Click to save the games played in engine match to PGN file.",
                    disabled: !is_ready || during_engine_match || review_mode,
                    onclick: () => {
                      if (
                        !engine_match_mode ||
                        during_engine_match ||
                        review_mode
                      ) {
                        return;
                      }
                      let filecontent = "";
                      engine_match_game_list.forEach((val) => {
                        filecontent += `${val.ToPortableGameNotation(window.ffishlib)}\n`;
                      });
                      const blob = new Blob([filecontent], {
                        type: "text/plain",
                      });
                      const a = document.createElement("a");
                      a.href = URL.createObjectURL(blob);
                      a.download = "EngineMatch.pgn";
                      document.body.appendChild(a);
                      a.click();
                      document.body.removeChild(a);
                    },
                  },
                  "Save Played Games To PGN",
                ),
                m(
                  "button#startenginematch.ripple",
                  {
                    title: "Click to start a series of engine vs engine games.",
                    disabled: !is_ready || during_engine_match || review_mode,
                    onclick: () => {
                      if (
                        !engine_match_mode ||
                        during_engine_match ||
                        review_mode
                      ) {
                        return;
                      }
                      const whitedepth = document.getElementById("whitedepth");
                      const whitemovetime =
                        document.getElementById("whitemovetime");
                      const whitenodes = document.getElementById("whitenodes");
                      const blackdepth = document.getElementById("blackdepth");
                      const blackmovetime =
                        document.getElementById("blackmovetime");
                      const blacknodes = document.getElementById("blacknodes");
                      const depth = document.getElementById("depth");
                      const movetime = document.getElementById("movetime");
                      const nodes = document.getElementById("nodes");
                      if (advanced_time_control) {
                        if (
                          white_timer_type == "infinite" ||
                          black_timer_type == "infinite"
                        ) {
                          window.alert(
                            "Cannot start engine match with infinite time.",
                          );
                          return;
                        }
                      } else {
                        if (fge) {
                          if (fge.first_engine && fge.first_engine.IsUsing) {
                            if (
                              (!whitedepth.validity.valid ||
                                whitedepth.value == "") &&
                              (!whitemovetime.validity.valid ||
                                whitemovetime.value == "") &&
                              (!whitenodes.validity.valid ||
                                whitenodes.value == "")
                            ) {
                              window.alert(
                                "Move control is not set or invalid for first binary engine. Set depth/movetime/nodes before starting an engine match.",
                              );
                              return;
                            }
                          } else {
                            if (
                              (!depth.validity.valid || depth.value == "") &&
                              (!movetime.validity.valid ||
                                movetime.value == "") &&
                              (!nodes.validity.valid || nodes.value == "")
                            ) {
                              window.alert(
                                "Move control is not set or invalid for in browser Fairy-Stockfish. Set depth/movetime/nodes before starting an engine match.",
                              );
                              return;
                            }
                          }
                          if (fge.second_engine && fge.second_engine.IsUsing) {
                            if (
                              (!blackdepth.validity.valid ||
                                blackdepth.value == "") &&
                              (!blackmovetime.validity.valid ||
                                blackmovetime.value == "") &&
                              (!blacknodes.validity.valid ||
                                blacknodes.value == "")
                            ) {
                              window.alert(
                                "Move control is not set or invalid for second binary engine. Set depth/movetime/nodes before starting an engine match.",
                              );
                              return;
                            }
                          } else {
                            if (
                              (!depth.validity.valid || depth.value == "") &&
                              (!movetime.validity.valid ||
                                movetime.value == "") &&
                              (!nodes.validity.valid || nodes.value == "")
                            ) {
                              window.alert(
                                "Move control is not set or invalid for in browser Fairy-Stockfish. Set depth/movetime/nodes before starting an engine match.",
                              );
                              return;
                            }
                          }
                        } else {
                          if (
                            (!depth.validity.valid || depth.value == "") &&
                            (!movetime.validity.valid ||
                              movetime.value == "") &&
                            (!nodes.validity.valid || nodes.value == "")
                          ) {
                            window.alert(
                              "Move control is not set or invalid for in browser Fairy-Stockfish. Set depth/movetime/nodes before starting an engine match.",
                            );
                            return;
                          }
                        }
                      }
                      engine_match_game_list = [];
                      let game_count = document.getElementById(
                        "enginematchgamecount",
                      ).value;
                      play_white = true;
                      play_black = true;
                      during_engine_match = true;
                      engine_match_played_game_count = 0;
                      if (
                        !document.getElementById("enginematchgamecount")
                          .validity.valid ||
                        game_count == ""
                      ) {
                        engine_match_total_game_count = 1;
                      } else {
                        engine_match_total_game_count = parseInt(game_count);
                      }
                      engine_match_white_wins = 0;
                      engine_match_black_wins = 0;
                      engine_match_draws = 0;
                      document.getElementById("enginematchinfo").innerText =
                        `Games played: 0 | Total games to play: ${engine_match_total_game_count}`;
                      if (advanced_time_control) {
                        document.getElementById("gamestart").click();
                      } else {
                        document.getElementById("set").click();
                      }
                    },
                  },
                  "Start Engine Match",
                ),
                m(
                  "span",
                  {
                    style: "cursor: pointer;",
                    onclick: () =>
                      window.alert(
                        'You can let the engines play against each other (Supports binary engines, based on your settings) for a certain count of games automatically and Fairyground will collect the statistics on win/draw/loss counts for you to test variant balance or engine strength.\nYou need to setup time settings first, e.g. depth/move time/nodes controlled moving or use advanced time control. All the matches uses that setting after you click <Start Engine Match>.\nYou can click <Stop> to exit this mode at any time. If you use advanced time control, abort game first and then click <Stop>.\nThis will not swap sides, so if you want to let engines play each side, you can let them play N games and then swap side manually to play another N games.\nDo not do unnecessary things like setting FEN or changing variant during the match, otherwise something unexpected may happen.\nNote: If the match stops unexpectedly, then it usually indicates an engine crash. Check the console (Press Ctrl+Shift+I and select "Console" to see it) to see what\'s going on.',
                      ),
                  },
                  "[?]",
                ),
              ]),
              m(
                "p#enginematchinfo",
                'Click <Start Engine Match> to automatically start engine vs engine games for some times specified in "Game count".',
              ),
            ],
          ),
          m(
            "div#advancedtimesettings",
            { hidden: !advanced_time_control || during_play },
            [
              m("div#whitetimesettings", [
                m("p", "White Time Settings:  "),
                m(
                  "select#dropdown-whitetimemode",
                  {
                    disabled: !is_ready || review_mode,
                    title: "The time control mode for first mover (white).",
                    onchange: () => {
                      $("#whitetimetype").innerHTML = $(
                        "#dropdown-whitetimemode",
                      ).value;
                      white_timer_type = $("#dropdown-whitetimemode").value;
                    },
                  },
                  [
                    m(
                      "option",
                      {
                        value: "infinite",
                        title: "First mover has infinite time",
                      },
                      "Infinite",
                    ),
                    m(
                      "option",
                      {
                        value: "tournament",
                        title:
                          "First mover's time is limited and they can get time increment after every move.",
                      },
                      "Tournament",
                    ),
                    m(
                      "option",
                      {
                        value: "time per move",
                        title:
                          "First mover must make every move within a fixed time limit.",
                      },
                      "Time Per Move",
                    ),
                    m(
                      "option",
                      {
                        value: "hourglass",
                        title:
                          "First mover's time is limited and their used time on making a move will be added to second mover.",
                      },
                      "Hourglass",
                    ),
                    m(
                      "option",
                      {
                        value: "byoyomi",
                        title:
                          "(See [Why can I choose different time modes for two sides?] for more details on this mode)",
                      },
                      "Byo-yomi",
                    ),
                  ],
                ),
                m("input[type=number]#whitestarttime", {
                  placeholder: "Start time (ms)",
                  title: "The time at beginning in milliseconds.",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#whitetimegain", {
                  placeholder: "Time gain (ms)",
                  title:
                    "Get a time increment in milliseconds after every move.",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    white_timer_type != "tournament",
                  hidden: white_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#whitebyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  title:
                    "The duration in milliseconds of every byoyomi period.",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitebyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  title: "The count of byoyomi periods.",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitetimemargin", {
                  placeholder: "Timeout margin (ms)",
                  title:
                    "The time can be exceeded by this many milliseconds before running out of time.",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#blacktimesettings", [
                m("p", "Black Time Settings:  "),
                m(
                  "select#dropdown-blacktimemode",
                  {
                    disabled: !is_ready || review_mode,
                    title: "The time control mode for second mover (black).",
                    onchange: () => {
                      $("#blacktimetype").innerHTML = $(
                        "#dropdown-blacktimemode",
                      ).value;
                      black_timer_type = $("#dropdown-blacktimemode").value;
                    },
                  },
                  [
                    m(
                      "option",
                      {
                        value: "infinite",
                        title: "Second mover has infinite time",
                      },
                      "Infinite",
                    ),
                    m(
                      "option",
                      {
                        value: "tournament",
                        title:
                          "Second mover's time is limited and they can get time increment after every move.",
                      },
                      "Tournament",
                    ),
                    m(
                      "option",
                      {
                        value: "time per move",
                        title:
                          "Second mover must make every move within a fixed time limit.",
                      },
                      "Time Per Move",
                    ),
                    m(
                      "option",
                      {
                        value: "hourglass",
                        title:
                          "Second mover's time is limited and their used time on making a move will be added to first mover.",
                      },
                      "Hourglass",
                    ),
                    m(
                      "option",
                      {
                        value: "byoyomi",
                        title:
                          "(See [Why can I choose different time modes for two sides?] for more details on this mode)",
                      },
                      "Byo-yomi",
                    ),
                  ],
                ),
                m("input[type=number]#blackstarttime", {
                  placeholder: "Start time (ms)",
                  title: "The time at beginning in milliseconds.",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#blacktimegain", {
                  placeholder: "Time gain (ms)",
                  title:
                    "Get a time increment in milliseconds after every move.",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    black_timer_type != "tournament",
                  hidden: black_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#blackbyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  title:
                    "The duration in milliseconds of every byoyomi period.",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blackbyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  title: "The count of byoyomi periods.",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blacktimemargin", {
                  placeholder: "Timeout margin (ms)",
                  title:
                    "The time can be exceeded by this many milliseconds before running out of time.",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#gamecontrol-start", [
                m(
                  "button#gamestart.ripple",
                  {
                    disabled: !is_ready || review_mode,
                    title: "Click to start a game in advanced timing system.",
                    onclick: goWithTimeControl,
                  },
                  "Start Game",
                ),
                m(
                  "p",
                  {
                    style: "cursor: pointer;",
                    onclick: () => {
                      alert(
                        'This time control system allows user select different time modes for two sides and gives user more choice on time odds settings.\nThe time modes are:\nInfinite: Selected side has infinite time.\nTournament: Selected side has limited time and may get a time increment after a move.\nTime per move: Selected side need to make each move within a fixed time limit.\nHourglass: Selected side has limited time and used time will be added to opponent\'s time.\nByo-yomi: Selected side will enter the countdown(byoyomi) period(s) after their initial time runs out. During countdown periods, if the player make a move before the countdown period time runs out, the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"), otherwise the remaining period count will be decreased by 1 and the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"). If there\'s no countdown periods (Specified in "Byoyomi period count") left and the remaining time runs out, this side runs out of time.\nNote: if you set engine\'s time mode to infinite, it will think forever!',
                      );
                    },
                  },
                  "[Why can I choose different time modes for two sides?]",
                ),
                m(
                  "p",
                  {
                    style: "cursor: pointer;",
                    onclick: () => {
                      alert(
                        "Start time: The initial time (in milliseconds) at the beginning of the game. Not applicable to infinite.\nTime gain: Get a time increment of this many milliseconds after every move. Only applicable to tournament.\nByoyomi period length: The time (in milliseconds) of each period when in extra countdown(byoyomi) periods. Only applicable to byo-yomi.\nByoyomi period count: The count of countdown(byoyomi) periods. Only applicable to byo-yomi.\nTimeout margin: The time can be exceeded by this many milliseconds. The remaining time will be shown as minus numbers if exceeded. Not applicable to infinite.",
                      );
                    },
                  },
                  "  [What are these parameters?]",
                ),
              ]),
            ],
          ),
          m("div#visualeffects", [
            m("p", "Visual effect: "),
            m(
              "select#dropdown-visualeffect",
              {
                disabled: !is_ready || board_setup_mode,
                title:
                  "A visual effect is a change on the visibility of the board. Usually it's restricting piece visibility.",
              },
              [
                m(
                  "option",
                  {
                    value: "<DISABLED>",
                    title: "No visual effect. The board is shown as is.",
                  },
                  "<DISABLED>",
                ),
                m(
                  "option",
                  {
                    value: "fogofwar",
                    title:
                      "Fog of war is a visual effect that can prevent a player from seeing unreachable squares except wall squares.",
                  },
                  "Fog Of War",
                ),
                m(
                  "option",
                  {
                    value: "wargame",
                    title:
                      "War game is a visual effect that can prevent a player from seeing opponent's pieces",
                  },
                  "War Game",
                ),
              ],
            ),
            m("p", "Perspective: "),
            m(
              "select#dropdown-visualeffectperspective",
              {
                disabled: !is_ready || board_setup_mode,
                title: "Choose the perspective of visual effect.",
              },
              [
                m(
                  "option",
                  {
                    value: "white",
                    title: "See the board at white's perspective.",
                  },
                  "White's View",
                ),
                m(
                  "option",
                  {
                    value: "black",
                    title: "See the board at black's perspective.",
                  },
                  "Black's View",
                ),
                m(
                  "option",
                  {
                    value: "alternate",
                    title: "See the board at current mover's perspective.",
                  },
                  "View Alternately",
                ),
              ],
            ),
          ]),
          m("div#gamesettings", [
            m("p", "Quick promote/demote: "),
            m(
              "select#dropdown-quickpromotion",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "Select an option to make the promotion or demotion automatically if available.",
              },
              [
                m("option", { value: "" }, "<DISABLED>"),
                m("option", { value: "a" }, "a"),
                m("option", { value: "b" }, "b"),
                m("option", { value: "c" }, "c"),
                m("option", { value: "d" }, "d"),
                m("option", { value: "e" }, "e"),
                m("option", { value: "f" }, "f"),
                m("option", { value: "g" }, "g"),
                m("option", { value: "h" }, "h"),
                m("option", { value: "i" }, "i"),
                m("option", { value: "j" }, "j"),
                m("option", { value: "k" }, "k"),
                m("option", { value: "l" }, "l"),
                m("option", { value: "m" }, "m"),
                m("option", { value: "n" }, "n"),
                m("option", { value: "o" }, "o"),
                m("option", { value: "p" }, "p"),
                m("option", { value: "q" }, "q"),
                m("option", { value: "r" }, "r"),
                m("option", { value: "s" }, "s"),
                m("option", { value: "t" }, "t"),
                m("option", { value: "u" }, "u"),
                m("option", { value: "v" }, "v"),
                m("option", { value: "w" }, "w"),
                m("option", { value: "x" }, "x"),
                m("option", { value: "y" }, "y"),
                m("option", { value: "z" }, "z"),
                m("option", { value: "+" }, "Promote (+)"),
                m("option", { value: "-" }, "Demote (-)"),
                m("option", { value: "=" }, "Keep (=)"),
              ],
            ),
            m(
              "label",
              {
                title:
                  "When checked, you can also make a move by clicking the piece and then clicking the target square.",
              },
              m("input[type=checkbox]#clickclickmove", {
                disabled: review_mode,
              }),
              "Click-click move",
            ),
            m(
              "button#passmove.ripple",
              { disabled: !is_ready, title: "Click to pass your turn." },
              "Pass This Turn",
            ),
            m(
              "button#placewall.ripple",
              {
                disabled: !is_ready,
                title:
                  "Click to place a wall only (Requires entering choice in prompt dialog).",
              },
              "Place A Wall",
            ),
            m(
              "label#label-showmovediv",
              m("input[type=checkbox]#showmovediv", {
                checked: select_move_dialog,
                disabled: review_mode || board_setup_mode,
                onclick: () => {
                  select_move_dialog = !select_move_dialog;
                },
              }),
              "Show moves dialog",
            ),
            m(
              "span",
              {
                style: "cursor: pointer;",
                onclick: () =>
                  window.alert(
                    "If you cannot make your move on the board (For example, ATAXX drops), you can open this dialog to make the move.",
                  ),
              },
              "[?]",
            ),
            m(
              "span",
              {
                style: "cursor: pointer; margin-left: 5px;",
                onclick: () =>
                  window.alert(
                    "A null move is considered as a move that have the same original square and destination square. Double click a square (No matter whether it's empty or not) will make a null move on that square.\nNote:\n1. In most cases passing a turn is equivalent to making a null move on the king.\n2. In Atlantis variant, placing a wall without moving any piece requires to make a null move on the most bottom then the most left piece of your color.\n3. Click <show moves dialog> to see all legal moves if you are not sure how to make a move.",
                  ),
              },
              "[How to make null moves?]",
            ),
          ]),
          m("div#boardsetupsettings", { hidden: !board_setup_mode }, [
            m("p", "Board Setup:"),
            m("div#boardpiecechange", { disabled: !is_ready }, [
              m(
                "select#dropdown-setpiece",
                {
                  title:
                    "<move>: Move the pieces on the board.\n<delete>: Click on a square to delete the piece on that square.\n<letter>: Click on a square to place a piece of that letter. If there is a plus ahead, it means the promoted from.",
                  onchange: () => {
                    let fakepiece = document.getElementById("fakepiece");
                    let dropdownsetpiece =
                      document.getElementById("dropdown-setpiece");
                    let values = [];
                    let value =
                      dropdownsetpiece[dropdownsetpiece.selectedIndex].value;
                    if (value == undefined || value == "") {
                      return;
                    }
                    let chcode = value.charCodeAt(0);
                    let ch = value.charAt(0);
                    let promoted = false;
                    if (value.charAt(0) == "+") {
                      chcode = value.charCodeAt(1);
                      ch = value.charAt(1);
                      promoted = true;
                    }
                    if (value == "<move>") {
                      values.push("move-piece");
                    } else if (value == "<delete>") {
                      values.push("delete-piece");
                    } else if (
                      value.length > 2 ||
                      (value.length == 2 && value.charAt(0) != "+")
                    ) {
                      return;
                    } else if (chcode >= 65 && chcode <= 90) {
                      values.push(
                        `${promoted ? "p" : ""}${ch.toLowerCase()}-piece`,
                      );
                      values.push("white");
                    } else if (chcode >= 97 && chcode <= 122) {
                      values.push(`${promoted ? "p" : ""}${ch}-piece`);
                      values.push("black");
                    } else if (value == "*") {
                      values.push("_-piece");
                      values.push("black");
                    } else {
                      return;
                    }
                    fakepiece.classList.value = values.join(" ");
                  },
                },
                [
                  m("option", { value: "<move>" }, "<move>"),
                  m("option", { value: "<delete>" }, "<delete>"),
                  m("option", { value: "b" }, "b"),
                  m("option", { value: "k" }, "k"),
                  m("option", { value: "n" }, "n"),
                  m("option", { value: "p" }, "p"),
                  m("option", { value: "q" }, "q"),
                  m("option", { value: "r" }, "r"),
                  m("option", { value: "B" }, "B"),
                  m("option", { value: "K" }, "K"),
                  m("option", { value: "N" }, "N"),
                  m("option", { value: "P" }, "P"),
                  m("option", { value: "Q" }, "Q"),
                  m("option", { value: "R" }, "R"),
                ],
              ),
              m(
                "button#addtopocket.ripple",
                {
                  disabled: !is_ready,
                  title:
                    "Click to add the piece selected in the dropdown to pocket.",
                },
                "Add piece to pocket",
              ),
              m(
                "button#clearboard.ripple",
                { disabled: !is_ready, title: "Click to remove all pieces." },
                "Clear Board",
              ),
              m(
                "button#initboardpos.ripple",
                {
                  disabled: !is_ready,
                  title: "Click to set the board to default position.",
                },
                "Reset Board",
              ),
              m(
                "button#validatepos.ripple",
                {
                  disabled: !is_ready,
                  title: "Click to validate this position.",
                },
                "Validate Position",
              ),
              m(
                "button#boardsetupcopyfen.ripple",
                {
                  disabled: !is_ready,
                  title:
                    "Click to set the position, and then uncheck Board Setup to play or analyze.",
                },
                "Apply",
              ),
            ]),
            m("div#pocketpiecechange", { hidden: true }, [
              m("form#pieceinpocket", { disabled: !is_ready }, [
                m("table#tablepieceinpocket", [
                  m("tr", [m("td", "Piece ID"), m("td", "Amount")]),
                ]),
              ]),
            ]),
          ]),
          m("div#outputs", [
            m("div", [
              m("div#chessground-container-div.defaultboard.default.board8x8", [
                m("div.cg-wrap.pocket-top", [m("div#pocket-top")]),
                m("div#chessground-board"),
                m("div.cg-wrap.pocket-bottom", [m("div#pocket-bottom")]),
              ]),
              m("div#boardsetupsettings2", { hidden: !board_setup_mode }, [
                m("div", [
                  m("p", "Side to move:"),
                  m(
                    "select#dropdown-sidetomove",
                    { title: "Select the side to move in this position." },
                    [
                      m("option", { value: "First Mover" }, "First Mover"),
                      m("option", { value: "Second Mover" }, "Second Mover"),
                    ],
                  ),
                ]),
                m("div", [
                  m(
                    "label",
                    {
                      title:
                        "Check if first mover has the right to castle kingside.",
                    },
                    m("input[type=checkbox]#whitekingsidecastle"),
                    "White O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if first mover has the right to castle queenside.",
                    },
                    m("input[type=checkbox]#whitequeensidecastle"),
                    "White O-O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if second mover has the right to castle kingside.",
                    },
                    m("input[type=checkbox]#blackkingsidecastle"),
                    "Black O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if second mover has the right to castle queenside.",
                    },
                    m("input[type=checkbox]#blackqueensidecastle"),
                    "Black O-O-O",
                  ),
                ]),
                m("div", [
                  m("input[type=number]#halfmoveclock", {
                    placeholder: "Half move clock",
                    title:
                      "The number in half move clock, which records the moves that does not capture or is not irreversible for N-move rule.",
                    min: 0,
                  }),
                  m("input[type=number]#whiteremainingchecks", {
                    placeholder: "White remaining checks",
                    title:
                      "The remaining checks of first mover, used in variants that limit check count such as 3 Check.",
                    min: 1,
                  }),
                  m("input[type=number]#blackremainingchecks", {
                    placeholder: "Black remaining checks",
                    title:
                      "The remaining checks of second mover, used in variants that limit check count such as 3 Check.",
                    min: 1,
                  }),
                  m("input[type=number]#currentmovenum", {
                    placeholder: "Current move number",
                    title:
                      "The number of current move in full move format (A turn that both player make a move is 1 full move, 2 half moves).",
                    min: 1,
                  }),
                ]),
                m("div", [
                  m("input[type=number]#enpassantfile", {
                    placeholder: "En passant file number",
                    title: "The file (column) number of en passant square.",
                    min: 1,
                    max: 12,
                  }),
                  m("input[type=number]#enpassantrank", {
                    placeholder: "En passant rank number",
                    title: "The rank (row) number of en passant square.",
                    min: 1,
                    max: 10,
                  }),
                ]),
                m("div", [
                  m("input[type=text]#seirwangatingfiles", {
                    placeholder: "Seirawan gating files (e.g. ABab)",
                    title:
                      'The files (e.g. 1st column is a-file, 2nd column is b-file, etc.) where players can perform seirawan gating.\nGateable files for first mover is in upper case and for second mover in lower case.\nExample: "ABcd" means first mover can gate at A and B file while second mover can gate at C and D file.',
                    maxlength: 9999,
                  }),
                ]),
              ]),
              m("div#movecontrol", { hidden: during_play }, [
                m(
                  "button#initialposition.ripple",
                  {
                    onclick: displayInitialPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the initial position of current game.",
                  },
                  "Initial Position",
                ),
                m(
                  "button#currentposition.ripple",
                  {
                    onclick: displayCurrentPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the latest position of current game.",
                  },
                  "Current Position",
                ),
                m(
                  "button#previousposition.ripple",
                  {
                    onclick: displayPreviousMove,
                    disabled: !is_ready,
                    title:
                      "Click to display previous position of the displayed position.",
                  },
                  "Previous Position",
                ),
                m(
                  "button#nextposition.ripple",
                  {
                    onclick: displayNextMove,
                    disabled: !is_ready,
                    title:
                      "Click to display next position of the displayed position.",
                  },
                  "Next Position",
                ),
                m("input[type=number]#gotomovenum", {
                  placeholder: "Half Move Number",
                  disabled: !is_ready,
                  title:
                    "The half number to the half move to display (A turn that both player make a move is 1 full move, 2 half moves).",
                  min: 0,
                }),
                m(
                  "button#specifiedposition.ripple",
                  {
                    onclick: displaySpecifiedPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the position that the half move specified in the input box is moved.",
                  },
                  "Go to Move",
                ),
                m(
                  "button#starthere.ripple",
                  {
                    onclick: () => {
                      if (!review_mode) {
                        return;
                      }
                      $("#move").value = $("#displaymoves").value;
                      $("#currentposition").click();
                    },
                    disabled: !is_ready || !review_mode,
                    title:
                      "Click to set the position to the position displayed on the board. Moves after this position will be discarded.",
                  },
                  "Start Here",
                ),
              ]),
              m(
                "p#reviewmodenote1",
                { hidden: !review_mode },
                "Review mode enabled.",
              ),
              m(
                "p#reviewmodenote2",
                { hidden: !review_mode },
                "You can go to previous moves played to analyze your game, but you cannot make changes to the game. To exit review mode, click <reset>, <current position> or <start here>.",
              ),
              m("div#controls", [
                m("div", [
                  m(
                    "button.ripple",
                    {
                      onclick: () => {
                        changePieces(false);
                      },
                    },
                    "Change pieces",
                  ),
                  m(
                    "select#dropdown-piecetheme",
                    {
                      onchange: () => {
                        changePieceSet(
                          $("#dropdown-piecetheme")[
                            $("#dropdown-piecetheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [
                      m("option", { value: "default" }, "Default Pieces"),
                      m(
                        "option",
                        { value: "userdefined" },
                        getThemeName("userdefined"),
                      ),
                    ],
                  ),
                  m(
                    "button.ripple",
                    {
                      onclick: () => {
                        changeBoard(false);
                      },
                    },
                    "Change board",
                  ),
                  m(
                    "select#dropdown-boardtheme",
                    {
                      onchange: () => {
                        changeBoardSet(
                          $("#dropdown-boardtheme")[
                            $("#dropdown-boardtheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [m("option", { value: "defaultboard" }, "Default Board")],
                  ),
                  m(
                    "button#button-flip.ripple",
                    {
                      onclick: () => {
                        if (board_setup_mode) {
                          setTimeout(() => {
                            triggerBoardSetupPieceIdentifier(false);
                          }, 50);
                        }
                      },
                    },
                    "Flip Board",
                  ),
                  m(
                    "button.ripple",
                    {
                      onclick: () => {
                        let time = Date.now();
                        if (time - previouschangeuitime < 750) {
                          return;
                        }
                        previouschangeuitime = time;
                        const uithemesdropdown =
                          document.getElementById("dropdown-uitheme");
                        changeUI(
                          uithemesdropdown[
                            (uithemesdropdown.selectedIndex + 1) %
                              uithemesdropdown.length
                          ].value,
                          true,
                          true,
                        );
                      },
                    },
                    "Change UI",
                  ),
                  m(
                    "select#dropdown-uitheme",
                    {
                      onchange: () => {
                        changeUI(
                          $("#dropdown-uitheme")[
                            $("#dropdown-uitheme").selectedIndex
                          ].value,
                          true,
                          true,
                        );
                      },
                    },
                    [m("option", { value: "defaultui" }, "Default UI")],
                  ),
                ]),
                m("div", [
                  m(
                    "input[type=range]#range-volume",
                    {
                      min: 0,
                      max: 1,
                      step: 0.05,
                      title: "Adjust sound volume here.",
                    },
                    "range",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "When checked, the legal moves of the selected piece are shown on the board.",
                    },
                    m("input[type=checkbox]#check-dests", {
                      checked: show_dests,
                      onclick: () => {
                        show_dests = !show_dests;
                      },
                    }),
                    "Show Legal Moves & Drops",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "(Legacy) When checked, show the game result in PGN.",
                    },
                    m("input[type=checkbox]#check-adjudicate", {
                      checked: adjudicate,
                      onclick: () => {
                        adjudicate = !adjudicate;
                      },
                    }),
                    "Adjudicate",
                  ),
                  m(
                    "select#boardcoordinate",
                    {
                      title:
                        "Choose the coordinate system for the chess board.",
                    },
                    [
                      m(
                        "option",
                        {
                          value: "ALGEBRAIC",
                          title:
                            "English letters on bottom, Arabic numbers on side.",
                        },
                        "Chess Letter-Algebraic (ALGEBRAIC)",
                      ),
                      m(
                        "option",
                        {
                          value: "SHOGI_ENGLET",
                          title:
                            "Arabic numbers on top, English letters on side.",
                        },
                        "Shogi Algebraic-Letter (SHOGI_ENGLET)",
                      ),
                      m(
                        "option",
                        {
                          value: "SHOGI_ARBNUM",
                          title: "Arabic numbers on top and side.",
                        },
                        "Shogi Algebraic (SHOGI_ARBNUM)",
                      ),
                      m(
                        "option",
                        {
                          value: "SHOGI_HANNUM",
                          title:
                            "Arabic numbers on top, Kanji numbers on side.",
                        },
                        "Shogi Algebraic-Kanji (SHOGI_HANNUM)",
                      ),
                      m(
                        "option",
                        {
                          value: "JANGGI",
                          title:
                            "Arabic numbers on bottom and side, with 0 denoting 10th rank.",
                        },
                        "Janggi Algebraic (JANGGI)",
                      ),
                      m(
                        "option",
                        {
                          value: "XIANGQI_ARBNUM",
                          title: "Arabic numbers on top and bottom.",
                        },
                        "Xiangqi Algebraic (XIANGQI_ARBNUM)",
                      ),
                      m(
                        "option",
                        {
                          value: "XIANGQI_HANNUM",
                          title:
                            "Arabic numbers on top, Hanzi numbers on bottom.",
                        },
                        "Xiangqi Algebraic-Hanzi (XIANGQI_HANNUM)",
                      ),
                      m(
                        "option",
                        {
                          value: "THAI_ALGEBRAIC",
                          title:
                            "Thai letters on bottom, Thai numbers on side.",
                        },
                        "Makruk Thai Letter-Thai Algebraic (THAI_ALGEBRAIC)",
                      ),
                    ],
                  ),
                  m(
                    "label",
                    {
                      title:
                        "When checked, the board coordinates are shown inside of the board. Otherwise they are outside of the board.",
                    },
                    m("input[type=checkbox]#check-innercoordinate", {
                      disabled: !is_ready,
                      onclick: () => {
                        if (
                          document.getElementById("check-innercoordinate")
                            .checked
                        ) {
                          document
                            .getElementById("chessground-container-div")
                            .classList.add("inner");
                        } else {
                          document
                            .getElementById("chessground-container-div")
                            .classList.remove("inner");
                        }
                      },
                    }),
                    "Inner Board Coordinate",
                  ),
                ]),
              ]),
            ]),
            m("div#info", [
              m(
                "select#sannotation",
                {
                  title:
                    "Select the move notation system that is used in move history and engine principal variations.",
                  onchange: () => {
                    const dropdownnotation =
                      document.getElementById("sannotation");
                    const evalbar = document.getElementById("evalbar");
                    const value =
                      dropdownnotation[dropdownnotation.selectedIndex].value;
                    evalbar.classList.remove("xiangqi");
                    evalbar.classList.remove("shogi");
                    evalbar.classList.remove("janggi");
                    if (/xiangqi|ucci/i.test(value)) {
                      evalbar.classList.add("xiangqi");
                    } else if (/shogi|usi/i.test(value)) {
                      evalbar.classList.add("shogi");
                    } else if (/janggi/i.test(value)) {
                      evalbar.classList.add("janggi");
                    }
                  },
                },
                [
                  m("option", { value: "" }, "--Select Notation System--"),
                  m(
                    "option",
                    { value: "DEFAULT" },
                    "Standard/Short Algebraic Notation Without Piece Type Omission (DEFAULT)",
                  ),
                  m(
                    "option",
                    { value: "SAN" },
                    "Standard/Short Algebraic Notation (SAN)",
                  ),
                  m(
                    "option",
                    { value: "LAN" },
                    "Long Algebraic Notation (LAN)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HOSKING" },
                    "Shogi Hosking Notation (SHOGI_HOSKING)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HODGES" },
                    "Shogi George Hodges Notation (SHOGI_HODGES)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HODGES_NUMBER" },
                    "Shogi George Hodges Number-only Notation (SHOGI_HODGES_NUMBER)",
                  ),
                  m("option", { value: "JANGGI" }, "Janggi Notation (JANGGI)"),
                  m(
                    "option",
                    { value: "XIANGQI_WXF" },
                    "World Xiangqi Federation Notation (XIANGQI_WXF)",
                  ),
                  m(
                    "option",
                    { value: "THAI_SAN" },
                    "Thai Standard/Short Algebraic Notation (THAI_SAN)",
                  ),
                  m(
                    "option",
                    { value: "THAI_LAN" },
                    "Thai Long Algebraic Notation (THAI_LAN)",
                  ),
                  m(
                    "option",
                    { value: "FEN" },
                    "Forsyth–Edwards Notation (Fairy-Stockfish) (FEN)",
                  ),
                  m("option", { value: "PGN" }, "Portable Game Notation (PGN)"),
                  m(
                    "option",
                    { value: "EPD" },
                    "Extended Position Description (EPD)",
                  ),
                  m(
                    "option",
                    { value: "FEN+UCIMOVE" },
                    "Forsyth–Edwards Notation (Fairy-Stockfish) and UCI Moves (FEN+UCIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "FEN+USIMOVE" },
                    "Forsyth–Edwards Notation (Fairy-Stockfish) and USI Moves (FEN+USIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "FEN+UCCIMOVE" },
                    "Forsyth–Edwards Notation (Fairy-Stockfish) and UCCI (CECP) Moves (FEN+UCCIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "SFEN+USIMOVE" },
                    "Shogi Forsyth–Edwards Notation and USI Moves (SFEN+USIMOVE)",
                  ),
                ],
              ),
              m("p#positioninfo", ""),
              m("div#timers", { hidden: !advanced_time_control }, [
                m("div#whitetimer", [
                  m("p", "White Time"),
                  m("p#whitetime", "--"),
                  m("p#whitetimetype", "infinite"),
                ]),
                m("div#blacktimer", [
                  m("p", "Black Time"),
                  m("p#blacktime", "--"),
                  m("p#blacktimetype", "infinite"),
                ]),
              ]),
              m(
                "div#timecontrolduringplay",
                { hidden: !advanced_time_control || !during_play },
                [
                  m(
                    "button#addtimeforwhite.ripple",
                    {
                      title:
                        "Add 10 seconds to the remaining time of first mover.",
                      onclick: () => {
                        white_remaining_time = +white_remaining_time + 10000;
                      },
                    },
                    "Add 10s for white",
                  ),
                  m(
                    "button#addtimeforblack.ripple",
                    {
                      title:
                        "Add 10 seconds to the remaining time of second mover.",
                      onclick: () => {
                        black_remaining_time = +black_remaining_time + 10000;
                      },
                    },
                    "Add 10s for black",
                  ),
                  m(
                    "button#gameabort.ripple",
                    {
                      title: "Exit current advanced timing system based game.",
                      onclick: () => {
                        if (confirm("Are you sure to abort the game?")) {
                          gameAbort();
                        }
                      },
                    },
                    "ABORT GAME",
                  ),
                ],
              ),
              m("p#checkcounts"),
              m("div#evaluation", { hidden: !analysis_mode }, [
                m("div#evalbar", [m("p#cp", "0.00"), m("div#evalbarprogress")]),
                m("p#evalinfo", ""),
                m("p#pvinfo", ""),
              ]),
              m("p#currentboardfen"),
              m("p#label-pgn.ripple"),
              m("div#output2", { onupdate: scrollOutput }, [
                m("pre#fsfoutput", engineoutput),
                m(
                  "pre#whiteengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with ▶▶ are the messages sent to the engine.\nLines start with ◀◀ are the messages received from the engine.\n\n",
                ),
                m(
                  "pre#blackengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with ▶▶ are the messages sent to the engine.\nLines start with ◀◀ are the messages received from the engine.\n\n",
                ),
                m(
                  "pre#analysisengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with ▶▶ are the messages sent to the engine.\nLines start with ◀◀ are the messages received from the engine.\n\n",
                ),
              ]),
              m("div#enginecmddiv", [
                m("input[type=text]#enginecmd", {
                  placeholder: "Send command to engine...",
                  title: "The command to send to the engine.",
                  maxlength: 9999,
                  disabled: !is_ready || during_play,
                  onkeyup: (e) => {
                    if (e.keyCode != 13) {
                      e.redraw = false;
                      return;
                    }
                    if (during_play) {
                      return;
                    }
                    sendCommandToEngine();
                  },
                }),
                m(
                  "select#targetengine",
                  {
                    title:
                      "Select the console of the engine. This is the target engine of the command sent, and the engine that sends the message above.",
                    onchange: () => {
                      let index = $("#targetengine").selectedIndex;
                      if (index == 0) {
                        document.getElementById("fsfoutput").hidden = false;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 1) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          false;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 2) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          false;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 3) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          false;
                      }
                    },
                  },
                  [
                    m(
                      "option",
                      { value: "DEFAULT" },
                      "In browser Fairy-Stockfish",
                    ),
                    m("option", { value: "WHITE" }, "1st binary engine"),
                    m("option", { value: "BLACK" }, "2nd binary engine"),
                    m(
                      "option",
                      { value: "ANALYSIS" },
                      "Analysis binary engine",
                    ),
                  ],
                ),
                m(
                  "button#sendenginecmd.ripple",
                  {
                    disabled: during_play,
                    title: "Click to send the command.",
                    onclick: () => {
                      if (during_play) {
                        return;
                      }
                      sendCommandToEngine();
                    },
                  },
                  "SEND",
                ),
                m(
                  "label#label-clearlogonstartthinking",
                  {
                    title:
                      "When checked, automatically clear the console of the binary engine when it starts thinking.",
                  },
                  m("input[type=checkbox]#clearlogonstartthinking", {
                    disabled: !is_ready,
                    checked: clear_log,
                    onclick: () => {
                      clear_log = !clear_log;
                    },
                  }),
                  "Clear Log On Start Thinking",
                ),
                m(
                  "button.ripple",
                  {
                    title: "Click to clear the consoles of the binary engines.",
                    onclick: () => {
                      first_engine_output = "";
                      second_engine_output = "";
                      analysis_engine_output = "";
                      document.getElementById("whiteengineoutput").textContent =
                        "";
                      document.getElementById("blackengineoutput").textContent =
                        "";
                      document.getElementById(
                        "analysisengineoutput",
                      ).textContent = "";
                      scrollOutput();
                    },
                  },
                  "Clear Logs",
                ),
              ]),
            ]),
          ]),
          m("hr#linkdivhr"),
          m("div#links", [
            m("a[href='./index.html']", "play"),
            m("a[href='./advanced.html']", "advanced"),
            m("a[href='./resources.html']", "resources"),
            m("a[href='https://github.com/ianfab/fairyground']", "github"),
          ]),
          m("div#moveselectiondialog", { hidden: !select_move_dialog }, [
            m("div#moveslectdiv", [
              m("p", "Moves:"),
              m("select#availablemovelist", [
                m("option", { value: "" }, "--SELECT MOVE--"),
              ]),
              m("input[type=text]#movesearchfilter", {
                placeholder: "Search UCI move...",
                maxlength: 9999,
              }),
              m(
                "label#label-regexp1",
                m("input[type=checkbox]#regexp1", {
                  disabled: review_mode || board_setup_mode,
                }),
                "Regular Expression",
              ),
              m("button#searchmove.ripple", "Search Moves"),
            ]),
            m("div#movefilters", [
              m("p#searchresultinfo", "Click <Search Moves> to search!"),
              m("hr#separatorsearchresult"),
              m(
                "p",
                "Note: Click <Search Moves> to find available moves with filter. Leave the search field blank to find all moves. Click <Make Move> to make selected move. Click <Highlight Move> to show the move on the board. If you are in analysis mode, the highlighted move can be replaced by recommended move (Blue) and threat move (Red) and you need to highlight it again.",
              ),
              m(
                "p",
                "Check <Regular Expression> to search with regular expression, e.g. /[a-z]+/g",
              ),
              m("hr#separatormoveselectiondialog"),
              m("p", "Additional Search Restrictions:"),
              m("input[type=text]#origfilter", {
                placeholder:
                  "Original Square... (e.g. e2, leave empty to search all, useless for drops)",
                maxlength: 9999,
              }),
              m("input[type=text]#destfilter", {
                placeholder:
                  "Destination Square... (e.g. e4, leave empty to search all, effective on drops)",
                maxlength: 9999,
              }),
              m(
                "label#label-isdrop",
                m("input[type=checkbox]#isdrop", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include drops",
              ),
              m(
                "label#label-haswallgating",
                m("input[type=checkbox]#haswallgating", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include moves having wall gating",
              ),
              m(
                "label#label-haspiecechange",
                m("input[type=checkbox]#haspiecechange", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include moves having promotion/demotion or seirawan gating",
              ),
              m("button#makemove.ripple", "Make Move"),
              m("button#highlightmove.ripple", "Highlight Move (Yellow Marks)"),
            ]),
          ]),
          m("div#chessground-mini", [
            m("div#chessground-mini-board-operation-div", [
              m(
                "button#lockminiboard.operationdivbutton",
                {
                  title:
                    "Status: Unlocked\nWhen locked, the mini board will not be closed if somewhere else is clicked.",
                  onclick: () => {
                    const chessgroundmini =
                      document.getElementById("chessground-mini");
                    if (chessgroundmini.locked) {
                      chessgroundmini.locked = false;
                      chessgroundmini.classList.remove("locked");
                      document.getElementById("lockminiboard").title =
                        "Status: Unlocked\nWhen locked, the mini board will not be closed if somewhere else is clicked.";
                    } else {
                      chessgroundmini.locked = true;
                      chessgroundmini.classList.add("locked");
                      document.getElementById("lockminiboard").title =
                        "Status: Locked\nWhen locked, the mini board will not be closed if somewhere else is clicked.";
                    }
                  },
                },
                "",
              ),
              m(
                "button#pinminiboard.operationdivbutton",
                {
                  title:
                    "Status: Placed On Document\nWhen placed on document, the mini board will move with the webpage when you scroll.\nWhen pinned to window, the mini board will not move when you scroll.",
                  onclick: () => {
                    const maindiv = document.getElementsByTagName("main")[0];
                    const chessgroundmini =
                      document.getElementById("chessground-mini");
                    const maindivrect = maindiv.getBoundingClientRect();
                    const chessgroundminirect =
                      chessgroundmini.getBoundingClientRect();
                    const chessgroundminiboardwrapper = document.getElementById(
                      "chessground-mini-board-wrapper-div",
                    );
                    if (chessgroundmini.pinned) {
                      chessgroundmini.pinned = false;
                      chessgroundmini.classList.remove("pinned");
                      document.getElementById("pinminiboard").title =
                        "Status: Placed On Document\nWhen placed on document, the mini board will move with the webpage when you scroll.\nWhen pinned to window, the mini board will not move when you scroll.";
                      chessgroundmini.style.left = `${chessgroundminirect.left - maindivrect.left}px`;
                      chessgroundmini.style.top = `${chessgroundminirect.top - maindivrect.top}px`;
                      chessgroundmini.style.position = "";
                    } else {
                      chessgroundmini.pinned = true;
                      chessgroundmini.classList.add("pinned");
                      document.getElementById("pinminiboard").title =
                        "Status: Pinned To Window\nWhen placed on document, the mini board will move with the webpage when you scroll.\nWhen pinned to window, the mini board will not move when you scroll.";
                      chessgroundmini.style.left = `${chessgroundminirect.left}px`;
                      chessgroundmini.style.top = `${chessgroundminirect.top}px`;
                      chessgroundmini.style.position = "fixed";
                    }
                  },
                },
                "",
              ),
              m(
                "button#setpositiontomainboard.operationdivbutton",
                {
                  title:
                    "Click to move the position on mini board to main board for further investigation.",
                  onclick: () => {
                    const chessgroundmini =
                      document.getElementById("chessground-mini");
                    const fen = document.getElementById("fen");
                    const move = document.getElementById("move");
                    if (chessgroundmini.startingfen == undefined) {
                      fen.value = "";
                    } else {
                      fen.value = chessgroundmini.startingfen;
                    }
                    if (chessgroundmini.moves == undefined) {
                      move.value = "";
                    } else {
                      move.value = chessgroundmini.moves;
                    }
                    document.getElementById("setpos").click();
                  },
                },
                "",
              ),
              m(
                "button#closeminiboard.operationdivbutton",
                {
                  title: "Click to close mini board.",
                  onclick: () => {
                    document.getElementById("chessground-mini").style.display =
                      "none";
                  },
                },
                "",
              ),
            ]),
            m("div#chessground-mini-board-wrapper-div", [
              m(
                "div#chessground-mini-container-div.defaultboard.default.board8x8",
                [
                  m("div.cg-wrap.pocket-top.movemode", [
                    m("div#pocket-top-mini"),
                  ]),
                  m("div#chessground-board-mini.micro"),
                  m("div.cg-wrap.pocket-bottom.movemode", [
                    m("div#pocket-bottom-mini"),
                  ]),
                ],
              ),
            ]),
          ]),
          m("div#boardsetuppieceidentifier", [
            m("div#fakeboard.defaultboard.default.board8x8", [
              m("div#fakewrap.cg-wrap.orientation-white", [
                m("piece#fakepiece"),
              ]),
            ]),
          ]),
        ]);
      };

      return { oninit, view };
    };

    if (!isSupported()) {
      window.alert(
        "Your browser is not supported. For more information, please take a look at https://github.com/hi-ogawa/Stockfish/wiki.",
      );
    } else {
      m.mount($("#root"), App);
    }
  </script>
</body>
