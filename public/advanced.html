<!doctype html>
<head>
  <meta charset="utf-8" />
  <title>Fairy-Stockfish playground</title>
  <!-- By curl https://data-url-maker-hiro18181.netlify.app/api/url/https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg -->
  <link
    rel="icon"
    href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+CiAgPGcgc3R5bGU9Im9wYWNpdHk6MTsgZmlsbDpub25lOyBmaWxsLW9wYWNpdHk6MTsgZmlsbC1ydWxlOmV2ZW5vZGQ7IHN0cm9rZTojMDAwMDAwOyBzdHJva2Utd2lkdGg6MS41OyBzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDsgc3Ryb2tlLWRhc2hhcnJheTpub25lOyBzdHJva2Utb3BhY2l0eToxOyI+CiAgICA8cGF0aAogICAgICBkPSJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4IgogICAgICBzdHlsZT0iZmlsbDojMDAwMDAwOyBzdHJva2U6IzAwMDAwMDsiIC8+CiAgICA8cGF0aAogICAgICBkPSJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMCIKICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDsgc3Ryb2tlOiMwMDAwMDA7IiAvPgogICAgPHBhdGgKICAgICAgZD0iTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHoiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHoiCiAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MykiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogIgogICAgICBzdHlsZT0iZmlsbDojZmZmZmZmOyBzdHJva2U6bm9uZTsiIC8+CiAgPC9nPgo8L3N2Zz4K"
  />
  <link rel="stylesheet" href="assets/chessground.css" />
  <link rel="stylesheet" href="assets/generated.css" />
  <link rel="stylesheet" href="assets/theme-backgrounds.css" />
  <link rel="stylesheet" href="assets/theme-default.css" />
  <base target="_blank" />
</head>

<!-- CSS -->

<style>
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0;
    font: inherit;
  }

  html,
  body,
  #root {
    height: 100%;
    transition-property: background-color, color;
    transition-duration: 0.5s, 0.2s;
    transition-timing-function: linear, linear;
    transition-delay: 0s;
  }

  #root {
    font-size: 16px;
  }

  main {
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }

  div {
    transition-property: background-color, color;
    transition-duration: 0.5s, 0.2s;
    transition-timing-function: linear, linear;
    transition-delay: 0s;
  }

  .backgroundimg {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-size: cover;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }

  .pagebackground {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: none;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: top left;
    z-index: -100;
  }

  input[type="checkbox"] {
    display: inline-block;
    height: 20px;
    width: 20px;
    border: 2px solid #ddd;
    overflow: hidden;
    vertical-align: middle;
    text-align: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    font: normal normal normal 14px/1 Arial;
    outline: 0;
    background: 0 0;
    background-color: white;
    margin-left: 5px;
  }

  input[type="checkbox"]:hover {
    color: #000;
    background-color: #ddd;
  }

  input[type="checkbox"]:checked {
    color: #fff;
    background-color: #000;
  }

  input[type="checkbox"]:hover:checked {
    color: #fff;
    background-color: #777;
  }

  input[type="checkbox"]:checked:after {
    content: "âœ”";
    font-size: 15px;
    text-align: center;
    line-height: 17px;
  }

  input[type="checkbox"]:disabled {
    color: #000;
    background-color: #aaa;
    opacity: 0.7;
  }

  input[type="checkbox"]:disabled:hover {
    color: #000;
    background-color: #aaa;
    opacity: 0.7;
  }

  #pagetitle {
    font-size: 40px;
    font-family: "Times New Roman", Times, serif, Arial;
    margin-bottom: 10px;
    font-style: oblique;
    font-weight: bold;
  }

  #input {
    display: flex;
    margin-bottom: 10px;
  }

  #input2 {
    display: flex;
    margin-bottom: 10px;
  }

  #input3 {
    display: flex;
    margin-bottom: 10px;
  }

  #gamesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #gamesettings button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #gamesettings button:hover {
    background: #aaa;
  }

  #gamesettings button:disabled {
    background: #ccc;
    color: #000;
  }

  #gamesettings button:active {
    background: #000;
  }

  #input #fen {
    width: 50%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input #move {
    width: 10%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #movetime {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #movetime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #depth {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #depth:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #nodes {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #nodes:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #threads {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #threads:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #hash {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #hash:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input2 #multipv {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #multipv:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #input button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #input button:hover {
    background: #aaa;
  }

  #input button:disabled {
    background: #ccc;
    color: #000;
  }

  #input button:active {
    background: #000;
  }

  #input2 button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #input2 button:hover {
    background: #aaa;
  }

  #input2 button:disabled {
    background: #ccc;
    color: #000;
  }

  #input2 button:active {
    background: #000;
  }

  #movecontrol button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    margin-top: 2px;
    cursor: pointer;
  }

  #movecontrol button:hover {
    background: #aaa;
  }

  #movecontrol button:disabled {
    background: #ccc;
    color: #000;
  }

  #movecontrol button:active {
    background: #000;
  }

  #movecontrol #gotomovenum {
    width: 45%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #movecontrol #gotomovenum:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #controls button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #controls button:hover {
    background: #aaa;
  }

  #controls button:disabled {
    background: #ccc;
    color: #000;
  }

  #controls button:active {
    background: #000;
  }

  #gamesettings #dropdown-quickpromotion {
    width: 120px;
    background: #eee;
    margin-left: 10px;
  }

  #gamesettings #dropdown-fogofwarsettings {
    width: 120px;
    background: #eee;
    margin-left: 10px;
  }

  #dropdown-boardtheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #dropdown-piecetheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #dropdown-uitheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #misc {
    margin-bottom: 10px;
  }

  #misc button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #misc button:hover {
    background: #aaa;
  }

  #misc button:disabled {
    background: #ccc;
    color: #000;
  }

  #misc button:active {
    background: #000;
  }

  #outputs {
    display: flex;
    flex: 1 1 auto;
    margin-top: 10px;
    width: 100%;
    height: 50%;
  }

  #movecontrol {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #binengineinput {
    margin-bottom: 5px;
  }

  #binengineinput button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #binengineinput button:hover {
    background: #aaa;
  }

  #binengineinput button:disabled {
    background: #ccc;
    color: #000;
  }

  #binengineinput button:active {
    background: #000;
  }

  #binengineinput input {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #binengineinput input:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #binengineinput #whiteenginesettings {
    display: flex;
  }

  #binengineinput #blackenginesettings {
    display: flex;
  }

  #binengineinput #analysisenginesettings {
    display: flex;
  }

  #posvariantdiv {
    display: flex;
    margin-bottom: 10px;
  }

  #posvariantdiv #dropdown-variant {
    width: 150px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-varianttype {
    width: 150px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-posvarianttype {
    min-width: 120px;
    max-width: 200px;
    background: #eee;
    margin-left: 5px;
  }

  #posvariantdiv #dropdown-posvariantname {
    min-width: 120px;
    max-width: 200px;
    background: #eee;
    margin-left: 5px;
    margin-right: 5px;
  }

  #posvariantdiv button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #posvariantdiv button:hover {
    background: #aaa;
  }

  #posvariantdiv button:disabled {
    background: #ccc;
    color: #000;
  }

  #posvariantdiv button:active {
    background: #000;
  }

  #controls {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #info {
    padding: 10px;
    margin-left: 10px;
    font-size: 16px;
    height: 600px;
  }

  #info #sannotation {
    background: #eee;
    margin-bottom: 10px;
  }

  #info #timecontrolduringplay {
    padding: 10px;
    margin-left: 20px;
    font-size: 16px;
  }

  #info #timecontrolduringplay button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #info #timecontrolduringplay button:hover {
    background: #aaa;
  }

  #info #timecontrolduringplay button:disabled {
    background: #ccc;
    color: #000;
  }

  #info #timecontrolduringplay button:active {
    background: #000;
  }

  #currentboardfen {
    height: 10%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #label-pgn {
    height: 20%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #output2 {
    height: 70%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #pocket-top {
    display: flex;
  }

  #pocket-bottom {
    display: flex;
  }

  #links a {
    margin: 20px;
    font-size: 20px;
    text-decoration: none;
  }

  #info #timers {
    width: 600px;
    height: 125px;
    border: 2px solid #eee;
    background-color: gray;
    overflow: hidden;
    margin-bottom: 5px;
  }

  #info #timers #whitetimer {
    float: left;
    width: 290px;
    height: 120px;
    border: 2px solid #000;
    color: black;
    background-color: white;
    text-align: center;
    overflow: hidden;
  }

  #info #timers #blacktimer {
    float: right;
    width: 290px;
    height: 120px;
    border: 2px solid #fff;
    color: white;
    background-color: black;
    text-align: center;
    overflow: hidden;
  }

  #info #enginecmddiv {
    display: flex;
    margin-bottom: 10px;
  }

  #info #enginecmddiv #enginecmd {
    width: 500px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #info #enginecmddiv button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #info #enginecmddiv button:hover {
    background: #aaa;
  }

  #info #enginecmddiv button:disabled {
    background: #ccc;
    color: #000;
  }

  #info #enginecmddiv button:active {
    background: #000;
  }

  #info #enginecmddiv #targetengine {
    width: 150px;
    background: #eee;
  }

  #blacktime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #whitetime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #boardsetupsettings {
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange {
    display: flex;
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange #dropdown-setpiece {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings #boardpiecechange button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #boardsetupsettings #boardpiecechange button:hover {
    background: #aaa;
  }

  #boardsetupsettings #boardpiecechange button:disabled {
    background: #ccc;
    color: #000;
  }

  #boardsetupsettings #boardpiecechange button:active {
    background: #000;
  }

  #boardsetupsettings2 {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #boardsetupsettings2 #dropdown-sidetomove {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings2 #halfmoveclock {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #halfmoveclock:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #whiteremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #whiteremainingchecks:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #blackremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #blackremainingchecks:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #currentmovenum {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #boardsetupsettings2 #currentmovenum:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #enpassantfile {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #enpassantfile:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #enpassantrank {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #boardsetupsettings2 #enpassantrank:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #boardsetupsettings2 #seirwangatingfiles {
    width: 60%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings {
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings #dropdown-whitetimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #whitetimesettings #whitestarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #whitetimesettings #whitestarttime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitetimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitetimegain:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomitime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #whitetimesettings #whitetimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitetimemargin:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #blacktimesettings #dropdown-blacktimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #blacktimesettings #blackstarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #blacktimesettings #blackstarttime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blacktimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blacktimegain:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomitime:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #blacktimesettings #blacktimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blacktimemargin:invalid {
    background: #ff9e9e;
    border: 3px solid #f00;
  }

  #advancedtimesettings #gamecontrol-start {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #gamecontrol-start #gamestart {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    font-size: 24px;
    margin-right: 6px;
    cursor: pointer;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:hover {
    background: #aaa;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:disabled {
    background: #ccc;
    color: #000;
  }

  #advancedtimesettings #gamecontrol-start #gamestart:active {
    background: #000;
  }

  #evalbar {
    width: 400px;
    height: 30px;
    overflow: hidden;
    border-radius: 10px;
    border-color: grey;
    border-width: 2px;
    border-style: solid;
    background-color: black;
    position: relative;
  }

  #evalbar #evalbarprogress {
    float: left;
    height: 100%;
    width: 50%;
    background-color: white;
  }

  #evalbar #cp {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    color: orange;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 25px;
    font-weight: bold;
    font-family: Arial, "Times New Roman", Georgia, Serif;
  }

  #evalinfo {
    white-space: pre-line;
  }

  #pvinfo {
    white-space: pre-line;
  }

  evalnum {
    font-weight: 900;
    font-family: Arial, "Times New Roman", Georgia, Serif;
  }

  #timecontrolduringplay {
    margin-bottom: 5px;
  }

  #evaluation {
    margin-bottom: 10px;
  }

  spangameresult {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 10px;
    position: fixed;
    transition: 0.5s linear;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
    z-index: 1000;
  }

  #moveselectiondialog {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 700px;
    padding: 10px;
    background-color: #000000;
    color: #ffffff;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.6);
    z-index: 999;
  }

  #moveselectiondialog input[type="checkbox"] {
    border: 2px solid #ddd;
  }

  #moveselectiondialog button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    margin-bottom: 5px;
    cursor: pointer;
  }

  #moveselectiondialog button:hover {
    background: #aaa;
  }

  #moveselectiondialog button:disabled {
    background: #ccc;
    color: #000;
  }

  #moveselectiondialog button:active {
    background: #000;
  }

  #moveselectiondialog #moveslectdiv {
    display: flex;
    flex-direction: row;
  }

  #moveselectiondialog #movefilters {
    display: flex;
    flex-direction: column;
  }

  #moveselectiondialog #availablemovelist {
    width: 150px;
    background: #eee;
    margin-right: 5px;
  }

  #movesearchfilter {
    border: 1px solid #ddd;
    width: 150px;
  }

  #separatormoveselectiondialog {
    border: dashed #ffffff;
  }

  #separatorsearchresult {
    border: double #ffffff;
  }

  #fsfoutput {
    font-family: Consolas;
  }

  #whiteengineoutput {
    font-family: Consolas;
  }

  #whiteunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #blackengineoutput {
    font-family: Consolas;
  }

  #blackunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #analysisengineoutput {
    font-family: Consolas;
  }

  #analysisunsupportedvariant {
    color: red;
    font-weight: bold;
  }

  #enginesettingspopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginesettingspopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginesettingspopup button:hover {
    background: #aaa;
  }

  #enginesettingspopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginesettingspopup button:active {
    background: #000;
  }

  #enginesettingspopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesettingspopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesettingspopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginemanagementpopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginemanagementpopup button:hover {
    background: #aaa;
  }

  #enginemanagementpopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginemanagementpopup button:active {
    background: #000;
  }

  #enginemanagementpopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginemanagementpopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #enginesetuppopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #enginesetuppopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #enginesetuppopup button:hover {
    background: #aaa;
  }

  #enginesetuppopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #enginesetuppopup button:active {
    background: #000;
  }

  #enginesetuppopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
    min-width: 300px;
  }

  #enginesetuppopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
    min-width: 300px;
  }

  #enginesetuppopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup {
    display: none;
    position: fixed;
    top: 0%;
    left: 0%;
    width: 100%;
    height: 100%;
    z-index: 2;
    background-color: white;
    border-radius: 5px;
    overflow: scroll;
  }

  #loadsavedgamespopup button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    margin-top: 2px;
    margin-bottom: 2px;
    cursor: pointer;
  }

  #loadsavedgamespopup button:hover {
    background: #aaa;
  }

  #loadsavedgamespopup button:disabled {
    background: #ccc;
    color: #000;
  }

  #loadsavedgamespopup button:active {
    background: #000;
  }

  #loadsavedgamespopup input[type="text"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup input[type="number"] {
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    margin-left: 6px;
    margin-right: 6px;
  }

  #loadsavedgamespopup select {
    min-width: 120px;
    background: #eee;
    margin-left: 6px;
    margin-right: 6px;
  }

  #moveselectiondialog input {
    border: 1px solid #ddd;
  }
</style>

<body>
  <div id="root"></div>
  <div id="pagebackground" class="pagebackground"></div>
  <script>
    //Fairyground namespace for variable/function definition transfer
    window.fairyground = { super: window };
  </script>
  <script src="bundle.js" defer></script>

  <!--iframe src="./themes.html" onload="this.before((this.contentDocument.body || this.contentDocument).children[0]); this.remove();"--><!--/iframe-->

  <!-- Javascript -->

  <script src="./lib/stockfish.js"></script>
  <script src="./lib/mithril.min.js"></script>
  <script src="./lib/BinaryEngineFeature.js"></script>
  <script src="./lib/SavedGamesParsingFeature.js"></script>
  <script>
    //For quick access (Shortening the name)
    var fge = window.fairyground.BinaryEngineFeature;
    var fgs = window.fairyground.SavedGamesParsingFeature;
    let themes = [[], [], []];
    let themenames = [[], []];
    let variantsettings = [[], [], [], [], []];
    let allvariants = [];
    let uithemes = [[], [], []];
    let currentuicss = null;
    let onpageload = false;
    let uithemesparsed = false;
    let previouschangeuitime = 0;
    const $ = (...args) => document.querySelector(...args);

    document.addEventListener("onpageload", () => {
      onpageload = true;
      if (uithemesparsed) {
        document.getElementById("setupuithemes").click();
      }
    });

    document.addEventListener("uithemesparsed", () => {
      uithemesparsed = true;
      if (onpageload) {
        document.getElementById("setupuithemes").click();
      }
    });

    //Remove duplicated elements
    function uniqArr(arr) {
      var newArr = new Set(arr);
      return Array.from(newArr);
    }

    //Throttle function, used to prevent lag when operating DOM objects.
    function Throttle(func, wait) {
      let timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(() => {
            func.apply(this, arguments);
            timer = null;
          }, wait);
          func.apply(this, arguments);
        }
      };
    }

    function OpenURL(url) {
      let link = document.createElement("a");
      link.href = url;
      link.id = "tmplink";
      link.target = "_blank";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function getFileFromServer(url, doneCallback, errorCallback) {
      if (
        typeof url != "string" ||
        typeof doneCallback != "function" ||
        (typeof errorCallback != "function" && errorCallback != undefined)
      ) {
        throw TypeError(
          "getFileFromServer(url:string, doneCallback:function(string), errorCallback:function(Error) | undefined)",
        );
      }
      fetch(url)
        .then((response) => {
          if (!response.ok) {
            throw new Error(
              `Network response error: Code ${response.status} (${response.statusText})`,
            );
          }
          return response.text();
        })
        .then((content) => {
          doneCallback(content);
        })
        .catch((error) => {
          console.error(
            `There has been a problem when fetching "${url}":`,
            error,
          );
          if (typeof errorCallback == "function") {
            errorCallback(error);
          }
        });
    }

    function setVariantStylesheet(variant) {
      document.getElementById("current-variant-stylesheet").href =
        `./assets/theme-variant-${variant}.css`;
    }

    function LinearTransition(
      start,
      end,
      step,
      interval,
      operation,
      doneCallBack,
    ) {
      if (
        typeof start != "number" ||
        typeof end != "number" ||
        typeof step != "number" ||
        typeof interval != "number" ||
        typeof operation != "function" ||
        typeof doneCallBack != "function"
      ) {
        throw TypeError(
          "FadeInOut(start:number, end:number, step:number, interval:number, operation:function(number), doneCallBack:function())",
        );
      }
      let i = start;
      const operate = () => {
        operation(i);
        if ((step > 0 && i >= end) || (step < 0 && i <= end)) {
          doneCallBack();
        } else {
          setTimeout(operate, interval);
        }
        i += step;
      };
      setTimeout(operate, interval);
    }

    const copyText = async (val) => {
      if (navigator.clipboard && navigator.permissions) {
        await navigator.clipboard.writeText(val);
      } else {
        const textArea = document.createElement("textArea");
        textArea.value = val;
        textArea.style.width = 0;
        textArea.style.position = "fixed";
        textArea.style.left = "-999px";
        textArea.style.top = "10px";
        textArea.setAttribute("readonly", "readonly");
        document.body.appendChild(textArea);

        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
      }
    };

    const formatMB = (n) => {
      return (n ? (n / 1e6).toPrecision(3) : "?") + "MB";
    };

    const isSupported = () => {
      if (typeof WebAssembly !== "object") return false;
      const source = Uint8Array.from([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 7, 8,
        1, 4, 116, 101, 115, 116, 0, 0, 10, 15, 1, 13, 0, 65, 0, 253, 17, 65, 0,
        253, 17, 253, 186, 1, 11,
      ]);
      if (
        typeof WebAssembly.validate !== "function" ||
        !WebAssembly.validate(source)
      )
        return false;
      if (typeof Atomics !== "object") return false;
      if (typeof SharedArrayBuffer !== "function") {
        console.log("SharedArrayBuffer not enabled!");
        return false;
      }
      if (typeof FileReader === "undefined") {
        return false;
      }
      if (typeof WebSocket === "undefined") {
        return false;
      }
      return true;
    };

    const RequestProgress = ({ attrs: { url, onFinishDownload } }) => {
      let state = "INIT"; // 'LOADING', 'DONE', 'FAILED'
      let loaded = 0;
      let total = 0;

      const oninit = () => {
        state = "LOADING";
        m.request({
          url: url,
          method: "GET",
          responseType: "arraybuffer",
          headers: { Accept: "*/*" },
          config: (xhr) => {
            xhr.onprogress = (e) => {
              // TODO:
              // When gzip compressed, the value of "loaded/total" gets messed up.
              // On Chrome, "loaded" is the value after decompression, but on the other hand,
              // On Firefox, "loaded" is the value before decompression.
              loaded = e.loaded;
              total =
                e.total ||
                Number(
                  e.target.getResponseHeader("x-decompressed-content-length"),
                );
              m.redraw();
            };
          },
        }).then(
          (response) => {
            state = "DONE";
            onFinishDownload(response);
          },
          (e) => {
            console.error(e);
            state = "FAILED";
            onFinishDownload(null);
          },
        );
      };

      const view = () => {
        const fraction =
          total == -1 ? `?MB/?MB` : `${formatMB(loaded)}/${formatMB(total)}`;
        return m("span", [
          `${fraction} [${state}] `,
          m(
            "span",
            {
              style: "cursor: pointer;",
              onclick: () =>
                window.alert(
                  "On some browsers, download size might look contradictory due to file compression.",
                ),
            },
            "[?]",
          ),
        ]);
      };

      return { oninit, view };
    };

    const LoadVariantSettings = (side, clientdata) => {
      function StartLoad(data) {
        if (typeof data == "string") {
          let rawText = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n");
          let i = 0;
          let variantdescriptionitem = [];
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            variantdescriptionitem = rawText[i].split("|");
            if (variantdescriptionitem.length != 5) {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Syntax error.`,
              );
              continue;
            }
            if (variantsettings[0].includes(variantdescriptionitem[0])) {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant ${variantdescriptionitem[0]} already exists.`,
              );
              continue;
            }
            if (variantdescriptionitem[0] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant ID must not be null.`,
              );
              continue;
            }
            if (variantdescriptionitem[1] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant type must not be null.`,
              );
              continue;
            }
            if (variantdescriptionitem[2] == "") {
              console.warn(
                `At line ${i + 1} in variantsettings.txt: Variant name must not be null.`,
              );
              continue;
            }
            variantsettings[0].push(variantdescriptionitem[0]);
            variantsettings[1].push(variantdescriptionitem[1]);
            variantsettings[2].push(variantdescriptionitem[2]);
            variantsettings[3].push(variantdescriptionitem[3]);
            variantsettings[4].push(variantdescriptionitem[4]);
          }
          //console.log(variantsettings);
        } else {
          console.error(
            `Bad data type from variantsettings.txt: ${typeof data}`,
          );
        }
      }
      if (side == "server") {
        this.getFileFromServer("./variantsettings.txt", (res) => {
          console.log("res3:", res);
          StartLoad(res);
        });
      } else if (side == "client") {
        StartLoad(clientdata);
      }
    };

    const LoadThemes = () => {
      themes = [[], [], []];
      themenames = [[], []];
      function StartLoad(data, namedata) {
        if (typeof data == "string") {
          data = data.replace(/\r\n/g, "\n");
          data = data.replace(/\r/g, "\n");
          let rawText = data.split("\n");
          console.log("theme data:", rawText);
          let i = 0;
          let j = 0;
          let css_name = "";
          let index = 0;
          let require_list = [];
          let themesettings = [];
          let apply_to_all_list = [];
          let loaded_css_list = [];
          let require_board_list = [];
          let board_apply_to_all_list = [];
          let themeavailable = [];
          let boardthemeavailable = [];
          let link = null;
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 3) {
              console.warn(`At line ${i + 1} in themes.txt: Bad syntax\n`);
              continue;
            }
            themeavailable = themesettings[1].split(",");
            boardthemeavailable = themesettings[2].split(",");
            if (themeavailable.length == 1 && themeavailable[0] == "") {
              themeavailable = [];
            }
            if (
              boardthemeavailable.length == 1 &&
              boardthemeavailable[0] == ""
            ) {
              boardthemeavailable = [];
            }
            if (
              (themesettings[1].length < 1 && themesettings[2].length < 1) ||
              themeavailable.includes("") ||
              boardthemeavailable.includes("")
            ) {
              console.warn(
                `At line ${i + 1} in themes.txt: Piece and Board style names must not be both null or contain null element\n`,
              );
              continue;
            }
            if (themesettings[1].length > 0) {
              require_list = themeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              themeavailable = themeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_list.length; j++) {
                if (themes[0].includes(require_list[j].substring(1))) {
                  index = themes[0].indexOf(require_list[j].substring(1));
                  themeavailable = themeavailable.concat(themes[1][index]);
                } else {
                  console.warn(
                    `At line ${i + 1} in themes.txt: Variant ${require_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              themeavailable = uniqArr(themeavailable);
            }
            if (themesettings[2].length > 0) {
              require_board_list = boardthemeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              boardthemeavailable = boardthemeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_board_list.length; j++) {
                if (themes[0].includes(require_board_list[j].substring(1))) {
                  index = themes[0].indexOf(require_board_list[j].substring(1));
                  boardthemeavailable = boardthemeavailable.concat(
                    themes[2][index],
                  );
                } else {
                  console.warn(
                    `At line ${i + 1} in themes.txt: Variant ${require_board_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              boardthemeavailable = uniqArr(boardthemeavailable);
            }
            if (themesettings[0] == "*") {
              if (themesettings[1].length > 0) {
                apply_to_all_list = apply_to_all_list.concat(themeavailable);
              }
              if (themesettings[2].length > 0) {
                board_apply_to_all_list =
                  board_apply_to_all_list.concat(boardthemeavailable);
              }
            } else if (themes[0].includes(themesettings[0])) {
              if (themesettings[1].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[1][index] = uniqArr(
                  themes[1][index].concat(themeavailable),
                );
              }
              if (themesettings[2].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[2][index] = uniqArr(
                  themes[2][index].concat(boardthemeavailable),
                );
              }
            } else {
              themeavailable = uniqArr(
                themeavailable.concat(apply_to_all_list),
              );
              boardthemeavailable = uniqArr(
                boardthemeavailable.concat(board_apply_to_all_list),
              );
              themes[0].push(themesettings[0]);
              themes[1].push(themeavailable);
              themes[2].push(boardthemeavailable);
            }
          }
          for (i = 0; i < themes[0].length; i++) {
            for (j = 0; j < themes[1][i].length; j++) {
              css_name = "theme-piece-" + themes[1][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
            for (j = 0; j < themes[2][i].length; j++) {
              css_name = "theme-board-" + themes[2][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
          }

          // Needs to be after piece and board stylesheets to override them.
          css_name = "theme-variant-";
          if (!loaded_css_list.includes(css_name)) {
            loaded_css_list.push(css_name);
            link = document.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("href", "./assets/" + css_name + ".css");
            link.setAttribute("id", "current-variant-stylesheet");
            document.head.appendChild(link);
          }

          console.log(themes);
        } else {
          console.error(`Bad data type from themes.txt: ${typeof data}`);
        }

        if (typeof namedata == "string") {
          namedata = namedata.replace(/\r\n/g, "\n");
          namedata = namedata.replace(/\r/g, "\n");
          rawText = namedata.split("\n");
          console.log("theme name:", rawText);
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 2) {
              console.warn(`At line ${i + 1} in themename.txt: Bad syntax\n`);
              continue;
            }
            themenames[0].push(themesettings[0]);
            themenames[1].push(themesettings[1]);
          }

          console.log(themenames);
        } else {
          console.error(`Bad data type from themename.txt: ${typeof namedata}`);
        }
      }
      this.getFileFromServer("./themes.txt", (res) => {
        console.log("res:", res);
        this.getFileFromServer(
          "./themenames.txt",
          (res2) => {
            console.log("res2:", res2);
            StartLoad(res, res2);
          },
          () => {
            console.warn("themes.txt load failed.");
            this.getFileFromServer("./themenames.txt", (res2) => {
              console.log("res2:", res2);
              StartLoad("", res2);
            });
          },
        );
      });
    };

    const LoadUIThemes = () => {
      let received = 0;
      let totalreceives = 0;
      function ClearInvalid() {
        let i = 0;
        for (i = 0; i < uithemes[0].length; i++) {
          if (uithemes[2][i] == undefined) {
            uithemes[0].splice(i, 1);
            uithemes[1].splice(i, 1);
            uithemes[2].splice(i, 1);
            i--;
          }
        }
      }
      function StartLoad(data) {
        if (typeof data == "string") {
          let i = 0;
          let rawText = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n");
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i] == "" || rawText[i].startsWith("#")) {
              continue;
            }
            let uithemesettings = rawText[i].split("|");
            if (uithemesettings.length != 2) {
              console.warn(`At line ${i + 1} in uithemes.txt: Bad syntax\n`);
              continue;
            }
            if (uithemesettings[0] == "" || uithemesettings[1] == "") {
              console.warn(
                `At line ${i + 1} in uithemes.txt: ID and display name must not be empty.\n`,
              );
              continue;
            }
            if (uithemes[0].indexOf(uithemesettings[0]) > -1) {
              console.warn(
                `At line ${i + 1} in uithemes.txt: Theme ${uithemesettings[0]} already exists.\n`,
              );
              continue;
            }
            uithemes[0].push(uithemesettings[0]);
            uithemes[1].push(uithemesettings[1]);
            uithemes[2].push(undefined);
          }
          totalreceives = uithemes[0].length;
          for (i = 0; i < uithemes[0].length; i++) {
            (function (index) {
              getFileFromServer(
                `./assets/theme-ui-${uithemes[0][index]}.css`,
                (res) => {
                  uithemes[2][index] = document.createElement("style");
                  uithemes[2][index].style = "text/css";
                  uithemes[2][index].appendChild(document.createTextNode(res));
                  received++;
                  if (received >= totalreceives) {
                    ClearInvalid();
                    document.dispatchEvent(new Event("uithemesparsed"));
                  }
                },
                () => {
                  console.error(
                    `UI theme CSS ${uithemes[0][index]} fetch failed. This theme will not load.`,
                  );
                  received++;
                  if (received >= totalreceives) {
                    ClearInvalid();
                    document.dispatchEvent(new Event("uithemesparsed"));
                  }
                },
              );
            })(i);
          }
        } else {
          console.error(`Bad data type from uithemes.txt: ${typeof data}`);
        }
      }
      getFileFromServer(
        "./uithemes.txt",
        (res) => {
          StartLoad(res);
        },
        () => {
          console.error(
            "Failed to load uithemes.txt. UI themes are not available.",
          );
        },
      );
    };

    function getThemeName(themeid) {
      if (typeof themeid != "string") {
        return null;
      }
      let index = themenames[0].indexOf(themeid);
      if (index < 0) {
        return themeid + " âš ";
      } else {
        return themenames[1][index];
      }
    }

    function getVariantType(variant) {
      if (typeof variant != "string") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        return "<|NC|>";
      } else {
        return variantsettings[1][index];
      }
    }

    function getVariantName(variant, useplaceholder, showid) {
      if (
        typeof variant != "string" ||
        typeof useplaceholder != "boolean" ||
        typeof showid != "boolean"
      ) {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return variant;
        } else {
          return undefined;
        }
      } else {
        if (showid) {
          return variantsettings[2][index] + ` (${variant})`;
        } else {
          return variantsettings[2][index];
        }
      }
    }

    function getVariantDescription(variant, useplaceholder) {
      if (typeof variant != "string" || typeof useplaceholder != "boolean") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return variant;
        } else {
          return undefined;
        }
      } else {
        return variantsettings[3][index];
      }
    }

    function getVariantWikiPageURL(variant, useplaceholder) {
      if (typeof variant != "string" || typeof useplaceholder != "boolean") {
        return null;
      }
      let index = variantsettings[0].indexOf(variant);
      if (index < 0) {
        if (useplaceholder) {
          return "";
        } else {
          return undefined;
        }
      } else {
        return variantsettings[4][index];
      }
    }

    const App = () => {
      let stockfish = null;
      let stockfish_state = "INIT"; // 'READY', 'FAILED'
      let output2 = "";
      let first_engine_output = "";
      let second_engine_output = "";
      let analysis_engine_output = "";
      let show_dests = true;
      let adjudicate = true;
      let analysis_mode = false;
      let play_white = false;
      let play_black = false;
      let play_move = false;
      let review_mode = false;
      let board_setup_mode = false;
      let advanced_time_control = false;
      let during_play = false;
      let select_move_dialog = false;
      let in_browser_fsf_hash = 16;
      let random_mover_white = false;
      let random_mover_black = false;
      let white_start_time = 0;
      let black_start_time = 0;
      let white_remaining_time = 0;
      let black_remaining_time = 0;
      let white_moving_time_list = [];
      let black_moving_time_list = [];
      let white_time_gain = 0;
      let black_time_gain = 0;
      let white_timer_type = "infinite";
      let black_timer_type = "infinite";
      let timer_interval = 100;
      let white_byoyomi_time_per_period = 0;
      let black_byoyomi_time_per_period = 0;
      let white_byoyomi_period_count = 0;
      let black_byoyomi_period_count = 0;
      let white_remaining_byoyomi_periods = 0;
      let black_remaining_byoyomi_periods = 0;
      let white_time_margin = 0;
      let black_time_margin = 0;
      let timeout_margin = 500;
      let previous_mover = "";
      let move_finish_timer_updating = false;
      let changing_variant_type = false;
      let clear_log = true;
      let game_list = [];
      let throttle_threshold = 400; //in milliseconds, increase this if the GUI lags
      let timer;

      let variants = [];
      let varianttypes = [];

      let engine_list = [];

      const checkconnectionnumber = parseInt(Math.random() * 100000);
      let wsport = window.location.port;
      if (wsport == "") {
        wsport = 5001;
      } else {
        wsport = +wsport + 1;
      }

      const connectToWebSocketServer = (port, callbackfn) => {
        let i = 0;
        for (i = 0; i < fge.WebSocketReconnectionTime; i++) {
          try {
            fge.WebSocketStatus = "CONNECTING";
            fge.ws = new WebSocket("ws://localhost:" + port.toString());

            fge.ws.addEventListener("open", function (event) {
              fge.ws.send(`CONNECT\x10${checkconnectionnumber}`);
            });

            fge.ws.addEventListener("message", function (event) {
              if (typeof event.data != "string") {
                console.error(
                  `%c WebSocket %c ERROR %c Received bad data type from server: ${typeof event.data}`,
                  "color: #fff; background: #5f5f5f",
                  "color: #fff; background: #f03a17",
                  "",
                );
                fge.ws.close();
                fge.WebSocketStatus = "ERROR";
                const binenginediv = document.getElementById("binengineinput");
                if (binenginediv) {
                  binenginediv.style.display = "none";
                }
                fge.first_engine = null;
                fge.second_engine = null;
                fge.analysis_engine = null;
                return;
              }
              let msg = event.data.split("|");
              if (fge.WebSocketStatus == "CONNECTING") {
                if (event.data == `${checkconnectionnumber}`) {
                  console.log(
                    `%c WebSocket %c CONNECTED %c WebSocket connection established.`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                  fge.WebSocketStatus = "CONNECTED";
                  fge.ws.send("READYOK");
                  const binenginediv =
                    document.getElementById("binengineinput");
                  if (binenginediv) {
                    binenginediv.hidden = false;
                    binenginediv.style.display = "";
                  }
                } else {
                  console.error(
                    `%c WebSocket %c ERROR %c WebSocket Server connection failed: Server returns bad verification code.`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #f03a17",
                    "",
                  );
                  fge.ws.close();
                  fge.WebSocketStatus = "ERROR";
                  const binenginediv =
                    document.getElementById("binengineinput");
                  if (binenginediv) {
                    binenginediv.style.display = "none";
                  }
                  fge.first_engine = null;
                  fge.second_engine = null;
                  fge.analysis_engine = null;
                }
              } else if (fge.WebSocketStatus == "CONNECTED") {
                if (msg[0] == "UPDATE_DATA") {
                  fge.GetEngineList((data) => {
                    engine_list = data;
                  }, fge.ws);
                  console.log(engine_list);
                }
              }
            });

            fge.ws.addEventListener("close", function (event) {
              let { code, reason, wasClen } = event;
              if (fge.WebSocketStatus == "ERROR") {
                return;
              }
              console.error(
                `%c WebSocket %c CLOSED %c WebSocket Connection Closed.`,
                "color: #fff; background: #5f5f5f",
                "color: #fff; background: #f03a17",
                "",
              );
              console.error(event);
              fge.WebSocketStatus = "CLOSED";
              const binenginediv = document.getElementById("binengineinput");
              if (binenginediv) {
                binenginediv.style.display = "none";
              }
              fge.first_engine = null;
              fge.second_engine = null;
              fge.analysis_engine = null;
              window.alert(
                "WebSocket connection has closed. You will be unable to use binary engines. Try reloading this page to fix this.",
              );
            });

            fge.ws.addEventListener("error", function (event) {
              fge.WebSocketStatus = "ERROR";
              console.error(
                `%c WebSocket %c ERROR %c Errors occurred during establishing WebSocket connection.`,
                "color: #fff; background: #5f5f5f",
                "color: #fff; background: #f03a17",
                "",
              );
              console.error(event);
              const binenginediv = document.getElementById("binengineinput");
              if (binenginediv) {
                binenginediv.style.display = "none";
              }
              fge.first_engine = null;
              fge.second_engine = null;
              fge.analysis_engine = null;
              window.alert(
                `Errors occurred in WebSocket connection ws://localhost:${port}`,
              );
            });

            break;
          } catch {
            console.warn(
              `%c WebSocket %c WARNING %c Cannot initiate WebSocket connection. Retrying... (${i + 1}/${fge.WebSocketReconnectionTime})`,
              "color: #fff; background: #5f5f5f",
              "color: #fff; background: #ffc83d",
              "",
            );
            continue;
          }
        }
        if (i == fge.WebSocketReconnectionTime) {
          console.error(
            `%c WebSocket %c ERROR %c Cannot initiate WebSocket connection. Binary engine loading feature will be disabled.`,
            "color: #fff; background: #5f5f5f",
            "color: #fff; background: #f03a17",
            "",
          );
          fge.WebSocketStatus = "ERROR";
          window.alert(
            `Cannot initiate WebSocket connection to ws://localhost:${port}. Binary engine loading feature will be disabled.`,
          );
          const binenginediv = document.getElementById("binengineinput");
          if (binenginediv) {
            binenginediv.style.display = "none";
          }
          fge.first_engine = null;
          fge.second_engine = null;
          fge.analysis_engine = null;
        }
      };

      if (window.location.hostname == "localhost") {
        connectToWebSocketServer(wsport);
      } else {
        console.log(
          `%c WebSocket %c PENDING %c Cannot automatically initiate WebSocket connection in online versions. Waiting user action...`,
          "color: #fff; background: #5f5f5f",
          "color: #fff; background: #3f48cc",
          "",
        );
        fge.ws = null;
        fge.WebSocketStatus = "Unestablished";
        const binenginediv = document.getElementById("binengineinput");
        if (binenginediv) {
          binenginediv.style.display = "none";
        }
        fge.first_engine = null;
        fge.second_engine = null;
        fge.analysis_engine = null;
      }

      const getVariants = () => {
        stockfish.postMessage(`uci`);
      };

      const setVariant = () => {
        play_move = false;
        stop(true);
        const variant = $("#dropdown-variant").value;
        stockfish.postMessage(`ucinewgame`);
        if (variant == "") {
          stockfish.postMessage(`setoption name UCI_Variant value chess`);
        } else {
          stockfish.postMessage(`setoption name UCI_Variant value ${variant}`);
        }
        stockfish.postMessage(`position startpos`);
        if (fge.WebSocketStatus == "CONNECTED") {
          if (fge.first_engine) {
            if (fge.first_engine.SetVariant(variant)) {
              document.getElementById("whiteunsupportedvariant").hidden = true;
            } else {
              document.getElementById("whiteunsupportedvariant").hidden = false;
            }
          }
          if (fge.second_engine) {
            if (fge.second_engine.SetVariant(variant)) {
              document.getElementById("blackunsupportedvariant").hidden = true;
            } else {
              document.getElementById("blackunsupportedvariant").hidden = false;
            }
          }
          if (fge.analysis_engine) {
            if (fge.analysis_engine.SetVariant(variant)) {
              document.getElementById("analysisunsupportedvariant").hidden =
                true;
            } else {
              document.getElementById("analysisunsupportedvariant").hidden =
                false;
            }
          }
        }
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();

        setVariantStylesheet(variant);
      };

      const setFen = (
        interrupt_ponder,
        automatically_start_engine_thinking,
      ) => {
        stop(interrupt_ponder);
        const fen = $("#fen").value.trim();
        const moves = $("#move").value.trim();

        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${moves}`);
        }
        const stm = $("#label-stm").innerText;
        if (fge.WebSocketStatus == "CONNECTED") {
          if (fge.analysis_engine) {
            fge.analysis_engine.SetPosition(
              fen,
              moves,
              fge.GetBoardWidth(),
              fge.GetBoardHeight(),
            );
          }
          if (
            interrupt_ponder ||
            !advanced_time_control ||
            (advanced_time_control && !during_play)
          ) {
            if (fge.first_engine) {
              fge.first_engine.SetPosition(
                fen,
                moves,
                fge.GetBoardWidth(),
                fge.GetBoardHeight(),
              );
            }
            if (fge.second_engine) {
              fge.second_engine.SetPosition(
                fen,
                moves,
                fge.GetBoardWidth(),
                fge.GetBoardHeight(),
              );
            }
          } else {
            if (stm == "white") {
              if (fge.first_engine) {
                if (fge.first_engine.Ponder && advanced_time_control) {
                  if (
                    fge.first_engine.PonderMove != "0000" &&
                    fge.first_engine.PonderMove !=
                      $("#move").value.trim().split(" ").at(-1)
                  ) {
                    fge.first_engine.SetPonderMiss();
                    fge.first_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                    console.log(
                      `%c Ponder %c MISS %c WHITE Ponder misses`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #f03a17",
                      "",
                    );
                  } else if (fge.first_engine.PonderMove == "0000") {
                    fge.first_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                  }
                } else {
                  fge.first_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
              if (fge.second_engine) {
                if (
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove != "0000" &&
                  advanced_time_control
                ) {
                  fge.second_engine.SetPosition(
                    fen,
                    moves + ` ${fge.second_engine.PonderMove}`,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                } else {
                  if (fge.second_engine.Ponder && fge.second_engine.IsUsing) {
                    console.log(
                      `%c Ponder %c WARNING %c BLACK makes no ponder move but Ponder=true`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #ffc83d",
                      "",
                    );
                  }
                  fge.second_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
            } else if (stm == "black") {
              if (fge.second_engine) {
                if (fge.second_engine.Ponder && advanced_time_control) {
                  if (
                    fge.second_engine.PonderMove != "0000" &&
                    fge.second_engine.PonderMove !=
                      $("#move").value.trim().split(" ").at(-1)
                  ) {
                    fge.second_engine.SetPonderMiss();
                    fge.second_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                    console.log(
                      `%c Ponder %c MISS %c BLACK Ponder misses`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #f03a17",
                      "",
                    );
                  } else if (fge.second_engine.PonderMove == "0000") {
                    fge.second_engine.SetPosition(
                      fen,
                      moves,
                      fge.GetBoardWidth(),
                      fge.GetBoardHeight(),
                    );
                  }
                } else {
                  fge.second_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
              if (fge.first_engine) {
                if (
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove != "0000" &&
                  advanced_time_control
                ) {
                  fge.first_engine.SetPosition(
                    fen,
                    moves + ` ${fge.first_engine.PonderMove}`,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                } else {
                  if (fge.first_engine.Ponder && fge.first_engine.IsUsing) {
                    console.log(
                      `%c Ponder %c WARNING %c WHITE makes no ponder move but Ponder=true`,
                      "color: #fff; background: #5f5f5f",
                      "color: #fff; background: #ffc83d",
                      "",
                    );
                  }
                  fge.first_engine.SetPosition(
                    fen,
                    moves,
                    fge.GetBoardWidth(),
                    fge.GetBoardHeight(),
                  );
                }
              }
            }
          }
        }
        updateTimerOnMove();

        if (
          automatically_start_engine_thinking &&
          stm != "undefined" &&
          ((play_white && stm == "white") ||
            (play_black && stm == "black") ||
            analysis_mode)
        ) {
          setTimeout(go(false, false), 10);
        } else if (automatically_start_engine_thinking) {
          if (fge.first_engine) {
            if (
              fge.first_engine.IsUsing &&
              fge.first_engine.Ponder &&
              stm != "undefined" &&
              play_white
            ) {
              setTimeout(go(true, false), 10);
            }
          }
          if (fge.second_engine) {
            if (
              fge.second_engine.IsUsing &&
              fge.second_engine.Ponder &&
              stm != "undefined" &&
              play_black
            ) {
              setTimeout(go(false, true), 10);
            }
          }
          if (
            (random_mover_white && !play_white && stm == "white") ||
            (random_mover_black && !play_black && stm == "black")
          ) {
            setTimeout(() => {
              if (random_mover_white || random_mover_black)
                document.getElementById("randommovergo").click();
            }, 200);
          }
        }
      };

      const sendCommandToEngine = () => {
        let cmd = $("#enginecmd")
          .value.split(" ")
          .filter(function (item) {
            return item != null && item != undefined && item != "";
          });
        if (cmd[0] == "quit") {
          window.alert(
            "Cannot send this command: Quitting engine will cause the engine to not work.",
          );
          return;
        }
        if (cmd[0] == "position") {
          window.alert(
            "Cannot send this command: Setting position will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "flip") {
          window.alert(
            "Cannot send this command: Flipping the side will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "go") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "stop") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ucinewgame") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ponderhit") {
          window.alert(
            "Cannot send this command: Engine ponder hit is only allowed to be sent by the GUI.",
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          cmd[2] == "VariantPath"
        ) {
          window.alert(
            'Cannot send this command: To select variants.ini, select the ini file by clicking the "Select File" button of variants.ini at the top of the page.',
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          (cmd[2] == "UCI_Variant" ||
            cmd[2] == "USI_Variant" ||
            cmd[2] == "UCCI_Variant")
        ) {
          window.alert(
            "Cannot send this command: To change the variant, select the items in the variants dropdown.",
          );
          return;
        }
        if (cmd[0] == "setoption" && cmd[1] == "name" && cmd[2] == "Ponder") {
          window.alert(
            "Cannot send this command: Setting this value manually does not make sense.",
          );
          return;
        }
        if (cmd[0] == "usi") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucci") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "xboard") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucicyclone") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "uci") {
          window.alert(
            "Cannot send this command: Change engine protocol in engine management UI. In browser Fairy-Stockfish only accepts UCI protocol.",
          );
          return;
        }
        const targetengine = document.getElementById("targetengine");
        if (targetengine[targetengine.selectedIndex].value == "WHITE") {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.first_engine) {
              fge.first_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("1st engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (targetengine[targetengine.selectedIndex].value == "BLACK") {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.second_engine) {
              fge.second_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("2nd engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (
          targetengine[targetengine.selectedIndex].value == "ANALYSIS"
        ) {
          if (fge.WebSocketStatus == "CONNECTED") {
            if (fge.analysis_engine) {
              fge.analysis_engine.PostMessage($("#enginecmd").value.trim());
            } else {
              window.alert("Analysis engine is not loaded.");
            }
          } else if (window.location.hostname != "localhost") {
            window.alert("This feature is only available in offline versions.");
          } else {
            window.alert(
              "Connection lost with the server. Try reloading the page.",
            );
          }
        } else if (
          targetengine[targetengine.selectedIndex].value == "DEFAULT"
        ) {
          stockfish.postMessage($("#enginecmd").value.trim());
        }
      };

      const totalMoveNumber = () => {
        let listlength = 0;
        let i = 0;
        moves_split = $("#move").value.split(" ");
        for (i = 0; i < moves_split.length; i++) {
          if (moves_split[i].length == 0) {
            continue;
          }
          listlength++;
        }
        return listlength;
      };

      const displayMove = (movenum, is_force_stop, interrupt_pondering) => {
        if (
          $("#displayready").value.length > 0 &&
          $("#displayready").value > 0
        ) {
          //$("#displayready").value = 0, displayMove() is ready
          return;
        }
        $("#displayready").value = 2; //2 = displayMove() working
        let i = 0;
        let j = 0;
        moves_split = $("#move").value.split(" ");
        if (movenum == -1) {
          if (is_force_stop) {
            force_stop();
          } else {
            stop(interrupt_pondering);
          }
          $("#displaymoves").value = $("#move").value;
          review_mode = false;
          $("#isreviewmode").value = 0;
        } else if (movenum > totalMoveNumber() || movenum < -1) {
          console.log(`${movenum} is out of range for move number.`);
          return;
        } else {
          if (is_force_stop) {
            force_stop();
          } else {
            stop(interrupt_pondering);
          }
          if ($("#showmovediv").checked) {
            $("#showmovediv").click();
          }
          review_mode = true;
          $("#isreviewmode").value = 1;
          $("#displaymoves").value = "";
          for (i = 0, j = 0; j < movenum; i++, j++) {
            if (moves_split[i].length == 0) {
              j--;
              continue;
            }
            $("#displaymoves").value = $("#displaymoves").value.concat(
              moves_split[i],
            );
            if (j < movenum - 1) {
              $("#displaymoves").value = $("#displaymoves").value.concat(" ");
            }
          }
        }
        const fen = $("#fen").value.trim();
        const display_moves = $("#displaymoves").value.trim();
        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${display_moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${display_moves}`);
        }
        if (fge.first_engine) {
          fge.first_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        if (fge.second_engine) {
          fge.second_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.SetPosition(
            fen,
            display_moves,
            fge.GetBoardWidth(),
            fge.GetBoardHeight(),
          );
        }
        //console.log(`${display_moves}`);
        $("#displayready").value = 1; //1 = updateChessBoardToPosition() working
      };

      const displayNextMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value < 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value >= totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value++;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const displayPreviousMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value <= 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value > totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value--;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const displayInitialPosition = () => {
        $("#gotomovenum").value = 0;
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove(0, true, true);
      };

      const displayCurrentPosition = () => {
        $("#gotomovenum").value = totalMoveNumber();
        console.log(`Current: ${!during_play}`);
        displayMove(-1, false, false);
      };

      const displaySpecifiedPosition = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#gotomovenum").value < 0) {
          $("#gotomovenum").value = 0;
        } else if ($("#gotomovenum").value > totalMoveNumber()) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true, true);
      };

      const reset = () => {
        review_mode = false;
        board_setup_mode = false;
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();
        stockfish.postMessage(`stop`);
        stockfish.postMessage(`ucinewgame`);
        if (fge.first_engine) {
          fge.first_engine.NewGame();
        }
        if (fge.second_engine) {
          fge.second_engine.NewGame();
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.NewGame();
        }
        play_move = false;
        setFen(true, false);
        $("#currentposition").click();
      };

      const undo = () => {
        if (review_mode || board_setup_mode) {
          return;
        }
        const moves = $("#move").value;
        $("#move").value = moves.substring(0, moves.lastIndexOf(" "));
        stockfish.postMessage(`stop`);
        stockfish.postMessage(`ucinewgame`);
        if (fge.first_engine) {
          fge.first_engine.NewGame();
        }
        if (fge.second_engine) {
          fge.second_engine.NewGame();
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.NewGame();
        }
        resetTimer();
        play_move = false;
        setFen(true, analysis_mode);
      };

      const go = (
        white_engine_ponder_and_human_black,
        black_engine_ponder_and_human_white,
      ) => {
        if (board_setup_mode) {
          return;
        }
        return_early = play_move;
        console.log(`return early: ${return_early}`);
        if (return_early) return; // avoid race condition
        let args = "";
        let wargs = "";
        let bargs = "";
        const movetime = $("#movetime").value;
        const depth = $("#depth").value;
        const nodes = $("#nodes").value;
        const threadnum = $("#threads").value;
        const hashsize = $("#hash").value;
        const multipleprincipalvariation = $("#multipv").value;
        const whiteengineoutput = document.getElementById("whiteengineoutput");
        const blackengineoutput = document.getElementById("blackengineoutput");
        const analysisengineoutput = document.getElementById(
          "analysisengineoutput",
        );
        let whitedepthv = parseInt($("#whitedepth").value);
        let whitemovetimev = parseInt($("#whitemovetime").value);
        let whitenodesv = parseInt($("#whitenodes").value);
        let blackdepthv = parseInt($("#blackdepth").value);
        let blackmovetimev = parseInt($("#blackmovetime").value);
        let blacknodesv = parseInt($("#blacknodes").value);
        let winf = false;
        let binf = false;
        let wtime = 0;
        let btime = 0;
        let winc = 0;
        let binc = 0;
        if (analysis_mode) {
          args += " infinite";
        } else if (advanced_time_control) {
          if (
            white_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "white"
          ) {
            args += "infinite";
            wargs += "infinite";
            winf = true;
            console.log("wtime infinite");
          } else if (
            black_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "black"
          ) {
            args += "infinite";
            bargs += "infinite";
            binf = true;
            console.log("btime infinite");
          }
          if (white_timer_type == "time per move") {
            wtime += +white_moving_time_list[0].remaining_time;
            winc += +white_moving_time_list[0].remaining_time;
          } else if (white_timer_type == "tournament") {
            wtime += +(+white_remaining_time);
            winc += +white_time_gain;
          } else if (white_timer_type == "hourglass") {
            //How to tell that it's hourglass to engine?
            wtime += +white_remaining_time;
          } else if (white_timer_type == "byoyomi") {
            wtime += +white_remaining_time;
            if (
              white_remaining_time < white_byoyomi_time_per_period &&
              white_remaining_byoyomi_periods > 0
            ) {
              winc += +white_byoyomi_time_per_period;
            }
            if (white_remaining_byoyomi_periods == white_byoyomi_period_count) {
              wtime += +white_byoyomi_time_per_period;
              winc = 0;
            }
          }
          if (black_timer_type == "time per move") {
            btime += +black_moving_time_list[0].remaining_time;
            binc += +black_moving_time_list[0].remaining_time;
          } else if (black_timer_type == "tournament") {
            btime += +(+black_remaining_time);
            binc = +black_time_gain;
          } else if (black_timer_type == "hourglass") {
            //How to tell that it's hourglass to engine?
            btime += +black_remaining_time;
          } else if (black_timer_type == "byoyomi") {
            btime += +black_remaining_time;
            if (
              black_remaining_time < black_byoyomi_time_per_period &&
              black_remaining_byoyomi_periods > 0
            ) {
              binc += +black_byoyomi_time_per_period;
            }
            if (black_remaining_byoyomi_periods == black_byoyomi_period_count) {
              btime += +black_byoyomi_time_per_period;
              binc = 0;
            }
          }
          console.log(
            `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`,
          );
          args += `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
          stockfish.postMessage(
            `setoption name Move Overhead value ${timer_interval}`,
          );
        } else {
          if (!analysis_mode && $("#depth").validity.valid && depth > 0) {
            args += ` depth ${depth}`;
          }
          if (!analysis_mode && $("#movetime").validity.valid && movetime > 0) {
            args += ` movetime ${movetime}`;
          }
          if (!analysis_mode && $("#nodes").validity.valid && nodes > 0) {
            args += ` nodes ${nodes}`;
          }
          if (!($("#whitedepth").validity.valid && whitedepthv > 0)) {
            whitedepth = -1;
          }
          if (!($("#whitemovetime").validity.valid && whitemovetimev > 0)) {
            whitemovetime = -1;
          }
          if (!($("#whitenodes").validity.valid && whitenodesv > 0)) {
            whitenodes = -1;
          }
          if (!($("#blackdepth").validity.valid && blackdepthv > 0)) {
            blackdepth = -1;
          }
          if (!($("#blackmovetime").validity.valid && blackmovetimev > 0)) {
            blackmovetime = -1;
          }
          if (!($("#blacknodes").validity.valid && blacknodesv > 0)) {
            blacknodes = -1;
          }
        }

        if (threadnum.length <= 0 || threadnum < 1) {
          stockfish.postMessage(`setoption name Threads value 1`);
        } else if (threadnum > 512) {
          stockfish.postMessage(`setoption name Threads value 512`);
        } else {
          stockfish.postMessage(`setoption name Threads value ${threadnum}`);
        }
        if (hashsize.length <= 0 || hashsize < 1) {
          if (in_browser_fsf_hash != 16) {
            stockfish.postMessage(`setoption name Hash value 16`);
            in_browser_fsf_hash = 16;
            console.log(`sethash: 16`);
          }
        } else if (hashsize > 33554432) {
          if (in_browser_fsf_hash != 33554432) {
            stockfish.postMessage(`setoption name Hash value 33554432`);
            in_browser_fsf_hash = 33554432;
            console.log(`sethash: 33554432`);
          }
        } else if (in_browser_fsf_hash != hashsize) {
          stockfish.postMessage(`setoption name Hash value ${hashsize}`);
          in_browser_fsf_hash = hashsize;
          console.log(`sethash: ${hashsize}`);
        }
        if (
          multipleprincipalvariation.length <= 0 ||
          multipleprincipalvariation < 1
        ) {
          stockfish.postMessage(`setoption name MultiPV value 1`);
        } else if (multipleprincipalvariation > 500) {
          stockfish.postMessage(`setoption name MultiPV value 500`);
        } else {
          stockfish.postMessage(
            `setoption name MultiPV value ${multipleprincipalvariation}`,
          );
        }
        stockfish.postMessage(`isready`);

        const stm = $("#label-stm").innerText;
        play_move =
          (play_white && stm == "white") ||
          (play_black && stm == "black") ||
          analysis_mode;
        if (fge.WebSocketStatus == "CONNECTED") {
          if (analysis_mode) {
            if (fge.analysis_engine) {
              if (fge.analysis_engine.IsUsing) {
                if (clear_log) {
                  analysisengineoutput.textContent = "";
                  analysis_engine_output = "";
                }
                fge.analysis_engine.IsAnalysisEngine = true;
                fge.analysis_engine.StartThinking(
                  stm,
                  true,
                  false,
                  false,
                  false,
                  false,
                  -1,
                  -1,
                  -1,
                  wtime,
                  winc,
                  btime,
                  binc,
                  white_byoyomi_time_per_period,
                );
              } else {
                stockfish.postMessage(`go ${args}`);
              }
            } else {
              stockfish.postMessage(`go ${args}`);
            }
          } else if (stm == "white") {
            if (fge.first_engine) {
              if (fge.first_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove ==
                    $("#move").value.trim().split(" ").at(-1)
                ) {
                  fge.first_engine.StartThinking(
                    stm,
                    false,
                    true,
                    false,
                    true,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  console.log(
                    `%c Ponder %c HIT %c WHITE Ponder Hits`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                } else {
                  if (clear_log) {
                    whiteengineoutput.textContent = "";
                    first_engine_output = "";
                  }
                  fge.first_engine.StartThinking(
                    stm,
                    winf,
                    advanced_time_control,
                    false,
                    false,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  //console.log("WHITE: go " + wargs);
                }
              } else if (!black_engine_ponder_and_human_white) {
                output2 = "";
                stockfish.postMessage(`go ${args}`);
              }
            } else if (!black_engine_ponder_and_human_white) {
              output2 = "";
              stockfish.postMessage(`go ${args}`);
            }
            if (fge.second_engine) {
              if (fge.second_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove != "0000"
                ) {
                  if (clear_log) {
                    blackengineoutput.textContent = "";
                    second_engine_output = "";
                  }
                  fge.second_engine.StartThinking(
                    stm,
                    false,
                    true,
                    true,
                    false,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    black_byoyomi_time_per_period,
                  );
                }
              }
            }
          } else if (stm == "black") {
            if (fge.second_engine) {
              if (fge.second_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.second_engine.Ponder &&
                  fge.second_engine.PonderMove ==
                    $("#move").value.trim().split(" ").at(-1)
                ) {
                  fge.second_engine.StartThinking(
                    stm,
                    false,
                    true,
                    false,
                    true,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    black_byoyomi_time_per_period,
                  );
                  console.log(
                    `%c Ponder %c HIT %c BLACK Ponder Hits`,
                    "color: #fff; background: #5f5f5f",
                    "color: #fff; background: #4bc729",
                    "",
                  );
                } else {
                  if (clear_log) {
                    blackengineoutput.textContent = "";
                    second_engine_output = "";
                  }
                  fge.second_engine.StartThinking(
                    stm,
                    binf,
                    advanced_time_control,
                    false,
                    false,
                    black_timer_type == "byoyomi",
                    blackdepthv,
                    blackmovetimev,
                    blacknodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                  //console.log("BLACK: go " + bargs);
                }
              } else if (!white_engine_ponder_and_human_black) {
                output2 = "";
                stockfish.postMessage(`go ${args}`);
              }
            } else if (!white_engine_ponder_and_human_black) {
              output2 = "";
              stockfish.postMessage(`go ${args}`);
            }
            if (fge.first_engine) {
              if (fge.first_engine.IsUsing) {
                if (
                  advanced_time_control &&
                  fge.first_engine.Ponder &&
                  fge.first_engine.PonderMove != "0000"
                ) {
                  if (clear_log) {
                    whiteengineoutput.textContent = "";
                    first_engine_output = "";
                  }
                  fge.first_engine.StartThinking(
                    stm,
                    false,
                    true,
                    true,
                    false,
                    white_timer_type == "byoyomi",
                    whitedepthv,
                    whitemovetimev,
                    whitenodesv,
                    wtime,
                    winc,
                    btime,
                    binc,
                    white_byoyomi_time_per_period,
                  );
                }
              }
            }
          }
        } else {
          output2 = "";
          stockfish.postMessage(`go ${args}`);
        }
      };

      const setupTimer = () => {
        $("#timeoutside").value = 0;
        white_timer_type = $("#dropdown-whitetimemode").value;
        black_timer_type = $("#dropdown-blacktimemode").value;
        white_remaining_time = parseInt($("#whitestarttime").value);
        black_remaining_time = parseInt($("#blackstarttime").value);
        if (
          isNaN(white_remaining_time) ||
          white_remaining_time.length < 1 ||
          white_remaining_time < 1
        ) {
          white_remaining_time = play_white ? 20000 : 600000;
        }
        if (
          isNaN(black_remaining_time) ||
          black_remaining_time.length < 1 ||
          black_remaining_time < 1
        ) {
          black_remaining_time = play_black ? 20000 : 600000;
        }
        white_time_gain = parseInt($("#whitetimegain").value);
        black_time_gain = parseInt($("#blacktimegain").value);
        if (
          isNaN(white_time_gain) ||
          white_time_gain.length < 1 ||
          white_time_gain < 0
        ) {
          white_time_gain = 0;
        }
        if (
          isNaN(black_time_gain) ||
          black_time_gain.length < 1 ||
          black_time_gain < 0
        ) {
          black_time_gain = 0;
        }
        white_byoyomi_time_per_period = parseInt($("#whitebyoyomitime").value);
        black_byoyomi_time_per_period = parseInt($("#blackbyoyomitime").value);
        if (
          isNaN(white_byoyomi_time_per_period) ||
          white_byoyomi_time_per_period.length < 1 ||
          white_byoyomi_time_per_period < 1
        ) {
          white_byoyomi_time_per_period = 30000;
        }
        if (
          isNaN(black_byoyomi_time_per_period) ||
          black_byoyomi_time_per_period.length < 1 ||
          black_byoyomi_time_per_period < 1
        ) {
          black_byoyomi_time_per_period = 30000;
        }
        white_byoyomi_period_count = parseInt(
          $("#whitebyoyomiperiodcount").value,
        );
        black_byoyomi_period_count = parseInt(
          $("#blackbyoyomiperiodcount").value,
        );
        if (
          isNaN(white_byoyomi_period_count) ||
          white_byoyomi_period_count.length < 1 ||
          white_byoyomi_period_count < 1
        ) {
          white_byoyomi_period_count = 1;
        }
        if (
          isNaN(black_byoyomi_period_count) ||
          black_byoyomi_period_count.length < 1 ||
          black_byoyomi_period_count < 1
        ) {
          black_byoyomi_period_count = 1;
        }
        white_remaining_byoyomi_periods = white_byoyomi_period_count;
        black_remaining_byoyomi_periods = black_byoyomi_period_count;
        white_time_margin = parseInt($("#whitetimemargin").value);
        black_time_margin = parseInt($("#blacktimemargin").value);
        if (
          isNaN(white_time_margin) ||
          white_time_margin.length < 1 ||
          white_time_margin < 0
        ) {
          white_time_margin = timeout_margin;
        }
        if (
          isNaN(black_time_margin) ||
          black_time_margin.length < 1 ||
          black_time_margin < 0
        ) {
          black_time_margin = timeout_margin;
        }
        white_moving_time_list = [];
        black_moving_time_list = [];
        const now = Date.now();
        white_moving_time_list.push({
          remaining_time: white_remaining_time,
          time_stamp: now,
        }); //Start time white
        black_moving_time_list.push({
          remaining_time: black_remaining_time,
          time_stamp: now,
        }); //Start time black
        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
        if (white_timer_type == "infinite") {
          $("#whitetime").innerHTML = "âˆž";
        }
        if (black_timer_type == "infinite") {
          $("#blacktime").innerHTML = "âˆž";
        }
        previous_mover = "";
      };

      const resetTimer = () => {
        $("#whitetime").innerHTML = "--";
        $("#blacktime").innerHTML = "--";
        previous_mover = "";
        $("#timeoutside").value = 0;
      };

      function updateTimerOnMove() {
        if (!during_play) {
          return;
        }
        move_finish_timer_updating = true;
        const stm = document.getElementById("label-stm").innerText;
        console.log(`${$("#gamestatus").innerHTML}`);
        //console.log(white_moving_time_list);
        //console.log(white_moving_time_list);
        const now = Date.now();
        if (stm == "white") {
          if (previous_mover == "") {
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            }
            white_moving_time_list.push({
              remaining_time: white_remaining_time,
              time_stamp: now,
            }); //Time stamp for white's turn begin
          } else {
            black_moving_time_list.push({
              remaining_time: black_remaining_time,
              time_stamp: now,
            }); //Time stamp for black's turn end
            if (black_remaining_time < 0) {
              black_remaining_time = 0;
            }
            //white_remaining_time = (+white_moving_time_list.at(-1).remaining_time) + ((+white_moving_time_list.at(-1).time_stamp) - (+now));
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            } else if (white_timer_type == "time per move") {
              white_remaining_time =
                +white_moving_time_list[0].remaining_time + +timer_interval;
            } else if (white_timer_type == "byoyomi") {
              if (
                white_remaining_byoyomi_periods < white_byoyomi_period_count
              ) {
                white_remaining_time =
                  +white_byoyomi_time_per_period + +timer_interval;
              } else {
                white_remaining_time = +white_remaining_time + +timer_interval;
              }
            }
            if (black_timer_type == "hourglass") {
              white_remaining_time =
                +white_remaining_time +
                +black_moving_time_list.at(-2).remaining_time -
                +black_moving_time_list.at(-1).remaining_time;
            }
            white_moving_time_list.push({
              remaining_time: white_remaining_time,
              time_stamp: now,
            }); //Time stamp for white's turn begin
          }
          previous_mover = "WHITE";
        } else if (stm == "black") {
          if (previous_mover == "") {
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            }
            black_moving_time_list.push({
              remaining_time: black_remaining_time,
              time_stamp: now,
            }); //Time stamp for black's turn begin
          } else {
            white_moving_time_list.push({
              remaining_time: white_remaining_time,
              time_stamp: now,
            }); //Time stamp for white's turn end
            if (white_remaining_time < 0) {
              white_remaining_time = 0;
            }
            //black_remaining_time = (+black_moving_time_list.at(-1).remaining_time) + ((+black_moving_time_list.at(-1).time_stamp) - (+now));
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            } else if (black_timer_type == "time per move") {
              black_remaining_time =
                +black_moving_time_list[0].remaining_time + +timer_interval;
            } else if (black_timer_type == "byoyomi") {
              if (
                black_remaining_byoyomi_periods < black_byoyomi_period_count
              ) {
                black_remaining_time =
                  +black_byoyomi_time_per_period + +timer_interval;
              } else {
                black_remaining_time = +black_remaining_time + +timer_interval;
              }
            }
            if (white_timer_type == "hourglass") {
              black_remaining_time =
                +black_remaining_time +
                +white_moving_time_list.at(-2).remaining_time -
                +white_moving_time_list.at(-1).remaining_time;
            }
            black_moving_time_list.push({
              remaining_time: black_remaining_time,
              time_stamp: now,
            }); //Time stamp for black's turn begin
          }
          previous_mover = "BLACK";
        }
        move_finish_timer_updating = false;
      }

      function updateTimer() {
        if ($("#gamestatus").innerHTML == "END") {
          deleteTimer();
          gameEnd();
          return;
        }
        if (move_finish_timer_updating) {
          //avoid race condition
          return;
        }
        $("#gamestatus").click();
        console.log(`${$("#gamestatus").innerHTML}`);
        if ($("#gamestatus").innerHTML == "PLAYING_WHITE") {
          if (white_timer_type == "infinite") {
            previous_mover = "WHITE";
            return;
          }
          white_remaining_time = white_remaining_time - timer_interval;
          if (white_timer_type == "byoyomi" && white_remaining_time <= 0) {
            if (white_remaining_byoyomi_periods == 0) {
            } else {
              white_remaining_byoyomi_periods--;
              white_remaining_time = +white_byoyomi_time_per_period;
              console.log(
                "WHITE byoyomi remaining periods: " +
                  white_remaining_byoyomi_periods,
              );
            }
          }
          if (white_remaining_time < -white_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 1;
            timeIsUpFor("WHITE");
            return;
          }
          if (white_timer_type == "infinite") {
            $("#whitetime").innerText = "âˆž";
          } else if (white_remaining_time >= 10000) {
            $("#whitetime").innerText = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            $("#whitetime").innerText = `${(
              parseInt(Math.max(white_remaining_time, 0) / 100) / 10
            ).toFixed(1)}`;
          }
          if (black_timer_type == "infinite") {
            $("#blacktime").innerText = "âˆž";
          } else if (black_remaining_time >= 10000) {
            $("#blacktime").innerText = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            $("#blacktime").innerText = `${(
              parseInt(Math.max(black_remaining_time, 0) / 100) / 10
            ).toFixed(1)}`;
          }
          if (white_timer_type == "byoyomi") {
            $("#whitetime").innerText +=
              ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            $("#blacktime").innerText +=
              ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "WHITE";
        } else if ($("#gamestatus").innerHTML == "PLAYING_BLACK") {
          if (black_timer_type == "infinite") {
            previous_mover = "BLACK";
            return;
          }
          black_remaining_time = black_remaining_time - timer_interval;
          if (black_timer_type == "byoyomi" && black_remaining_time <= 0) {
            if (black_remaining_byoyomi_periods == 0) {
            } else {
              black_remaining_byoyomi_periods--;
              black_remaining_time = +black_byoyomi_time_per_period;
              console.log(
                "BLACK byoyomi remaining periods: " +
                  black_remaining_byoyomi_periods,
              );
            }
          }
          if (black_remaining_time < -black_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 2;
            timeIsUpFor("BLACK");
            return;
          }
          if (white_timer_type == "infinite") {
            $("#whitetime").innerText = "âˆž";
          } else if (white_remaining_time >= 10000) {
            $("#whitetime").innerText = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            $("#whitetime").innerText = `${(
              parseInt(Math.max(white_remaining_time, 0) / 100) / 10
            ).toFixed(1)}`;
          }
          if (black_timer_type == "infinite") {
            $("#blacktime").innerText = "âˆž";
          } else if (black_remaining_time >= 10000) {
            $("#blacktime").innerText = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            $("#blacktime").innerText = `${(
              parseInt(Math.max(black_remaining_time, 0) / 100) / 10
            ).toFixed(1)}`;
          }
          if (white_timer_type == "byoyomi") {
            $("#whitetime").innerText +=
              ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            $("#blacktime").innerText +=
              ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "BLACK";
        }
      }

      const createTimer = () => {
        timer = setInterval(() => {
          updateTimer();
        }, timer_interval);
        console.log(`${timer}`);
      };

      const deleteTimer = () => {
        console.log("Timer delete!");
        clearInterval(timer);
      };

      const timeIsUpFor = (side) => {
        force_stop();
        if (side == "WHITE") {
          white_remaining_time = 0;
          $("#timeoutside").value = 1;
          $("#whitetime").innerHTML = "Out Of Time";
        } else if (side == "BLACK") {
          black_remaining_time = 0;
          $("#timeoutside").value = 2;
          $("#blacktime").innerHTML = "Out Of Time";
        }
        $("#gamestatus").click();
        gameEnd();
      };

      const gameEnd = () => {
        during_play = false;
        //advanced_time_control = false;
        force_stop();
        $("#currentposition").click();
        $("#input").style.display = "";
        $("#input2").style.display = "";
        $("#input3").style.display = "";
        $("#posvariantdiv").style.display = "";
      };

      const gameAbort = () => {
        deleteTimer();
        $("#gamestatus").innerHTML = "END";
        gameEnd();
      };

      const goWithTimeControl = () => {
        if ($("#gamestatus").innerHTML != "END") {
          return;
        }
        //We need to prevent user from doing unnecessary actions during countdown, so we'll hide these divs
        $("#input").style.display = "none"; //These divs are unable to be hidden by {hidden: during_play}
        $("#input2").style.display = "none";
        $("#input3").style.display = "none";
        $("#posvariantdiv").style.display = "none";
        //$("#movecontrol").style.display = "none";
        resetTimer();
        setupTimer();
        $("#gamestatus").click();
        during_play = true;
        $("#currentposition").click();
        if (fge.first_engine) {
          fge.first_engine.PonderMove = "0000";
          fge.first_engine.PonderMiss = false;
        }
        if (fge.second_engine) {
          fge.second_engine.PonderMove = "0000";
          fge.second_engine.PonderMiss = false;
        }
        updateTimerOnMove();
        createTimer();
        const stm = $("#label-stm").innerText;
        console.log(
          `white: ${play_white} black: ${play_black} move: ${
            (play_white && stm == "white") || (play_black && stm == "black")
          }`,
        );
        console.log("Go!");
        setFen(false, true);
      };

      const stop = (interrupt_pondering) => {
        stockfish.postMessage(`stop`);
        if (fge.first_engine) {
          fge.first_engine.StopThinking(
            interrupt_pondering,
            advanced_time_control,
          );
        }
        if (fge.second_engine) {
          fge.second_engine.StopThinking(
            interrupt_pondering,
            advanced_time_control,
          );
        }
        if (fge.analysis_engine) {
          fge.analysis_engine.StopThinking(true, false);
        }
      };

      const force_stop = () => {
        play_white =
          play_black =
          random_mover_white =
          random_mover_black =
            false;
        play_move = false;
        stop(true);
      };

      const changePieces = (onlyChangeWhenInvalid) => {
        let index = 0;
        let themename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          themename = "default";
        } else {
          classes = themes[1][index];
          if (classes.length < 1) {
            classes = themes[1][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[1]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change piece.");
              updateThemeDropdowns(DOMListValue[1], null);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          themename = classes[index];
        } else {
          themename = "default";
        }
        DOMListValue[1] = themename;
        el.classList.value = DOMListValue.join(" ");
        console.log(`Piece theme: ${themename}`);
        updateThemeDropdowns(themename, null);
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const changeBoard = (onlyChangeWhenInvalid) => {
        let index = 0;
        let boardthemename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          boardthemename = "defaultboard";
        } else {
          classes = themes[2][index];
          if (classes.length < 1) {
            classes = themes[2][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[0]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change board.");
              updateThemeDropdowns(null, DOMListValue[0]);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          boardthemename = classes[index];
        } else {
          boardthemename = "defaultboard";
        }
        DOMListValue[0] = boardthemename;
        el.classList.value = DOMListValue.join(" ");
        console.log(`Board theme: ${boardthemename}`);
        updateThemeDropdowns(null, boardthemename);
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const setupThemeDropdowns = () => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        while (piecethemedropdown.options.length > 0) {
          piecethemedropdown.remove(0);
        }
        while (boardthemedropdown.options.length > 0) {
          boardthemedropdown.remove(0);
        }
        let index = 0;
        let piececlasses = [];
        let boardclasses = [];
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          null;
        } else {
          piececlasses = themes[1][index];
          if (piececlasses.length < 1) {
            piececlasses = themes[1][themes[0].indexOf("")];
          }
          boardclasses = themes[2][index];
          if (boardclasses.length < 1) {
            boardclasses = themes[2][themes[0].indexOf("")];
          }
        }
        if (piececlasses.length > 0) {
          piececlasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            piecethemedropdown.add(newOption);
            //console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Pieces";
          newOption.value = "default";
          piecethemedropdown.add(newOption);
          newOption = document.createElement("option");
          newOption.text = getThemeName("userdefined");
          newOption.value = "userdefined";
          piecethemedropdown.add(newOption);
        }
        if (boardclasses.length > 0) {
          boardclasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            boardthemedropdown.add(newOption);
            //console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Board";
          newOption.value = "defaultboard";
          boardthemedropdown.add(newOption);
        }
      };

      const updateThemeDropdowns = (piecethemeid, boardthemeid) => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        let i = 0;
        if (piecethemeid) {
          for (i = 0; i < piecethemedropdown.options.length; i++) {
            if (piecethemedropdown[i].value == piecethemeid) {
              piecethemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == piecethemedropdown.options.length) {
            piecethemedropdown.selectedIndex = -1;
          }
        }
        if (boardthemeid) {
          for (i = 0; i < boardthemedropdown.options.length; i++) {
            if (boardthemedropdown[i].value == boardthemeid) {
              boardthemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == boardthemedropdown.options.length) {
            boardthemedropdown.selectedIndex = -1;
          }
        }
      };

      const updateVariantDropdownTitles = () => {
        const variantdropdown = $("#dropdown-variant");
        let i = 0;
        let index = 0;
        for (i = 0; i < variantdropdown.children.length; i++) {
          index = variantsettings[0].indexOf(variantdropdown.children[i].value);
          if (index < 0) {
            continue;
          }
          variantdropdown.children[i].title = variantsettings[2][index];
        }
      };

      const updateVariantDropdown = () => {
        const varianttypedropdown = $("#dropdown-varianttype");
        const variantdropdown = $("#dropdown-variant");
        const selectedtype =
          varianttypedropdown[varianttypedropdown.selectedIndex].value;
        if (selectedtype == "") {
          variants = [""].concat(allvariants);
        } else if (selectedtype == "<|NC|>") {
          let tmpvariants = [""];
          allvariants.forEach((val) => {
            if (!variantsettings[0].includes(val)) {
              tmpvariants.push(val);
            }
          });
          variants = tmpvariants;
        } else {
          let tmpvariants = [];
          allvariants.forEach((val) => {
            if (getVariantType(val) == selectedtype) {
              tmpvariants.push(val);
            }
          });
          variants = tmpvariants;
        }
        while (variantdropdown.children.length > 0) {
          variantdropdown.removeChild(variantdropdown[0]);
        }
        variants.forEach((val) => {
          let option = document.createElement("option");
          let name = "(default)";
          let title = getVariantDescription(val, true);
          if (val != "") {
            name = getVariantName(val, true, true);
          }
          option.value = val;
          option.text = name;
          if (title != "") {
            option.title = title;
          }
          variantdropdown.appendChild(option);
        });
        variantdropdown.selectedIndex = 0;
        //updateVariantDropdownTitles();
      };

      const updateVariantTypeDropdown = () => {
        const varianttypedropdown = $("#dropdown-varianttype");
        while (varianttypedropdown.children.length > 2) {
          varianttypedropdown.removeChild(varianttypedropdown[2]);
        }
        let varianttypevariantcount = [[], []];
        variantsettings[1].forEach((val) => {
          if (varianttypevariantcount[0].includes(val)) {
            return;
          }
          varianttypevariantcount[0].push(val);
          varianttypevariantcount[1].push(0);
        });
        console.log(allvariants);
        variantsettings[0].forEach((val, ind) => {
          if (allvariants.includes(val)) {
            let index = varianttypevariantcount[0].indexOf(
              variantsettings[1][ind],
            );
            if (index >= 0) {
              varianttypevariantcount[1][index]++;
            }
          }
        });
        console.log(varianttypevariantcount);
        varianttypevariantcount[0].forEach((val, ind) => {
          if (varianttypevariantcount[1][ind] > 0) {
            if (!varianttypes.includes(val)) {
              varianttypes.push(val);
            }
          }
        });
        varianttypes.sort();
        varianttypes.forEach((val) => {
          let option = document.createElement("option");
          option.text = val;
          option.value = val;
          varianttypedropdown.appendChild(option);
        });
        varianttypedropdown.selectedIndex = 0;
        changing_variant_type = true;
        $("#dropdown-variant").dispatchEvent(new Event("change"));
      };

      const updateUIThemeDropdown = (ui_id) => {
        const uithemedropdown = document.getElementById("dropdown-uitheme");
        uithemedropdown.selectedIndex = uithemes[0].indexOf(ui_id);
      };

      const setupUIThemeDropdown = () => {
        const uithemedropdown = document.getElementById("dropdown-uitheme");
        let i = 0;
        if (uithemes[0].length > 0) {
          while (uithemedropdown[0]) {
            uithemedropdown.removeChild(uithemedropdown[0]);
          }
          for (i = 0; i < uithemes[0].length; i++) {
            let option = document.createElement("option");
            option.value = uithemes[0][i];
            option.text = uithemes[1][i];
            uithemedropdown.appendChild(option);
          }
        }
      };

      const scrollOutput = () => {
        $("#output2").scrollTo({
          top: $("#output2").scrollHeight,
          behavior: "smooth",
        });
      };

      const displayGameResult = () => {
        let i = 0;
        let chi = document.getElementsByTagName("spangameresult");
        for (i = 0; i < chi.length; i++) {
          document.body.removeChild(chi[i]);
        }
        if (review_mode || board_setup_mode) {
          return;
        }
        var span = document.createElement("spangameresult");
        span.innerHTML = $("#gameresult").value;
        span.style.left = window.innerWidth / 2 + "px";
        span.style.top = window.innerHeight / 2 + "px";
        setTimeout(function () {
          span.style.opacity = "1";
          span.style.transform = "scale(40)";
        }, 100);
        setTimeout(function () {
          span.style.opacity = "0";
          span.style.transform = "scale(0.02)";
        }, 2600);
        document.body.appendChild(span);
      };

      // Make error catchable
      const loadStockfish = async (params) => {
        return await Stockfish(params);
      };

      const onFinishDownload = (data) => {
        if (!data) {
          stockfish_state = "FAILED";
          m.redraw();
          return;
        }

        loadStockfish({ wasmBinary: data })
          .then(
            (_stockfish) => {
              stockfish = _stockfish;
              stockfish_state = "READY";
              stockfish.addMessageListener((line) => {
                if (line.startsWith("option")) {
                  if (line.startsWith("option name UCI_Variant")) {
                    allvariants = line
                      .replace(
                        "option name UCI_Variant type combo default chess var ",
                        "",
                      )
                      .replace(/ var /g, " ")
                      .split(" ")
                      .sort();
                    //variants = allvariants;
                    updateVariantTypeDropdown();
                  }
                } else if (line.startsWith(" ")) {
                } else {
                  if (
                    !review_mode &&
                    line.startsWith("bestmove") &&
                    play_move
                  ) {
                    play_move = false;
                    if (analysis_mode) {
                      return;
                    }
                    $("#move").value += " " + line.split(" ")[1];
                    $("#set").click();
                  }
                  output2 += line + "\n";
                  if (fge.analysis_engine) {
                    if (!fge.analysis_engine.IsUsing) {
                      $("#engineoutputline").value = line;
                      $("#engineoutputline").click();
                    }
                  } else {
                    $("#engineoutputline").value = line;
                    $("#engineoutputline").click();
                  }
                }
                m.redraw();
              });
              getVariants();
            },
            (err) => {
              console.error(err);
              throw err;
            },
          )
          .catch((e) => {
            stockfish_state = "FAILED";
            window.alert(
              "There is something wrong with in browser Fairy-Stockfish. Press Ctrl+Shift+I to see more details.",
            );
            throw e;
          })
          .finally(() => m.redraw());
      };

      const onSelectNnueFile = async (e) => {
        const selected = e.currentTarget.files[0];
        if (selected) {
          //
          // TODO:
          // On Archlinux Chromium 92.0.4515.107, most of times this code fails with the error saying:
          //   TypeError: Failed to execute 'decode' on 'TextDecoder': The provided ArrayBufferView value must not be shared.
          // On the other hand, either Chrome with the same version or Firefox never fail.
          //
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`setoption name EvalFile value ${filename}`);
          // Automatically set variant
          const variant = selected.name.split(/[_.-]+/)[0];
          $("#dropdown-variant").value = variant;
          $("#dropdown-variant").dispatchEvent(new Event("change"));
        }
      };

      const onSelectVariantsFile = async (e) => {
        const selected = e.currentTarget.files[0];
        //console.log(`${selected}`);
        if (selected) {
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`check ${filename}`);
          stockfish.postMessage(`load ${filename}`);
          getVariants();
        }
      };

      function isLetter(str) {
        return str.length === 1 && str.match(/[a-z]/i);
      }

      function changePieceSet(piece_set) {
        const el = $("#chessground-container-div");
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[1] = piece_set;
        el.classList.value = DOMListValue.join(" ");
        updateThemeDropdowns(piece_set, null);
      }

      function changeBoardSet(board_set) {
        const el = $("#chessground-container-div");
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[0] = board_set;
        el.classList.value = DOMListValue.join(" ");
        updateThemeDropdowns(null, board_set);
      }

      function changeUI(ui_id) {
        const pagebackground = document.getElementById("pagebackground");
        const htmlComputedStyle = window.getComputedStyle(pagebackground);
        const BGBefore = htmlComputedStyle.backgroundImage;
        if (currentuicss != null) {
          document.head.removeChild(currentuicss);
        }
        currentuicss = uithemes[2][uithemes[0].indexOf(ui_id)];
        document.head.appendChild(currentuicss);
        const htmlComputedStyleAfter = window.getComputedStyle(pagebackground);
        const BGAfter = htmlComputedStyleAfter.backgroundImage;
        console.log(BGBefore, BGAfter);

        if (BGBefore != "none") {
          const tmpbg = document.createElement("div");
          tmpbg.id = "bg-animation";
          tmpbg.style.backgroundImage = BGBefore;
          tmpbg.className = "backgroundimg";
          tmpbg.style.opacity = "1";
          tmpbg.style.zIndex = "-1";
          document.body.appendChild(tmpbg);
          LinearTransition(
            1,
            0,
            -0.02,
            10,
            (val) => {
              tmpbg.style.opacity = `${val}`;
            },
            () => {
              document.body.removeChild(tmpbg);
            },
          );
        }

        if (BGAfter != "none") {
          const tmpbg2 = document.createElement("div");
          tmpbg2.id = "bg-animation";
          tmpbg2.style.backgroundImage = BGAfter;
          tmpbg2.className = "backgroundimg";
          tmpbg2.style.opacity = "0";
          tmpbg2.style.zIndex = "-2";
          pagebackground.style.backgroundImage = "none";
          document.body.appendChild(tmpbg2);
          LinearTransition(
            0,
            1,
            0.02,
            10,
            (val) => {
              tmpbg2.style.opacity = `${val}`;
            },
            () => {
              pagebackground.style.backgroundImage = "";
              document.body.removeChild(tmpbg2);
            },
          );
        }
        updateUIThemeDropdown(ui_id);
      }

      const onSelectUserGraphics = async (e) => {
        var files_count = e.currentTarget.files.length;
        var files = [];

        if (!e.currentTarget.files.length) {
        } else {
          style = document.createElement("style");

          // See what files are being loaded.
          for (let i = 0; i < files_count; i++) {
            const selected = e.currentTarget.files[i];
            var filename = e.currentTarget.files[i].name.toLowerCase();

            files[files.length] = e.currentTarget.files[i];
          }

          console.log("File count: " + files.length);

          for (let i = 0; i < files.length; i++) {
            const selected = files[i];
            var bloburl = URL.createObjectURL(selected);
            var filename = files[i].name.split(".")[0].toLowerCase();
            var piececolor = filename.substr(0, 1);
            var pieceletter = filename.substr(1, 2).replace("+", "p");
            // Skip the file if it does not match the naming convention.
            if (piececolor == "b") {
              piececolor = "black";
            } else if (piececolor == "w") {
              piececolor = "white";
            } else {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length != 2 && filename.length != 3) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 2 && !isLetter(filename.substr(1, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && filename.substr(1, 1) != "+") {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && !isLetter(filename.substr(2, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            //console.log(filename);
            //console.log(piececolor);
            //console.log(pieceletter);
            console.log(`${bloburl}`);
            //console.log(`${selected}`);
            if (selected) {
              style.textContent =
                style.textContent +
                `.userdefined .cg-wrap piece.${pieceletter}-piece.${piececolor} { background-image: url('${bloburl}');} `;
            }
          }

          //console.log(`${style.textContent}`);
          document.head.appendChild(style);

          changePieceSet("userdefined");
        }
      };

      const onSelectVariantSettings = async (e) => {
        const selected = e.currentTarget.files[0];
        if (selected) {
          let reader = new FileReader();
          reader.readAsText(selected);
          reader.onload = function () {
            console.log(reader.result);
            LoadVariantSettings("client", reader.result);
            updateVariantTypeDropdown();
          };
        }
      };

      const oninit = () => {
        stockfish_state = "LOADING";
      };

      const view = () => {
        const is_ready = stockfish_state == "READY";

        return m("main", [
          m("p#pagetitle", "Advanced analysis"),
          m("div#misc", { hidden: during_play }, [
            m("div", [
              `Fairy-Stockfish: ${stockfish_state} - download: `,
              m(RequestProgress, {
                url: "./lib/stockfish.wasm",
                onFinishDownload,
              }),
            ]),
            m("div", { hidden: during_play }, [
              "- nnue file: ",
              m("input", {
                type: "file",
                disabled: !is_ready,
                onchange: onSelectNnueFile,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload a Fairy-Stockfish compatible .nnue file. Downloads: https://fairy-stockfish.github.io/nnue/#current-best-nnue-networks.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- variants.ini: ",
              m("input#variants-ini", {
                type: "file",
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: onSelectVariantsFile,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload a Fairy-Stockfish compatible variants.ini file. See here for details: https://github.com/ianfab/Fairy-Stockfish/wiki/Variant-configuration.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- positionvariants.txt: ",
              m("input#posvariant-txt", {
                type: "file",
                disabled: !is_ready || review_mode || board_setup_mode,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can select a Position Variant file to load different positions for different variants. Contents will be appended to the position variants provided by the server.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- User Piece Graphics: ",
              m("input#user-graphics", {
                type: "file",
                multiple: true,
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: onSelectUserGraphics,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload user defined piece graphics. They must be named as follows [piece colour][+][piece letter].svg.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- variantsettings.txt: ",
              m("input#variantsettings-txt", {
                type: "file",
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: onSelectVariantSettings,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload a Variant Settings file to load settings for the variants including classification, names and descriptions. Contents will be appended to the variant descriptions provided by the server.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- External binary engine feature: ",
              m(
                "button",
                {
                  disabled: !is_ready,
                  onclick: () => {
                    if (!is_ready) {
                      return;
                    }
                    if (fge.WebSocketStatus == "CONNECTED") {
                      window.alert("You are already connected.");
                      return;
                    } else if (fge.WebSocketStatus == "CONNECTING") {
                      window.alert(
                        "Connection is during establishment process.",
                      );
                      return;
                    }
                    let port = window.prompt(
                      "Please enter the WebSocket port of local fairyground server:",
                      "5016",
                    );
                    if (port) {
                      connectToWebSocketServer(port);
                    }
                  },
                },
                "CONNECT",
              ),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "If you are using online version of fairyground, external binary engine loading feature will not be enabled automatically. You need to provide the port of local (i.e. offline version) fairyground server in order to make it work.",
                    ),
                },
                "[?]",
              ),
            ]),
          ]),
          m("div#posvariantdiv", [
            m("p", "Variant Type:"),
            m(
              "select#dropdown-varianttype",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "The available types or categories of variants are shown in this list. Select one to see available variants in next dropdown.",
                onchange: (e) => {
                  changing_variant_type = true;
                  $("#dropdown-variant").dispatchEvent(new Event("change"));
                },
              },
              [
                m("option", { value: "" }, "(all)"),
                m("option", { value: "<|NC|>" }, "(not classified)"),
              ],
            ),
            m("p", "Name:"),
            m(
              "select#dropdown-variant",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "The available variants of the selected type are shown in this list. Select one to start a game of that variant.",
                onchange: (e) => {
                  if (changing_variant_type) {
                    updateVariantDropdown();
                    changing_variant_type = false;
                  }
                  window.setTimeout(setVariant, 10);
                },
              },
              [
                m("option", { value: "" }, "(default)"),
                //...variants.map((ex, index) => m("option", { value: ex, title: getVariantDescription(ex, true) }, getVariantName(ex,true,true))),
              ],
            ),
            m("p", "Custom Position Type:"),
            m(
              "select#dropdown-posvarianttype",
              {
                disabled: !is_ready || review_mode,
                title:
                  "The available types or categories of custom positions of this variant are shown in this list. Select one to see available positions in next dropdown.",
              },
              [m("option", { value: "(default)" }, "(default)")],
            ),
            m("p", "Name:"),
            m(
              "select#dropdown-posvariantname",
              {
                disabled: !is_ready || review_mode,
                title:
                  "The available custom positions of the selected type are shown in this list. Select one to set the position.",
              },
              [],
            ),
            m(
              "button#aboutposition",
              {
                disabled: !is_ready || review_mode,
                title:
                  "Click to show the information of current selected custom position (position variant).",
              },
              "Position INFO",
            ),
            m(
              "button#aboutvariant",
              {
                disabled: !is_ready || review_mode,
                title:
                  "Click to show the information and the wiki page (if it has, otherwise not shown) of current variant.",
                onclick: () => {
                  let name = getVariantName(
                    $("#dropdown-variant").value,
                    true,
                    false,
                  );
                  let description = getVariantDescription(
                    $("#dropdown-variant").value,
                    false,
                  );
                  let wiki = getVariantWikiPageURL(
                    $("#dropdown-variant").value,
                    false,
                  );
                  if (description) {
                    if (wiki) {
                      if (
                        window.confirm(
                          `Variant ${name} (ID: ${$("#dropdown-variant").value}):\n${description}\n\nWiki: ${wiki}\n\nDo you want to visit the wiki page?`,
                        )
                      ) {
                        OpenURL(wiki);
                      }
                    } else {
                      window.alert(
                        `Variant ${name} (ID: ${$("#dropdown-variant").value}):\n${description}`,
                      );
                    }
                  } else {
                    window.alert(
                      "This variant does not provide a description. You can upload a variantsettings.txt yourself to add a description for it.",
                    );
                  }
                },
              },
              "Variant INFO",
            ),
            m(
              "button",
              {
                disabled: !is_ready || review_mode,
                title: "Click to open PGN file and EPD file parser.",
                onclick: () => {
                  if (!is_ready || review_mode) {
                    return;
                  }
                  if (fgs) {
                    if (window.ffishlib) {
                      fgs.ShowPGNOrEPDFileUI(game_list, window.ffishlib);
                    }
                  }
                },
              },
              "PGN/EPD Parser",
            ),
          ]),
          m("div#input", { hidden: during_play }, [
            m("p", "Position:"),
            m("input[type=text]#fen", {
              placeholder: "Input FEN Here",
              title:
                "Input the Forsyth-Edwards Notation (FEN) of the position you want to load. Leave it blank to use default position.",
              maxlength: 9999,
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen(true, false);
              },
            }),
            m("input[type=text]#move", {
              placeholder: "Input Move Here",
              title:
                "Input the moves in UCI format based on the FEN. Leave it blank to indicate no move.",
              maxlength: 9999,
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen(true, false);
              },
            }),
            m(
              "button#setpos",
              {
                disabled: !is_ready || review_mode,
                title: "Click to set the FEN and the moves to the board.",
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  resetTimer();
                  stockfish.postMessage(`stop`);
                  stockfish.postMessage(`ucinewgame`);
                  if (fge.first_engine) {
                    fge.first_engine.NewGame();
                  }
                  if (fge.second_engine) {
                    fge.second_engine.NewGame();
                  }
                  if (fge.analysis_engine) {
                    fge.analysis_engine.NewGame();
                  }
                  window.setTimeout(() => {
                    setFen(true, false);
                  }, 10);
                  $("#currentposition").click();
                },
              },
              "â˜‘ï¸Set",
            ),
            m(
              "button#reset",
              {
                disabled: !is_ready,
                title: "Click to reset the position to default position.",
                onclick: reset,
              },
              "âï¸Reset",
            ),
            m(
              "button#undo",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title: "Click to undo last move.",
                hidden: review_mode,
                onclick: undo,
              },
              "â—€ï¸Undo",
            ),
          ]),
          m(
            "div#binengineinput",
            { hidden: during_play || fge.WebSocketStatus != "CONNECTED" },
            [
              m(
                "button",
                {
                  title: "Click to enter binary engine management UI.",
                  onclick: () => {
                    fge.ShowEngineManagementUI(engine_list, fge.ws);
                  },
                },
                "Engine Management",
              ),
              m("div#whiteenginesettings", [
                m("p", "1st binary engine settings:"),
                m("input[type=number]#whitedepth", {
                  placeholder: "Depth",
                  title:
                    "The maximum depth that the engine is allowed to search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m("input[type=number]#whitemovetime", {
                  placeholder: "Movetime",
                  title:
                    "The time in milliseconds that the engine can think at most.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 0,
                }),
                m("input[type=number]#whitenodes", {
                  placeholder: "Nodes",
                  title: "The number of moves that the engine should search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m(
                  "p#whiteunsupportedvariant",
                  { hidden: true },
                  "1st engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
              m("div#blackenginesettings", [
                m("p", "2nd binary engine settings:"),
                m("input[type=number]#blackdepth", {
                  placeholder: "Depth",
                  title:
                    "The maximum depth that the engine is allowed to search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m("input[type=number]#blackmovetime", {
                  placeholder: "Movetime",
                  title:
                    "The time in milliseconds that the engine can think at most.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 0,
                }),
                m("input[type=number]#blacknodes", {
                  placeholder: "Nodes",
                  title: "The number of moves that the engine should search.",
                  disabled:
                    !is_ready ||
                    fge.WebSocketStatus != "CONNECTED" ||
                    analysis_mode,
                  min: 1,
                }),
                m(
                  "p#blackunsupportedvariant",
                  { hidden: true },
                  "2nd engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
              m("div#analysisenginesettings", [
                m(
                  "p#analysisunsupportedvariant",
                  { hidden: true },
                  "Analysis engine does not support this variant. In browser Fairy-Stockfish will be used instead.",
                ),
              ]),
            ],
          ),
          m("div#input2", { hidden: during_play }, [
            m("p", "Settings:"),
            m("input[type=number]#depth", {
              placeholder: "Depth",
              title:
                "The maximum depth in browser Fairy-Stockfish is allowed to search.",
              disabled: !is_ready || analysis_mode,
              min: 1,
              max: 255,
            }),
            m("input[type=number]#movetime", {
              placeholder: "Movetime",
              title:
                "The time in milliseconds that in browser Fairy-Stockfish can think at most.",
              disabled: !is_ready || analysis_mode,
              min: 0,
            }),
            m("input[type=number]#nodes", {
              placeholder: "Nodes",
              title:
                "The number of moves that in browser Fairy-Stockfish should search.",
              disabled: !is_ready || analysis_mode,
              min: 1,
            }),
            m("input[type=number]#threads", {
              placeholder: "Threads",
              title:
                "The number of parallel searching threads of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 512,
            }),
            m("input[type=number]#hash", {
              placeholder: "Hash",
              title:
                "The size of the hash table of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 33554432,
            }),
            m("input[type=number]#multipv", {
              placeholder: "MultiPV",
              title:
                "The number of principal variations (engine lines, PV) of in browser Fairy-Stockfish.",
              disabled: !is_ready,
              min: 1,
              max: 500,
            }),
            m(
              "button#go",
              {
                disabled: !is_ready,
                title:
                  "Click to tell the corresponding engine to start thinking.",
                onclick: () => {
                  if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                  }
                  setTimeout(() => {
                    if (!review_mode) {
                      setFen(true, false);
                    }
                    go(false, false);
                  }, 10);
                },
              },
              "â–¶ï¸Go",
            ),
            m(
              "button#stop",
              {
                disabled: !is_ready,
                title: "Click to immediately stop all engines from thinking.",
                onclick: () => {
                  force_stop();
                  if (fge.first_engine) {
                    fge.first_engine.ForceStop();
                  }
                  if (fge.second_engine) {
                    fge.second_engine.ForceStop();
                  }
                  if (fge.analysis_engine) {
                    fge.analysis_engine.ForceStop();
                  }
                },
              },
              "â¹Stop",
            ),
            m(
              "label#label-analysis",
              {
                title:
                  "When checked, interactive analysis mode is enabled and will use analysis binary engine (if loaded, otherwise in browser Fairy-Stockfish) to think on the position infinitely.",
              },
              m("input[type=checkbox]#analysis", {
                checked: analysis_mode,
                disabled:
                  play_white ||
                  play_black ||
                  advanced_time_control ||
                  board_setup_mode ||
                  random_mover_white ||
                  random_mover_black,
                onclick: () => {
                  analysis_mode = !analysis_mode;
                  document
                    .getElementById("dropdown-fogofwarsettings")
                    .dispatchEvent(new Event("change"));
                },
              }),
              "Analysis",
            ),
            m(
              "label",
              {
                title: "When checked, engine will play as first mover (white).",
              },
              m("input[type=checkbox]#playwhite", {
                checked: play_white,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  random_mover_white,
                onclick: () => {
                  play_white = !play_white;
                },
              }),
              "Engine white",
            ),
            m(
              "label",
              {
                title:
                  "When checked, engine will play as second mover (black).",
              },
              m("input[type=checkbox]#playblack", {
                checked: play_black,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  random_mover_black,
                onclick: () => {
                  play_black = !play_black;
                },
              }),
              "Engine black",
            ),
            m(
              "label",
              {
                title:
                  "When checked, random moves will be made when it's first mover (white) to move.",
              },
              m("input[type=checkbox]#randommoverwhite", {
                checked: random_mover_white,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  play_white,
                onclick: () => {
                  random_mover_white = !random_mover_white;
                },
              }),
              "Random mover white",
            ),
            m(
              "label",
              {
                title:
                  "When checked, random moves will be made when it's second mover (black) to move.",
              },
              m("input[type=checkbox]#randommoverblack", {
                checked: random_mover_black,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  board_setup_mode ||
                  play_black,
                onclick: () => {
                  random_mover_black = !random_mover_black;
                },
              }),
              "Random mover black",
            ),
            m("p#label-stm", { hidden: true }),
            m("input#displaymoves", {
              placeholder: "Moves displayed on board for analysis",
              hidden: true,
            }),
            m("input[type=number]#displayready", {
              placeholder: "Board display update ready status",
              hidden: true,
            }),
            m("input[type=number]#isreviewmode", {
              placeholder: "Stores value to judge whether it is in review mode",
              hidden: true,
            }),
            m("input#gameresult", {
              placeholder: "The game result",
              hidden: true,
              onclick: () => {
                displayGameResult();
              },
            }),
            m(
              "p#gamestatus",
              {
                hidden: true,
              },
              "END",
            ),
            m("input#engineoutputline", { hidden: true }),
            m("input[type=number]#timeoutside", {
              placeholder: "Stores value that the side that run out of time",
              hidden: true,
            }),
            m(
              "p#set",
              {
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  play_move = false;
                  //console.log(Error());
                  window.setTimeout(() => {
                    setFen(false, true);
                  }, 10);
                },
                hidden: true,
              },
              "Set position (internal)",
            ),
            m(
              "p#loadthemes",
              {
                hidden: true,
                onclick: () => {
                  LoadThemes();
                  LoadVariantSettings("server", null);
                  LoadUIThemes();
                },
              },
              "Load Themes (internal)",
            ),
            m(
              "p#initializethemes",
              {
                hidden: true,
                onclick: () => {
                  setupThemeDropdowns();
                  changePieces(true);
                  changeBoard(true);
                },
              },
              "Initialize Themes (internal)",
            ),
            m(
              "p#setupuithemes",
              {
                hidden: true,
                onclick: () => {
                  setupUIThemeDropdown();
                  changeUI(
                    $("#dropdown-uitheme")[$("#dropdown-uitheme").selectedIndex]
                      .value,
                  );
                },
              },
              "Initialize UI Themes (internal)",
            ),
            m(
              "p#copysetfen",
              {
                hidden: true,
                onclick: () => {
                  copyText($("#fen").value);
                },
              },
              "Copy Set FEN (internal)",
            ),
            m(
              "p#randommovergo",
              {
                hidden: true,
              },
              "Random Mover Go (internal)",
            ),
            m(
              "p#binengineoutputinit",
              {
                hidden: true,
                onclick: () => {
                  if (fge.first_engine) {
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      document.getElementById(
                        "whiteengineoutput",
                      ).textContent += first_engine_output;
                      first_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.first_engine.OutputUpdateCallBack = (color, msg) => {
                      first_engine_output += "â—€â—€ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.first_engine.SendMessageCallBack = (msg) => {
                      first_engine_output += "\nâ–¶â–¶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.first_engine.OnErrorMessageCallBack = (msg) => {
                      if (during_play) {
                        window.alert(msg);
                      }
                    };
                  }
                  if (fge.second_engine) {
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      document.getElementById(
                        "blackengineoutput",
                      ).textContent += second_engine_output;
                      second_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.second_engine.OutputUpdateCallBack = (color, msg) => {
                      second_engine_output += "â—€â—€ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.second_engine.SendMessageCallBack = (msg) => {
                      second_engine_output += "\nâ–¶â–¶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.second_engine.OnErrorMessageCallBack = (msg) => {
                      if (during_play) {
                        window.alert(msg);
                      }
                    };
                  }
                  if (fge.analysis_engine) {
                    const OutputUpdateThrottleFunction = Throttle(() => {
                      document.getElementById(
                        "analysisengineoutput",
                      ).textContent += analysis_engine_output;
                      analysis_engine_output = "";
                      scrollOutput();
                    }, throttle_threshold);
                    fge.analysis_engine.OutputUpdateCallBack = (color, msg) => {
                      analysis_engine_output += "â—€â—€ " + msg + "\n";
                      OutputUpdateThrottleFunction();
                    };
                    fge.analysis_engine.EvaluationUpdateCallBack = (msg) => {
                      document.getElementById("engineoutputline").value = msg;
                      document.getElementById("engineoutputline").click();
                    };
                    fge.analysis_engine.SendMessageCallBack = (msg) => {
                      analysis_engine_output += "\nâ–¶â–¶ " + msg + "\n\n";
                      OutputUpdateThrottleFunction();
                    };
                  }
                  scrollOutput();
                },
              },
              "Binary Engine Output Event Handler Initialization (internal)",
            ),
          ]),
          m("div#input3", { hidden: during_play }, [
            m("p", "Additional Features: "),
            m(
              "label#label-advtimectrl",
              {
                title:
                  "When checked, advanced timing system is used to play time controlled games.",
              },
              m("input[type=checkbox]#advtimectrl", {
                checked: advanced_time_control,
                disabled: analysis_mode || review_mode || board_setup_mode,
                onclick: () => {
                  advanced_time_control = !advanced_time_control;
                },
              }),
              "Advanced Time Control",
            ),
            m(
              "label#label-boardsetup",
              {
                title:
                  "When checked, the board will enter setup mode where you can edit the position. Uncheck to exit this mode.",
              },
              m("input[type=checkbox]#isboardsetup", {
                checked: board_setup_mode,
                disabled:
                  analysis_mode ||
                  review_mode ||
                  advanced_time_control ||
                  select_move_dialog,
                onclick: () => {
                  board_setup_mode = !board_setup_mode;
                },
              }),
              "Board Setup",
            ),
          ]),
          m(
            "div#advancedtimesettings",
            { hidden: !advanced_time_control || during_play },
            [
              m("div#whitetimesettings", [
                m("p", "White Time Settings:  "),
                m(
                  "select#dropdown-whitetimemode",
                  {
                    disabled: !is_ready || review_mode,
                    title: "The time control mode for first mover (white).",
                    onchange: () => {
                      $("#whitetimetype").innerHTML = $(
                        "#dropdown-whitetimemode",
                      ).value;
                      white_timer_type = $("#dropdown-whitetimemode").value;
                    },
                  },
                  [
                    m(
                      "option",
                      {
                        value: "infinite",
                        title: "First mover has infinite time",
                      },
                      "Infinite",
                    ),
                    m(
                      "option",
                      {
                        value: "tournament",
                        title:
                          "First mover's time is limited and they can get time increment after every move.",
                      },
                      "Tournament",
                    ),
                    m(
                      "option",
                      {
                        value: "time per move",
                        title:
                          "First mover must make every move within a fixed time limit.",
                      },
                      "Time Per Move",
                    ),
                    m(
                      "option",
                      {
                        value: "hourglass",
                        title:
                          "First mover's time is limited and their used time on making a move will be added to second mover.",
                      },
                      "Hourglass",
                    ),
                    m(
                      "option",
                      {
                        value: "byoyomi",
                        title:
                          "(See [Why can I choose different time modes for two sides?] for more details on this mode)",
                      },
                      "Byo-yomi",
                    ),
                  ],
                ),
                m("input[type=number]#whitestarttime", {
                  placeholder: "Start time (ms)",
                  title: "The time at beginning in milliseconds.",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#whitetimegain", {
                  placeholder: "Time gain (ms)",
                  title:
                    "Get a time increment in milliseconds after every move.",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    white_timer_type != "tournament",
                  hidden: white_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#whitebyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  title:
                    "The duration in milliseconds of every byoyomi period.",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitebyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  title: "The count of byoyomi periods.",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitetimemargin", {
                  placeholder: "Timeout margin (ms)",
                  title:
                    "The time can be exceeded by this many milliseconds before running out of time.",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#blacktimesettings", [
                m("p", "Black Time Settings:  "),
                m(
                  "select#dropdown-blacktimemode",
                  {
                    disabled: !is_ready || review_mode,
                    title: "The time control mode for second mover (black).",
                    onchange: () => {
                      $("#blacktimetype").innerHTML = $(
                        "#dropdown-blacktimemode",
                      ).value;
                      black_timer_type = $("#dropdown-blacktimemode").value;
                    },
                  },
                  [
                    m(
                      "option",
                      {
                        value: "infinite",
                        title: "Second mover has infinite time",
                      },
                      "Infinite",
                    ),
                    m(
                      "option",
                      {
                        value: "tournament",
                        title:
                          "Second mover's time is limited and they can get time increment after every move.",
                      },
                      "Tournament",
                    ),
                    m(
                      "option",
                      {
                        value: "time per move",
                        title:
                          "Second mover must make every move within a fixed time limit.",
                      },
                      "Time Per Move",
                    ),
                    m(
                      "option",
                      {
                        value: "hourglass",
                        title:
                          "Second mover's time is limited and their used time on making a move will be added to first mover.",
                      },
                      "Hourglass",
                    ),
                    m(
                      "option",
                      {
                        value: "byoyomi",
                        title:
                          "(See [Why can I choose different time modes for two sides?] for more details on this mode)",
                      },
                      "Byo-yomi",
                    ),
                  ],
                ),
                m("input[type=number]#blackstarttime", {
                  placeholder: "Start time (ms)",
                  title: "The time at beginning in milliseconds.",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#blacktimegain", {
                  placeholder: "Time gain (ms)",
                  title:
                    "Get a time increment in milliseconds after every move.",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    black_timer_type != "tournament",
                  hidden: black_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#blackbyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  title:
                    "The duration in milliseconds of every byoyomi period.",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blackbyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  title: "The count of byoyomi periods.",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blacktimemargin", {
                  placeholder: "Timeout margin (ms)",
                  title:
                    "The time can be exceeded by this many milliseconds before running out of time.",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#gamecontrol-start", [
                m(
                  "button#gamestart",
                  {
                    disabled: !is_ready || review_mode,
                    title: "Click to start a game in advanced timing system.",
                    onclick: goWithTimeControl,
                  },
                  "Start Game",
                ),
                m(
                  "p",
                  {
                    style: "cursor: pointer;",
                    onclick: () => {
                      alert(
                        'This time control system allows user select different time modes for two sides and gives user more choice on time odds settings.\nThe time modes are:\nInfinite: Selected side has infinite time.\nTournament: Selected side has limited time and may get a time increment after a move.\nTime per move: Selected side need to make each move within a fixed time limit.\nHourglass: Selected side has limited time and used time will be added to opponent\'s time.\nByo-yomi: Selected side will enter the countdown(byoyomi) period(s) after their initial time runs out. During countdown periods, if the player make a move before the countdown period time runs out, the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"), otherwise the remaining period count will be decreased by 1 and the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"). If there\'s no countdown periods (Specified in "Byoyomi period count") left and the remaining time runs out, this side runs out of time.\nNote: if you set engine\'s time mode to infinite, it will think forever!',
                      );
                    },
                  },
                  "[Why can I choose different time modes for two sides?]",
                ),
                m(
                  "p",
                  {
                    style: "cursor: pointer;",
                    onclick: () => {
                      alert(
                        "Start time: The initial time (in milliseconds) at the beginning of the game. Not applicable to infinite.\nTime gain: Get a time increment of this many milliseconds after every move. Only applicable to tournament.\nByoyomi period length: The time (in milliseconds) of each period when in extra countdown(byoyomi) periods. Only applicable to byo-yomi.\nByoyomi period count: The count of countdown(byoyomi) periods. Only applicable to byo-yomi.\nTimeout margin: The time can be exceeded by this many milliseconds. The remaining time will be shown as minus numbers if exceeded. Not applicable to infinite.",
                      );
                    },
                  },
                  "  [What are these parameters?]",
                ),
              ]),
            ],
          ),
          m("div#gamesettings", [
            m("p", {}, "Quick promote/demote: "),
            m(
              "select#dropdown-quickpromotion",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                title:
                  "Select an option to make the promotion or demotion automatically if available.",
              },
              [
                m("option", { value: "" }, "<DISABLED>"),
                m("option", { value: "a" }, "a"),
                m("option", { value: "b" }, "b"),
                m("option", { value: "c" }, "c"),
                m("option", { value: "d" }, "d"),
                m("option", { value: "e" }, "e"),
                m("option", { value: "f" }, "f"),
                m("option", { value: "g" }, "g"),
                m("option", { value: "h" }, "h"),
                m("option", { value: "i" }, "i"),
                m("option", { value: "j" }, "j"),
                m("option", { value: "k" }, "k"),
                m("option", { value: "l" }, "l"),
                m("option", { value: "m" }, "m"),
                m("option", { value: "n" }, "n"),
                m("option", { value: "o" }, "o"),
                m("option", { value: "p" }, "p"),
                m("option", { value: "q" }, "q"),
                m("option", { value: "r" }, "r"),
                m("option", { value: "s" }, "s"),
                m("option", { value: "t" }, "t"),
                m("option", { value: "u" }, "u"),
                m("option", { value: "v" }, "v"),
                m("option", { value: "w" }, "w"),
                m("option", { value: "x" }, "x"),
                m("option", { value: "y" }, "y"),
                m("option", { value: "z" }, "z"),
                m("option", { value: "+" }, "Promote (+)"),
                m("option", { value: "-" }, "Demote (-)"),
                m("option", { value: "=" }, "Keep (=)"),
              ],
            ),
            m(
              "label",
              {
                title:
                  "When checked, you can also make a move by clicking the piece and then clicking the target square.",
              },
              m("input[type=checkbox]#clickclickmove", {
                disabled: review_mode,
              }),
              "Click-click move",
            ),
            m(
              "button#passmove",
              { disabled: !is_ready, title: "Click to pass your turn." },
              "ðŸ”„Pass This Turn",
            ),
            m(
              "button#placewall",
              {
                disabled: !is_ready,
                title:
                  "Click to place a wall only (Requires entering choice in prompt dialog).",
              },
              "ðŸ…¿ï¸Place A Wall",
            ),
            m("p", "Fog Of War:"),
            m(
              "select#dropdown-fogofwarsettings",
              {
                disabled: !is_ready || board_setup_mode,
                title:
                  "Fog of war is a visual effect that can prevent a player from seeing unreachable squares except wall squares.",
              },
              [
                m("option", { value: "<DISABLED>" }, "<DISABLED>"),
                m("option", { value: "whiteonly" }, "White's View"),
                m("option", { value: "blackonly" }, "Black's View"),
                m("option", { value: "alternate" }, "View Alternately"),
              ],
            ),
            m(
              "label#label-showmovediv",
              m("input[type=checkbox]#showmovediv", {
                checked: select_move_dialog,
                disabled: review_mode || board_setup_mode,
                onclick: () => {
                  select_move_dialog = !select_move_dialog;
                },
              }),
              "Show moves dialog",
            ),
            m(
              "span",
              {
                style: "cursor: pointer;",
                onclick: () =>
                  window.alert(
                    "If you cannot make your move on the board (For example, ATAXX drops), you can open this dialog to make the move.",
                  ),
              },
              "[?]",
            ),
            m(
              "span",
              {
                style: "cursor: pointer; margin-left: 5px;",
                onclick: () =>
                  window.alert(
                    "A null move is considered as a move that have the same original square and destination square. Double click a square (No matter whether it's empty or not) will make a null move on that square.\nNote:\n1. In most cases passing a turn is equivalent to making a null move on the king.\n2. In Atlantis variant, placing a wall without moving any piece requires to make a null move on the most bottom then the most left piece of your color.\n3. Click <show moves dialog> to see all legal moves if you are not sure how to make a move.",
                  ),
              },
              "[How to make null moves?]",
            ),
          ]),
          m("div#boardsetupsettings", { hidden: !board_setup_mode }, [
            m("p", "Board Setup:"),
            m("div#boardpiecechange", { disabled: !is_ready }, [
              m(
                "select#dropdown-setpiece",
                {
                  title:
                    "<move>: Move the pieces on the board.\n<delete>: Click on a square to delete the piece on that square.\n<letter>: Click on a square to place a piece of that letter. If there is a plus ahead, it means the promoted from.",
                },
                [
                  m("option", { value: "<move>" }, "<move>"),
                  m("option", { value: "<delete>" }, "<delete>"),
                  m("option", { value: "b" }, "b"),
                  m("option", { value: "k" }, "k"),
                  m("option", { value: "n" }, "n"),
                  m("option", { value: "p" }, "p"),
                  m("option", { value: "q" }, "q"),
                  m("option", { value: "r" }, "r"),
                  m("option", { value: "B" }, "B"),
                  m("option", { value: "K" }, "K"),
                  m("option", { value: "N" }, "N"),
                  m("option", { value: "P" }, "P"),
                  m("option", { value: "Q" }, "Q"),
                  m("option", { value: "R" }, "R"),
                ],
              ),
              m(
                "button#addtopocket",
                {
                  disabled: !is_ready,
                  title:
                    "Click to add the piece selected in the dropdown to pocket.",
                },
                "Add piece to pocket",
              ),
              m(
                "button#clearboard",
                { disabled: !is_ready, title: "Click to remove all pieces." },
                "Clear Board",
              ),
              m(
                "button#initboardpos",
                {
                  disabled: !is_ready,
                  title: "Click to set the board to default position.",
                },
                "Reset Board",
              ),
              m(
                "button#validatepos",
                {
                  disabled: !is_ready,
                  title: "Click to validate this position.",
                },
                "Validate Position",
              ),
              m(
                "button#boardsetupcopyfen",
                {
                  disabled: !is_ready,
                  title:
                    "Click to set the position, and then uncheck Board Setup to play or analyze.",
                },
                "Apply",
              ),
            ]),
            m("div#pocketpiecechange", { hidden: true }, [
              m("form#pieceinpocket", { disabled: !is_ready }, [
                m("table#tablepieceinpocket", [
                  m("tr", [m("td", "Piece ID"), m("td", "Amount")]),
                ]),
              ]),
            ]),
          ]),
          m("div#outputs", [
            m("div", [
              m("div#chessground-container-div.defaultboard.default.board8x8", [
                m("div.cg-wrap.pocket-top", [m("div#pocket-top")]),
                m("div#chessground-board"),
                m("div.cg-wrap.pocket-bottom", [m("div#pocket-bottom")]),
              ]),
              m("div#boardsetupsettings2", { hidden: !board_setup_mode }, [
                m("div", [
                  m("p", "Side to move:"),
                  m(
                    "select#dropdown-sidetomove",
                    { title: "Select the side to move in this position." },
                    [
                      m("option", { value: "First Mover" }, "First Mover"),
                      m("option", { value: "Second Mover" }, "Second Mover"),
                    ],
                  ),
                ]),
                m("div", [
                  m(
                    "label",
                    {
                      title:
                        "Check if first mover has the right to castle kingside.",
                    },
                    m("input[type=checkbox]#whitekingsidecastle"),
                    "White O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if first mover has the right to castle queenside.",
                    },
                    m("input[type=checkbox]#whitequeensidecastle"),
                    "White O-O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if second mover has the right to castle kingside.",
                    },
                    m("input[type=checkbox]#blackkingsidecastle"),
                    "Black O-O",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "Check if second mover has the right to castle queenside.",
                    },
                    m("input[type=checkbox]#blackqueensidecastle"),
                    "Black O-O-O",
                  ),
                ]),
                m("div", [
                  m("input[type=number]#halfmoveclock", {
                    placeholder: "Half move clock",
                    title:
                      "The number in half move clock, which records the moves that does not capture or is not irreversible for N-move rule.",
                    min: 0,
                  }),
                  m("input[type=number]#whiteremainingchecks", {
                    placeholder: "White remaining checks",
                    title:
                      "The remaining checks of first mover, used in variants that limit check count such as 3 Check.",
                    min: 1,
                  }),
                  m("input[type=number]#blackremainingchecks", {
                    placeholder: "Black remaining checks",
                    title:
                      "The remaining checks of second mover, used in variants that limit check count such as 3 Check.",
                    min: 1,
                  }),
                  m("input[type=number]#currentmovenum", {
                    placeholder: "Current move number",
                    title:
                      "The number of current move in full move format (A turn that both player make a move is 1 full move, 2 half moves).",
                    min: 1,
                  }),
                ]),
                m("div", [
                  m("input[type=number]#enpassantfile", {
                    placeholder: "En passant file number",
                    title: "The file (column) number of en passant square.",
                    min: 1,
                    max: 12,
                  }),
                  m("input[type=number]#enpassantrank", {
                    placeholder: "En passant rank number",
                    title: "The rank (row) number of en passant square.",
                    min: 1,
                    max: 10,
                  }),
                ]),
                m("div", [
                  m("input[type=text]#seirwangatingfiles", {
                    placeholder: "Seirawan gating files (e.g. ABab)",
                    title:
                      'The files (e.g. 1st column is a-file, 2nd column is b-file, etc.) where players can perform seirawan gating.\nGateable files for first mover is in upper case and for second mover in lower case.\nExample: "ABcd" means first mover can gate at A and B file while second mover can gate at C and D file.',
                    maxlength: 9999,
                  }),
                ]),
              ]),
              m("div#movecontrol", { hidden: during_play }, [
                m(
                  "button#initialposition",
                  {
                    onclick: displayInitialPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the initial position of current game.",
                  },
                  "â®Initial Position",
                ),
                m(
                  "button#currentposition",
                  {
                    onclick: displayCurrentPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the latest position of current game.",
                  },
                  "â­Current Position",
                ),
                m(
                  "button#previousposition",
                  {
                    onclick: displayPreviousMove,
                    disabled: !is_ready,
                    title:
                      "Click to display previous position of the displayed position.",
                  },
                  "âªPrevious Position",
                ),
                m(
                  "button#nextposition",
                  {
                    onclick: displayNextMove,
                    disabled: !is_ready,
                    title:
                      "Click to display next position of the displayed position.",
                  },
                  "â©Next Position",
                ),
                m("input[type=number]#gotomovenum", {
                  placeholder: "Half Move Number",
                  disabled: !is_ready,
                  title:
                    "The half number to the half move to display (A turn that both player make a move is 1 full move, 2 half moves).",
                  min: 0,
                }),
                m(
                  "button#specifiedposition",
                  {
                    onclick: displaySpecifiedPosition,
                    disabled: !is_ready,
                    title:
                      "Click to display the position that the half move specified in the input box is moved.",
                  },
                  "â†©ï¸Go to Move",
                ),
              ]),
              m("p", { hidden: !review_mode }, "Review mode enabled."),
              m(
                "p",
                { hidden: !review_mode },
                "You can go to previous moves played to analyze your game, but you cannot make changes to the game. To exit review mode, click <reset> or <current position>.",
              ),
              m("div#controls", [
                m("div", [
                  m(
                    "button",
                    {
                      onclick: () => {
                        changePieces(false);
                      },
                    },
                    "Change pieces",
                  ),
                  m(
                    "select#dropdown-piecetheme",
                    {
                      onchange: () => {
                        changePieceSet(
                          $("#dropdown-piecetheme")[
                            $("#dropdown-piecetheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [
                      m("option", { value: "default" }, "Default Pieces"),
                      m(
                        "option",
                        { value: "userdefined" },
                        getThemeName("userdefined"),
                      ),
                    ],
                  ),
                  m(
                    "button",
                    {
                      onclick: () => {
                        changeBoard(false);
                      },
                    },
                    "Change board",
                  ),
                  m(
                    "select#dropdown-boardtheme",
                    {
                      onchange: () => {
                        changeBoardSet(
                          $("#dropdown-boardtheme")[
                            $("#dropdown-boardtheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [m("option", { value: "defaultboard" }, "Default Board")],
                  ),
                  m("button#button-flip", "ðŸ”ƒFlip Board"),
                  m(
                    "button",
                    {
                      onclick: () => {
                        let time = Date.now();
                        if (time - previouschangeuitime < 750) {
                          return;
                        }
                        previouschangeuitime = time;
                        const uithemesdropdown =
                          document.getElementById("dropdown-uitheme");
                        changeUI(
                          uithemesdropdown[
                            (uithemesdropdown.selectedIndex + 1) %
                              uithemesdropdown.length
                          ].value,
                        );
                      },
                    },
                    "Change UI",
                  ),
                  m(
                    "select#dropdown-uitheme",
                    {
                      onchange: () => {
                        changeUI(
                          $("#dropdown-uitheme")[
                            $("#dropdown-uitheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [m("option", { value: "defaultui" }, "Default UI")],
                  ),
                ]),
                m("div", [
                  m(
                    "input[type=range]#range-volume",
                    {
                      min: 0,
                      max: 1,
                      step: 0.05,
                      title: "Adjust sound volume here.",
                    },
                    "range",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "When checked, the legal moves of the selected piece are shown on the board.",
                    },
                    m("input[type=checkbox]#check-dests", {
                      checked: show_dests,
                      onclick: () => {
                        show_dests = !show_dests;
                      },
                    }),
                    "Show Legal Moves & Drops",
                  ),
                  m(
                    "label",
                    {
                      title:
                        "(Legacy) When checked, show the game result in PGN.",
                    },
                    m("input[type=checkbox]#check-adjudicate", {
                      checked: adjudicate,
                      onclick: () => {
                        adjudicate = !adjudicate;
                      },
                    }),
                    "Adjudicate",
                  ),
                ]),
              ]),
              m("div#links", [
                m("a[href='./index.html']", "play"),
                m("a[href='./advanced.html']", "advanced"),
                m("a[href='./resources.html']", "resources"),
                m("a[href='https://github.com/ianfab/fairyground']", "github"),
              ]),
            ]),
            m("div#info", [
              m(
                "select#sannotation",
                {
                  onchange: () => {
                    const dropdownnotation =
                      document.getElementById("sannotation");
                    const evalbar = document.getElementById("evalbar");
                    const evalbarprogress =
                      document.getElementById("evalbarprogress");
                    const cp = document.getElementById("cp");
                    if (dropdownnotation.selectedIndex < 0) {
                      evalbar.style.backgroundColor = "black";
                      evalbarprogress.style.backgroundColor = "white";
                      cp.style.color = "orange";
                      return;
                    }
                    const value =
                      dropdownnotation[dropdownnotation.selectedIndex].value;
                    if (/xiangqi|ucci/i.test(value)) {
                      evalbar.style.backgroundColor = "black";
                      evalbarprogress.style.backgroundColor = "red";
                      cp.style.color = "white";
                    } else if (/shogi|usi/i.test(value)) {
                      evalbar.style.backgroundColor = "white";
                      evalbarprogress.style.backgroundColor = "black";
                      cp.style.color = "orange";
                    } else if (/janggi/i.test(value)) {
                      evalbar.style.backgroundColor = "red";
                      evalbarprogress.style.backgroundColor = "blue";
                      cp.style.color = "white";
                    } else {
                      evalbar.style.backgroundColor = "black";
                      evalbarprogress.style.backgroundColor = "white";
                      cp.style.color = "orange";
                    }
                  },
                },
                [
                  m("option", { value: "" }, "--Select Notation System--"),
                  m(
                    "option",
                    { value: "DEFAULT" },
                    "Standard/Short Algebraic Notation Without Piece Type Omission (DEFAULT)",
                  ),
                  m(
                    "option",
                    { value: "SAN" },
                    "Standard/Short Algebraic Notation (SAN)",
                  ),
                  m(
                    "option",
                    { value: "LAN" },
                    "Long Algebraic Notation (LAN)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HOSKING" },
                    "Shogi Hosking Notation (SHOGI_HOSKING)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HODGES" },
                    "Shogi George Hodges Notation (SHOGI_HODGES)",
                  ),
                  m(
                    "option",
                    { value: "SHOGI_HODGES_NUMBER" },
                    "Shogi George Hodges Number-only Notation (SHOGI_HODGES_NUMBER)",
                  ),
                  m("option", { value: "JANGGI" }, "Janggi Notation (JANGGI)"),
                  m(
                    "option",
                    { value: "XIANGQI_WXF" },
                    "World Xiangqi Federation Notation (XIANGQI_WXF)",
                  ),
                  m(
                    "option",
                    { value: "THAI_SAN" },
                    "Thai Standard/Short Algebraic Notation (THAI_SAN)",
                  ),
                  m(
                    "option",
                    { value: "THAI_LAN" },
                    "Thai Long Algebraic Notation (THAI_LAN)",
                  ),
                  m(
                    "option",
                    { value: "FEN" },
                    "Forsythâ€“Edwards Notation (Fairy-Stockfish) (FEN)",
                  ),
                  m("option", { value: "PGN" }, "Portable Game Notation (PGN)"),
                  m(
                    "option",
                    { value: "EPD" },
                    "Extended Position Description (EPD)",
                  ),
                  m(
                    "option",
                    { value: "FEN+UCIMOVE" },
                    "Forsythâ€“Edwards Notation (Fairy-Stockfish) and UCI Moves (FEN+UCIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "FEN+USIMOVE" },
                    "Forsythâ€“Edwards Notation (Fairy-Stockfish) and USI Moves (FEN+USIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "FEN+UCCIMOVE" },
                    "Forsythâ€“Edwards Notation (Fairy-Stockfish) and UCCI (CECP) Moves (FEN+UCCIMOVE)",
                  ),
                  m(
                    "option",
                    { value: "SFEN+USIMOVE" },
                    "Shogi Forsythâ€“Edwards Notation and USI Moves (SFEN+USIMOVE)",
                  ),
                ],
              ),
              m("p#positioninfo", ""),
              m("div#timers", { hidden: !advanced_time_control }, [
                m("div#whitetimer", [
                  m("p", "White Time"),
                  m("p#whitetime", "--"),
                  m("p#whitetimetype", "infinite"),
                ]),
                m("div#blacktimer", [
                  m("p", "Black Time"),
                  m("p#blacktime", "--"),
                  m("p#blacktimetype", "infinite"),
                ]),
              ]),
              m(
                "div#timecontrolduringplay",
                { hidden: !advanced_time_control || !during_play },
                [
                  m(
                    "button#addtimeforwhite",
                    {
                      title:
                        "Add 10 seconds to the remaining time of first mover.",
                      onclick: () => {
                        white_remaining_time = +white_remaining_time + 10000;
                      },
                    },
                    "Add 10s for white",
                  ),
                  m(
                    "button#addtimeforblack",
                    {
                      title:
                        "Add 10 seconds to the remaining time of second mover.",
                      onclick: () => {
                        black_remaining_time = +black_remaining_time + 10000;
                      },
                    },
                    "Add 10s for black",
                  ),
                  m(
                    "button#gameabort",
                    {
                      title: "Exit current advanced timing system based game.",
                      onclick: () => {
                        if (confirm("Are you sure to abort the game?")) {
                          gameAbort();
                        }
                      },
                    },
                    "ABORT GAME",
                  ),
                ],
              ),
              m("div#evaluation", { hidden: !analysis_mode }, [
                m("div#evalbar", [m("p#cp", "0.00"), m("div#evalbarprogress")]),
                m("p#evalinfo", ""),
                m("p#pvinfo", ""),
              ]),
              m("p#currentboardfen"),
              m("p#label-pgn"),
              m("div#output2", { onupdate: scrollOutput }, [
                m("pre#fsfoutput", output2),
                m(
                  "pre#whiteengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with â–¶â–¶ are the messages sent to the engine.\nLines start with â—€â—€ are the messages received from the engine.\n\n",
                ),
                m(
                  "pre#blackengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with â–¶â–¶ are the messages sent to the engine.\nLines start with â—€â—€ are the messages received from the engine.\n\n",
                ),
                m(
                  "pre#analysisengineoutput",
                  { hidden: true },
                  "This is the console where you can see the message communication.\nLines start with â–¶â–¶ are the messages sent to the engine.\nLines start with â—€â—€ are the messages received from the engine.\n\n",
                ),
              ]),
              m("div#enginecmddiv", [
                m("input[type=text]#enginecmd", {
                  placeholder: "Send command to engine...",
                  title: "The command to send to the engine.",
                  maxlength: 9999,
                  disabled: !is_ready || during_play,
                  onkeyup: (e) => {
                    if (e.keyCode != 13) {
                      e.redraw = false;
                      return;
                    }
                    if (during_play) {
                      return;
                    }
                    sendCommandToEngine();
                  },
                }),
                m(
                  "select#targetengine",
                  {
                    title:
                      "Select the console of the engine. This is the target engine of the command sent, and the engine that sends the message above.",
                    onchange: () => {
                      let index = $("#targetengine").selectedIndex;
                      if (index == 0) {
                        document.getElementById("fsfoutput").hidden = false;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 1) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          false;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 2) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          false;
                        document.getElementById("analysisengineoutput").hidden =
                          true;
                      } else if (index == 3) {
                        document.getElementById("fsfoutput").hidden = true;
                        document.getElementById("whiteengineoutput").hidden =
                          true;
                        document.getElementById("blackengineoutput").hidden =
                          true;
                        document.getElementById("analysisengineoutput").hidden =
                          false;
                      }
                    },
                  },
                  [
                    m(
                      "option",
                      { value: "DEFAULT" },
                      "In browser Fairy-Stockfish",
                    ),
                    m("option", { value: "WHITE" }, "1st binary engine"),
                    m("option", { value: "BLACK" }, "2nd binary engine"),
                    m(
                      "option",
                      { value: "ANALYSIS" },
                      "Analysis binary engine",
                    ),
                  ],
                ),
                m(
                  "button#sendenginecmd",
                  {
                    disabled: during_play,
                    title: "Click to send the command.",
                    onclick: () => {
                      if (during_play) {
                        return;
                      }
                      sendCommandToEngine();
                    },
                  },
                  "SEND",
                ),
                m(
                  "label#label-clearlogonstartthinking",
                  {
                    title:
                      "When checked, automatically clear the console of the binary engine when it starts thinking.",
                  },
                  m("input[type=checkbox]#clearlogonstartthinking", {
                    disabled: !is_ready,
                    checked: clear_log,
                    onclick: () => {
                      clear_log = !clear_log;
                    },
                  }),
                  "Clear Log On Start Thinking",
                ),
                m(
                  "button",
                  {
                    title: "Click to clear the consoles of the binary engines.",
                    onclick: () => {
                      first_engine_output = "";
                      second_engine_output = "";
                      analysis_engine_output = "";
                      document.getElementById("whiteengineoutput").textContent =
                        "";
                      document.getElementById("blackengineoutput").textContent =
                        "";
                      document.getElementById(
                        "analysisengineoutput",
                      ).textContent = "";
                      scrollOutput();
                    },
                  },
                  "Clear Logs",
                ),
              ]),
            ]),
          ]),
          m("div#moveselectiondialog", { hidden: !select_move_dialog }, [
            m("div#moveslectdiv", [
              m("p", "Moves:"),
              m("select#availablemovelist", [
                m("option", { value: "" }, "--SELECT MOVE--"),
              ]),
              m("input[type=text]#movesearchfilter", {
                placeholder: "Search UCI move...",
                maxlength: 9999,
              }),
              m(
                "label#label-regexp1",
                m("input[type=checkbox]#regexp1", {
                  disabled: review_mode || board_setup_mode,
                }),
                "Regular Expression",
              ),
              m("button#searchmove", "Search Moves"),
            ]),
            m("div#movefilters", [
              m("p#searchresultinfo", "Click <Search Moves> to search!"),
              m("hr#separatorsearchresult"),
              m(
                "p",
                "Note: Click <Search Moves> to find available moves with filter. Leave the search field blank to find all moves. Click <Make Move> to make selected move. Click <Highlight Move> to show the move on the board. If you are in analysis mode, the highlighted move can be replaced by recommended move (Blue) and threat move (Red) and you need to highlight it again.",
              ),
              m(
                "p",
                "Check <Regular Expression> to search with regular expression, e.g. /[a-z]+/g",
              ),
              m("hr#separatormoveselectiondialog"),
              m("p", "Additional Search Restrictions:"),
              m("input[type=text]#origfilter", {
                placeholder:
                  "Original Square... (e.g. e2, leave empty to search all, useless for drops)",
                maxlength: 9999,
              }),
              m("input[type=text]#destfilter", {
                placeholder:
                  "Destination Square... (e.g. e4, leave empty to search all, effective on drops)",
                maxlength: 9999,
              }),
              m(
                "label#label-isdrop",
                m("input[type=checkbox]#isdrop", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include drops",
              ),
              m(
                "label#label-haswallgating",
                m("input[type=checkbox]#haswallgating", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include moves having wall gating",
              ),
              m(
                "label#label-haspiecechange",
                m("input[type=checkbox]#haspiecechange", {
                  disabled: review_mode || board_setup_mode,
                  checked: true,
                }),
                "Include moves having promotion/demotion or seirawan gating",
              ),
              m("button#makemove", "Make Move"),
              m("button#highlightmove", "Highlight Move (Yellow Marks)"),
            ]),
          ]),
        ]);
      };

      return { oninit, view };
    };

    if (!isSupported()) {
      window.alert(
        "Your browser is not supported. For more information, please take a look at https://github.com/hi-ogawa/Stockfish/wiki.",
      );
    } else {
      m.mount($("#root"), App);
    }
  </script>
</body>
