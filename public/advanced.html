<!doctype html>
<head>
  <meta charset="utf-8" />
  <title>Fairy-Stockfish playground</title>
  <!-- By curl https://data-url-maker-hiro18181.netlify.app/api/url/https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg -->
  <link
    rel="icon"
    href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+CiAgPGcgc3R5bGU9Im9wYWNpdHk6MTsgZmlsbDpub25lOyBmaWxsLW9wYWNpdHk6MTsgZmlsbC1ydWxlOmV2ZW5vZGQ7IHN0cm9rZTojMDAwMDAwOyBzdHJva2Utd2lkdGg6MS41OyBzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDsgc3Ryb2tlLWRhc2hhcnJheTpub25lOyBzdHJva2Utb3BhY2l0eToxOyI+CiAgICA8cGF0aAogICAgICBkPSJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4IgogICAgICBzdHlsZT0iZmlsbDojMDAwMDAwOyBzdHJva2U6IzAwMDAwMDsiIC8+CiAgICA8cGF0aAogICAgICBkPSJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMCIKICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDsgc3Ryb2tlOiMwMDAwMDA7IiAvPgogICAgPHBhdGgKICAgICAgZD0iTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHoiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHoiCiAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MykiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogIgogICAgICBzdHlsZT0iZmlsbDojZmZmZmZmOyBzdHJva2U6bm9uZTsiIC8+CiAgPC9nPgo8L3N2Zz4K"
  />
  <link rel="stylesheet" href="assets/chessground.css" />
  <link rel="stylesheet" href="assets/generated.css" />
  <link rel="stylesheet" href="assets/theme-backgrounds.css" />
  <link rel="stylesheet" href="assets/theme-default.css" />
  <base target="_blank" />
</head>

<!-- CSS -->

<style>
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0;
    font: inherit;
  }

  html,
  body,
  #root {
    height: 100%;
  }

  #root {
    font-size: 16px;
  }

  main {
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 10px;
  }

  #pagetitle {
    font-size: 40px;
    font-family: "Times New Roman", Times, serif, Arial;
    margin-bottom: 10px;
    font-style: oblique;
    font-weight: bold;
  }

  #input {
    display: flex;
    margin-bottom: 10px;
  }

  #input2 {
    display: flex;
    margin-bottom: 10px;
  }

  #gamesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #gamesettings button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-left: 6px;
    margin-right: 6px;
    cursor: pointer;
  }

  #input #fen {
    width: 50%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input #move {
    width: 10%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #movetime {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #depth {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #nodes {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #threads {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #hash {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input2 #multipv {
    width: 5%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #input button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #input2 button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #movecontrol button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    margin-top: 2px;
    cursor: pointer;
  }

  #movecontrol #gotomovenum {
    width: 45%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #controls button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 5px;
    cursor: pointer;
    margin-bottom: 5px;
  }

  #gamesettings #dropdown-quickpromotion {
    width: 120px;
    background: #eee;
    margin-left: 10px;
    margin-right: 10px;
  }

  #dropdown-boardtheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #dropdown-piecetheme {
    min-width: 100px;
    background: #eee;
    margin-right: 5px;
  }

  #misc {
    margin-bottom: 10px;
  }

  #outputs {
    display: flex;
    flex: 1 1 auto;
    margin-top: 10px;
    width: 100%;
    height: 50%;
  }

  #movecontrol {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #posvariantdiv {
    display: flex;
    margin-bottom: 10px;
  }

  #posvariantdiv #dropdown-variant {
    width: 150px;
    background: #eee;
  }

  #posvariantdiv #dropdown-posvarianttype {
    min-width: 120px;
    background: #eee;
    margin-left: 10px;
  }

  #posvariantdiv #dropdown-posvariantname {
    min-width: 120px;
    background: #eee;
    margin-left: 10px;
  }

  #posvariantdiv button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #controls {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #info {
    padding: 10px;
    margin-left: 20px;
    font-size: 16px;
    height: 600px;
  }

  #info #timecontrolduringplay {
    padding: 10px;
    margin-left: 20px;
    font-size: 16px;
  }

  #info #timecontrolduringplay button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #currentboardfen {
    height: 10%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #label-pgn {
    height: 20%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #output2 {
    height: 70%;
    border: 1px solid #ddd;
    padding: 10px;
    margin-left: 20px;
    overflow-x: scroll;
    overflow-y: scroll;
    box-shadow: inset 1px 1px 2px #eee;
    font-size: 16px;
  }

  #pocket-top {
    display: flex;
  }

  #pocket-bottom {
    display: flex;
  }

  #links a {
    margin: 20px;
    font-size: 20px;
    text-decoration: none;
  }

  #info #timers {
    width: 600px;
    height: 125px;
    border: 2px solid #eee;
    background-color: gray;
    overflow: hidden;
    margin-bottom: 5px;
  }

  #info #timers #whitetimer {
    float: left;
    width: 290px;
    height: 120px;
    border: 2px solid #000;
    color: black;
    background-color: white;
    text-align: center;
    overflow: hidden;
  }

  #info #timers #blacktimer {
    float: right;
    width: 290px;
    height: 120px;
    border: 2px solid #fff;
    color: white;
    background-color: black;
    text-align: center;
    overflow: hidden;
  }

  #info #enginecmddiv {
    display: flex;
    margin-bottom: 10px;
  }

  #info #enginecmddiv #enginecmd {
    width: 600px;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #info #enginecmddiv #sendenginecmd {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #blacktime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #whitetime {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 50px;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
  }

  #boardsetupsettings {
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange {
    display: flex;
    margin-bottom: 10px;
  }

  #boardsetupsettings #boardpiecechange #dropdown-setpiece {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings #boardpiecechange button {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    margin-right: 6px;
    cursor: pointer;
  }

  #boardsetupsettings2 {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  #boardsetupsettings2 #dropdown-sidetomove {
    width: 120px;
    background: #eee;
  }

  #boardsetupsettings2 #halfmoveclock {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #whiteremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #blackremainingchecks {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #currentmovenum {
    width: 25%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #enpassantfile {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #enpassantrank {
    width: 35%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #boardsetupsettings2 #seirwangatingfiles {
    width: 60%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-right: 0;
  }

  #advancedtimesettings {
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #whitetimesettings #dropdown-whitetimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #whitetimesettings #whitestarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #whitetimesettings #whitetimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #whitetimesettings #whitetimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #blacktimesettings #dropdown-blacktimemode {
    margin-left: 10px;
    width: 120px;
    background: #eee;
  }

  #advancedtimesettings #blacktimesettings #blackstarttime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
  }

  #advancedtimesettings #blacktimesettings #blacktimegain {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomitime {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #blacktimesettings #blacktimemargin {
    width: 15%;
    padding: 2px 0 2px 6px;
    border: 1px solid #ddd;
    border-left: 0;
  }

  #advancedtimesettings #gamecontrol-start {
    display: flex;
    margin-bottom: 10px;
  }

  #advancedtimesettings #gamecontrol-start #gamestart {
    display: inline-block;
    padding: 3px 6px 3px 6px;
    background: #888;
    color: #fff;
    font-weight: bold;
    font-size: 24px;
    margin-right: 6px;
    cursor: pointer;
  }

  #evalbar {
    width: 400px;
    height: 30px;
    overflow: hidden;
    border-radius: 10px;
    background-color: #111111;
    position: relative;
  }

  #evalbar #evalbarprogress {
    float: left;
    height: 100%;
    width: 50%;
    background-color: #eeeeee;
  }

  #evalbar #cp {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    color: orange;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    font-weight: bold;
    font-family: Arial, "Times New Roman", Georgia, Serif;
  }

  #evalinfo {
    white-space: pre-line;
  }

  #pvinfo {
    white-space: pre-line;
  }

  #timecontrolduringplay {
    margin-bottom: 5px;
  }

  #evaluation {
    margin-bottom: 10px;
  }

  spangameresult {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 10px;
    position: fixed;
    transition: 0.5s linear;
    font-weight: bold;
    font-family: "Times New Roman", Georgia, Serif, Arial;
    z-index: 2;
  }
</style>

<body>
  <div id="root"></div>
  <script src="bundle.js" defer></script>

  <!--iframe src="./themes.html" onload="this.before((this.contentDocument.body || this.contentDocument).children[0]); this.remove();"--><!--/iframe-->

  <!-- Javascript -->

  <script src="./lib/stockfish.js"></script>
  <script src="./lib/mithril.min.js"></script>
  <script>
    let themes = [[], [], []];
    let themenames = [[], []];
    const $ = (...args) => document.querySelector(...args);

    //Remove duplicated elements
    function uniqArr(arr) {
      var newArr = new Set(arr);
      return Array.from(newArr);
    }

    function getFileFromServer(url, doneCallback, errorCallback) {
      var xhr;
      function handleStateChange() {
        if (xhr.readyState === 4) {
          doneCallback(xhr.status == 200 ? xhr.responseText : null);
        }
      }
      xhr = new XMLHttpRequest();
      xhr.onreadystatechange = handleStateChange;
      xhr.onerror = errorCallback;
      xhr.open("GET", url, true);
      xhr.send();
    }

    function setVariantStylesheet(variant) {
      document.getElementById("current-variant-stylesheet").href =
        `./assets/theme-variant-${variant}.css`;
    }

    const copyText = async (val) => {
      if (navigator.clipboard && navigator.permissions) {
        await navigator.clipboard.writeText(val);
      } else {
        const textArea = document.createElement("textArea");
        textArea.value = val;
        textArea.style.width = 0;
        textArea.style.position = "fixed";
        textArea.style.left = "-999px";
        textArea.style.top = "10px";
        textArea.setAttribute("readonly", "readonly");
        document.body.appendChild(textArea);

        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
      }
    };

    const formatMB = (n) => {
      return (n ? (n / 1e6).toPrecision(3) : "?") + "MB";
    };

    const isSupported = () => {
      if (typeof WebAssembly !== "object") return false;
      const source = Uint8Array.from([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 7, 8,
        1, 4, 116, 101, 115, 116, 0, 0, 10, 15, 1, 13, 0, 65, 0, 253, 17, 65, 0,
        253, 17, 253, 186, 1, 11,
      ]);
      if (
        typeof WebAssembly.validate !== "function" ||
        !WebAssembly.validate(source)
      )
        return false;
      if (typeof Atomics !== "object") return false;
      if (typeof SharedArrayBuffer !== "function") {
        console.log("SharedArrayBuffer not enabled!");
        return false;
      }
      if (typeof FileReader === "undefined") {
        return false;
      }
      return true;
    };

    const RequestProgress = ({ attrs: { url, onFinishDownload } }) => {
      let state = "INIT"; // 'LOADING', 'DONE', 'FAILED'
      let loaded = 0;
      let total = 0;

      const oninit = () => {
        state = "LOADING";
        m.request({
          url: url,
          method: "GET",
          responseType: "arraybuffer",
          headers: { Accept: "*/*" },
          config: (xhr) => {
            xhr.onprogress = (e) => {
              // TODO:
              // When gzip compressed, the value of "loaded/total" gets messed up.
              // On Chrome, "loaded" is the value after decompression, but on the other hand,
              // On Firefox, "loaded" is the value before decompression.
              loaded = e.loaded;
              total =
                e.total ||
                Number(
                  e.target.getResponseHeader("x-decompressed-content-length"),
                );
              m.redraw();
            };
          },
        }).then(
          (response) => {
            state = "DONE";
            onFinishDownload(response);
          },
          (e) => {
            console.error(e);
            state = "FAILED";
            onFinishDownload(null);
          },
        );
      };

      const view = () => {
        const fraction =
          total == -1 ? `?MB/?MB` : `${formatMB(loaded)}/${formatMB(total)}`;
        return m("span", [
          `${fraction} [${state}] `,
          m(
            "span",
            {
              style: "cursor: pointer;",
              onclick: () =>
                window.alert(
                  "On some browsers, download size might look contradictory due to file compression.",
                ),
            },
            "[?]",
          ),
        ]);
      };

      return { oninit, view };
    };

    const LoadThemes = () => {
      themes = [[], [], []];
      themenames = [[], []];
      function StartLoad(data, namedata) {
        if (typeof data == "string") {
          data = data.replace(/\r\n/g, "\n");
          data = data.replace(/\r/g, "\n");
          let rawText = data.split("\n");
          console.log("theme data:", rawText);
          let i = 0;
          let j = 0;
          let css_name = "";
          let index = 0;
          let require_list = [];
          let themesettings = [];
          let apply_to_all_list = [];
          let loaded_css_list = [];
          let require_board_list = [];
          let board_apply_to_all_list = [];
          let themeavailable = [];
          let boardthemeavailable = [];
          let link = null;
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 3) {
              console.warn(`At line ${i} in themes.txt: Bad syntax\n`);
              continue;
            }
            themeavailable = themesettings[1].split(",");
            boardthemeavailable = themesettings[2].split(",");
            if (themeavailable.length == 1 && themeavailable[0] == "") {
              themeavailable = [];
            }
            if (
              boardthemeavailable.length == 1 &&
              boardthemeavailable[0] == ""
            ) {
              boardthemeavailable = [];
            }
            if (
              (themesettings[1].length < 1 && themesettings[2].length < 1) ||
              themeavailable.includes("") ||
              boardthemeavailable.includes("")
            ) {
              console.warn(
                `At line ${i} in themes.txt: Piece and Board style names must not be both null or contain null element\n`,
              );
              continue;
            }
            if (themesettings[1].length > 0) {
              require_list = themeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              themeavailable = themeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_list.length; j++) {
                if (themes[0].includes(require_list[j].substring(1))) {
                  index = themes[0].indexOf(require_list[j].substring(1));
                  themeavailable = themeavailable.concat(themes[1][index]);
                } else {
                  console.warn(
                    `At line ${i} in themes.txt: Variant ${require_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              themeavailable = uniqArr(themeavailable);
            }
            if (themesettings[2].length > 0) {
              require_board_list = boardthemeavailable.filter((element) => {
                return element.charAt(0) == "@";
              });
              boardthemeavailable = boardthemeavailable.filter((element) => {
                return element.charAt(0) != "@";
              });
              for (j = 0; j < require_board_list.length; j++) {
                if (themes[0].includes(require_board_list[j].substring(1))) {
                  index = themes[0].indexOf(require_board_list[j].substring(1));
                  boardthemeavailable = boardthemeavailable.concat(
                    themes[2][index],
                  );
                } else {
                  console.warn(
                    `At line ${i} in themes.txt: Variant ${require_board_list[
                      j
                    ].substring(
                      1,
                    )} has not been defined yet. You need to put it before this line.\n`,
                  );
                }
              }
              boardthemeavailable = uniqArr(boardthemeavailable);
            }
            if (themesettings[0] == "*") {
              if (themesettings[1].length > 0) {
                apply_to_all_list = apply_to_all_list.concat(themeavailable);
              }
              if (themesettings[2].length > 0) {
                board_apply_to_all_list =
                  board_apply_to_all_list.concat(boardthemeavailable);
              }
            } else if (themes[0].includes(themesettings[0])) {
              if (themesettings[1].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[1][index] = uniqArr(
                  themes[1][index].concat(themeavailable),
                );
              }
              if (themesettings[2].length > 0) {
                index = themes[0].indexOf(themesettings[0]);
                themes[2][index] = uniqArr(
                  themes[2][index].concat(boardthemeavailable),
                );
              }
            } else {
              themeavailable = uniqArr(
                themeavailable.concat(apply_to_all_list),
              );
              boardthemeavailable = uniqArr(
                boardthemeavailable.concat(board_apply_to_all_list),
              );
              themes[0].push(themesettings[0]);
              themes[1].push(themeavailable);
              themes[2].push(boardthemeavailable);
            }
          }
          for (i = 0; i < themes[0].length; i++) {
            for (j = 0; j < themes[1][i].length; j++) {
              css_name = "theme-piece-" + themes[1][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
            for (j = 0; j < themes[2][i].length; j++) {
              css_name = "theme-board-" + themes[2][i][j];
              if (loaded_css_list.includes(css_name)) {
                continue;
              }
              loaded_css_list.push(css_name);
              link = document.createElement("link");
              link.setAttribute("rel", "stylesheet");
              link.setAttribute("href", "./assets/" + css_name + ".css");
              document.head.appendChild(link);
            }
          }

          // Needs to be after piece and board stylesheets to override them.
          css_name = "theme-variant-";
          if (!loaded_css_list.includes(css_name)) {
            loaded_css_list.push(css_name);
            link = document.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("href", "./assets/" + css_name + ".css");
            link.setAttribute("id", "current-variant-stylesheet");
            document.head.appendChild(link);
          }

          console.log(themes);
        } else {
          console.error(`Bad data type from themes.txt: ${typeof data}`);
        }

        if (typeof namedata == "string") {
          namedata = namedata.replace(/\r\n/g, "\n");
          namedata = namedata.replace(/\r/g, "\n");
          rawText = namedata.split("\n");
          console.log("theme name:", rawText);
          for (i = 0; i < rawText.length; i++) {
            if (rawText[i].length < 1 || rawText[i].charAt(0) == "#") {
              continue;
            }
            themesettings = rawText[i].trim().split("|");
            if (themesettings.length != 2) {
              console.warn(`At line ${i} in themename.txt: Bad syntax\n`);
              continue;
            }
            themenames[0].push(themesettings[0]);
            themenames[1].push(themesettings[1]);
          }

          console.log(themenames);
        } else {
          console.error(`Bad data type from themename.txt: ${typeof namedata}`);
        }
      }
      this.getFileFromServer("./themes.txt", (res) => {
        console.log("res:", res);
        this.getFileFromServer(
          "./themenames.txt",
          (res2) => {
            console.log("res2:", res2);
            StartLoad(res, res2);
          },
          () => {
            console.warn("themes.txt load failed.");
            this.getFileFromServer("./themenames.txt", (res2) => {
              console.log("res2:", res2);
              StartLoad("", res2);
            });
          },
        );
      });
    };

    function getThemeName(themeid) {
      if (typeof themeid != "string") {
        return null;
      }
      let index = themenames[0].indexOf(themeid);
      if (index < 0) {
        return themeid + " ⚠";
      } else {
        return themenames[1][index];
      }
    }

    const App = () => {
      let stockfish = null;
      let stockfish_state = "INIT"; // 'READY', 'FAILED'
      let output2 = "";
      let show_dests = true;
      let adjudicate = true;
      let analysis_mode = false;
      let play_white = false;
      let play_black = false;
      let play_move = false;
      let review_mode = false;
      let board_setup_mode = false;
      let advanced_time_control = false;
      let during_play = false;
      let white_remaining_time = 0;
      let black_remaining_time = 0;
      let white_moving_time_list = [];
      let black_moving_time_list = [];
      let white_time_gain = 0;
      let black_time_gain = 0;
      let white_timer_type = "infinite";
      let black_timer_type = "infinite";
      let timer_interval = 100;
      let white_byoyomi_time_per_period = 0;
      let black_byoyomi_time_per_period = 0;
      let white_byoyomi_period_count = 0;
      let black_byoyomi_period_count = 0;
      let white_remaining_byoyomi_periods = 0;
      let black_remaining_byoyomi_periods = 0;
      let white_time_margin = 0;
      let black_time_margin = 0;
      let timeout_margin = 500;
      let previous_mover = "";
      let timer;

      let variants = [];

      const getVariants = () => {
        stockfish.postMessage(`uci`);
      };

      const setVariant = () => {
        play_move = false;
        stop();
        const variant = $("#dropdown-variant").value;
        stockfish.postMessage(`setoption name UCI_Variant value ${variant}`);
        stockfish.postMessage(`position startpos`);
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();

        setVariantStylesheet(variant);
      };

      const setFen = () => {
        stop();
        const fen = $("#fen").value;
        const moves = $("#move").value;

        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${moves}`);
        }
        const stm = $("#label-stm").innerText;
        if (
          stm != "undefined" &&
          (analysis_mode ||
            (play_white && stm == "white") ||
            (play_black && stm == "black"))
        )
          setTimeout(go(), 10);
      };

      const sendCommandToEngine = () => {
        let cmd = $("#enginecmd")
          .value.split(" ")
          .filter(function (item) {
            return item != null && item != undefined && item != "";
          });
        if (cmd[0] == "quit") {
          window.alert(
            "Cannot send this command: Quitting engine will cause the engine to not work.",
          );
          return;
        }
        if (cmd[0] == "position") {
          window.alert(
            "Cannot send this command: Setting position will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "flip") {
          window.alert(
            "Cannot send this command: Flipping the side will cause the UI's position and the engine's position to be different. Set the position in the \"Position\" section instead.",
          );
          return;
        }
        if (cmd[0] == "go") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "stop") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ucinewgame") {
          window.alert(
            "Cannot send this command: Perform this action in the UI instead.",
          );
          return;
        }
        if (cmd[0] == "ponderhit") {
          window.alert(
            "Cannot send this command: Fairyground does not allow engine pondering.",
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          cmd[2] == "VariantPath"
        ) {
          window.alert(
            'Cannot send this command: To select variants.ini, select the ini file by clicking the "Select File" button of variants.ini at the top of the page.',
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          cmd[2] == "SyzygyPath"
        ) {
          window.alert(
            "Cannot send this command: Syzygy tablebase files cannot be accessed by setting value here, as the engine is running in WASM binary in the browser and web browsers do not allow accessing client's files without consent.",
          );
          return;
        }
        if (
          cmd[0] == "setoption" &&
          cmd[1] == "name" &&
          cmd[2] == "UCI_Variant"
        ) {
          window.alert(
            "Cannot send this command: To change the variant, select the items in the variants dropdown.",
          );
          return;
        }
        if (cmd[0] == "setoption" && cmd[1] == "name" && cmd[2] == "Ponder") {
          window.alert(
            "Cannot send this command: Setting this value manually does not make sense.",
          );
          return;
        }
        if (cmd[0] == "usi") {
          window.alert(
            "Cannot send this command: Fairyground only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucci") {
          window.alert(
            "Cannot send this command: Fairyground only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "xboard") {
          window.alert(
            "Cannot send this command: Fairyground only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "ucicyclone") {
          window.alert(
            "Cannot send this command: Fairyground only accepts UCI protocol.",
          );
          return;
        }
        if (cmd[0] == "uci") {
          window.alert(
            "Cannot send this command: This will reset engine status leaving UI status unchanged.",
          );
          return;
        }
        stockfish.postMessage($("#enginecmd").value);
      };

      const totalMoveNumber = () => {
        let listlength = 0;
        let i = 0;
        moves_split = $("#move").value.split(" ");
        for (i = 0; i < moves_split.length; i++) {
          if (moves_split[i].length == 0) {
            continue;
          }
          listlength++;
        }
        return listlength;
      };

      const displayMove = (movenum, is_force_stop) => {
        if (
          $("#displayready").value.length > 0 &&
          $("#displayready").value > 0
        ) {
          //$("#displayready").value = 0, displayMove() is ready
          return;
        }
        $("#displayready").value = 2; //2 = displayMove() working
        let i = 0;
        let j = 0;
        moves_split = $("#move").value.split(" ");
        if (movenum == -1) {
          if (is_force_stop) {
            force_stop();
          } else {
            stop();
          }
          $("#displaymoves").value = $("#move").value;
          review_mode = false;
          $("#isreviewmode").value = 0;
        } else if (movenum > totalMoveNumber() || movenum < -1) {
          console.log(`${movenum} is out of range for move number.`);
          return;
        } else {
          if (is_force_stop) {
            force_stop();
          } else {
            stop();
          }
          review_mode = true;
          $("#isreviewmode").value = 1;
          $("#displaymoves").value = "";
          for (i = 0, j = 0; j < movenum; i++, j++) {
            if (moves_split[i].length == 0) {
              j--;
              continue;
            }
            $("#displaymoves").value = $("#displaymoves").value.concat(
              moves_split[i],
            );
            if (j < movenum - 1) {
              $("#displaymoves").value = $("#displaymoves").value.concat(" ");
            }
          }
        }
        const fen = $("#fen").value;
        const display_moves = $("#displaymoves").value;
        if (fen.length > 0) {
          stockfish.postMessage(`position fen ${fen} moves ${display_moves}`);
        } else {
          stockfish.postMessage(`position startpos moves ${display_moves}`);
        }
        console.log(`${display_moves}`);
        $("#displayready").value = 1; //1 = updateChessBoardToPosition() working
      };

      const displayNextMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value < 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value >= totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value++;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true);
      };

      const displayPreviousMove = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        } else {
          if ($("#gotomovenum").value <= 0) {
            $("#gotomovenum").value = 0;
          } else if ($("#gotomovenum").value > totalMoveNumber()) {
            $("#gotomovenum").value = totalMoveNumber();
          } else {
            $("#gotomovenum").value--;
          }
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true);
      };

      const displayInitialPosition = () => {
        $("#gotomovenum").value = 0;
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove(0, true);
      };

      const displayCurrentPosition = () => {
        $("#gotomovenum").value = totalMoveNumber();
        console.log(`Current: ${!during_play}`);
        displayMove(-1, !during_play);
      };

      const displaySpecifiedPosition = () => {
        if ($("#gotomovenum").value.length <= 0) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#gotomovenum").value < 0) {
          $("#gotomovenum").value = 0;
        } else if ($("#gotomovenum").value > totalMoveNumber()) {
          $("#gotomovenum").value = totalMoveNumber();
        }
        if ($("#advtimectrl").checked == true) {
          $("#advtimectrl").click();
        }
        displayMove($("#gotomovenum").value, true);
      };

      const reset = () => {
        review_mode = false;
        board_setup_mode = false;
        $("#fen").value = "";
        $("#move").value = "";
        resetTimer();
        setFen();
        $("#currentposition").click();
      };

      const undo = () => {
        if (review_mode || board_setup_mode) {
          return;
        }
        const moves = $("#move").value;
        $("#move").value = moves.substring(0, moves.lastIndexOf(" "));
        resetTimer();
        setFen();
      };

      const go = () => {
        if (board_setup_mode) {
          return;
        }
        return_early = play_move;
        stop();
        console.log(`return early: ${return_early}`);
        if (return_early) return; // avoid race condition
        let args = "";
        const movetime = $("#movetime").value;
        const depth = $("#depth").value;
        const nodes = $("#nodes").value;
        const threadnum = $("#threads").value;
        const hashsize = $("#hash").value;
        const multipleprincipalvariation = $("#multipv").value;
        let wtime = 0;
        let btime = 0;
        let winc = 0;
        let binc = 0;
        if (analysis_mode) {
          args += " infinite";
        } else if (advanced_time_control) {
          if (
            white_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "white"
          ) {
            args += "infinite";
            console.log("wtime infinite");
          } else if (
            black_timer_type == "infinite" &&
            $("#label-stm").innerHTML == "black"
          ) {
            args += "infinite";
            console.log("btime infinite");
          } else {
            if (white_timer_type == "time per move") {
              wtime += +white_moving_time_list[0];
              winc += +white_moving_time_list[0];
            } else if (white_timer_type == "tournament") {
              wtime += +(+white_remaining_time + +white_time_gain);
              winc += +white_time_gain;
            } else if (white_timer_type == "hourglass") {
              //How to tell that it's hourglass to engine?
              wtime += +white_remaining_time;
            } else if (white_timer_type == "byoyomi") {
              wtime += +white_remaining_time;
              if (
                white_remaining_time < white_byoyomi_time_per_period &&
                white_remaining_byoyomi_periods > 0
              ) {
                winc += +white_byoyomi_time_per_period;
              }
            }
            if (black_timer_type == "time per move") {
              btime += +black_moving_time_list[0];
              binc += +black_moving_time_list[0];
            } else if (black_timer_type == "tournament") {
              btime += +(+black_remaining_time + +black_time_gain);
              binc = +black_time_gain;
            } else if (black_timer_type == "hourglass") {
              //How to tell that it's hourglass to engine?
              btime += +black_remaining_time;
            } else if (black_timer_type == "byoyomi") {
              btime += +black_remaining_time;
              if (
                black_remaining_time < black_byoyomi_time_per_period &&
                black_remaining_byoyomi_periods > 0
              ) {
                binc += +black_byoyomi_time_per_period;
              }
            }
            console.log(
              `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`,
            );
            args += `wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
            stockfish.postMessage(
              `setoption name Move Overhead value ${timer_interval}`,
            );
          }
        } else {
          if (!analysis_mode && $("#depth").validity.valid && depth > 0) {
            args += ` depth ${depth}`;
          }
          if (!analysis_mode && $("#movetime").validity.valid && movetime > 0) {
            args += ` movetime ${movetime}`;
          }
          if (!analysis_mode && $("#nodes").validity.valid && nodes > 0) {
            args += ` nodes ${nodes}`;
          }
        }

        if (threadnum.length <= 0 || threadnum < 1) {
          stockfish.postMessage(`setoption name Threads value 1`);
        } else if (threadnum > 512) {
          stockfish.postMessage(`setoption name Threads value 512`);
        } else {
          stockfish.postMessage(`setoption name Threads value ${threadnum}`);
        }
        stockfish.postMessage(`setoption name clear hash`);
        if (hashsize.length <= 0 || hashsize < 1) {
          stockfish.postMessage(`setoption name Hash value 16`);
        } else if (hashsize > 33554432) {
          stockfish.postMessage(`setoption name Hash value 33554432`);
        } else {
          stockfish.postMessage(`setoption name Hash value ${hashsize}`);
        }
        if (
          multipleprincipalvariation.length <= 0 ||
          multipleprincipalvariation < 1
        ) {
          stockfish.postMessage(`setoption name MultiPV value 1`);
        } else if (multipleprincipalvariation > 500) {
          stockfish.postMessage(`setoption name MultiPV value 500`);
        } else {
          stockfish.postMessage(
            `setoption name MultiPV value ${multipleprincipalvariation}`,
          );
        }
        stockfish.postMessage(`isready`);

        const stm = $("#label-stm").innerText;
        play_move =
          (play_white && stm == "white") || (play_black && stm == "black");
        stockfish.postMessage(`go ${args}`);
        output2 = "";
      };

      const setupTimer = () => {
        $("#timeoutside").value = 0;
        white_timer_type = $("#dropdown-whitetimemode").value;
        black_timer_type = $("#dropdown-blacktimemode").value;
        white_remaining_time = parseInt($("#whitestarttime").value);
        black_remaining_time = parseInt($("#blackstarttime").value);
        if (
          isNaN(white_remaining_time) ||
          white_remaining_time.length < 1 ||
          white_remaining_time < 1
        ) {
          white_remaining_time = play_white ? 20000 : 600000;
        }
        if (
          isNaN(black_remaining_time) ||
          black_remaining_time.length < 1 ||
          black_remaining_time < 1
        ) {
          black_remaining_time = play_black ? 20000 : 600000;
        }
        white_time_gain = parseInt($("#whitetimegain").value);
        black_time_gain = parseInt($("#blacktimegain").value);
        if (
          isNaN(white_time_gain) ||
          white_time_gain.length < 1 ||
          white_time_gain < 0
        ) {
          white_time_gain = 0;
        }
        if (
          isNaN(black_time_gain) ||
          black_time_gain.length < 1 ||
          black_time_gain < 0
        ) {
          black_time_gain = 0;
        }
        white_byoyomi_time_per_period = parseInt($("#whitebyoyomitime").value);
        black_byoyomi_time_per_period = parseInt($("#blackbyoyomitime").value);
        if (
          isNaN(white_byoyomi_time_per_period) ||
          white_byoyomi_time_per_period.length < 1 ||
          white_byoyomi_time_per_period < 1
        ) {
          white_byoyomi_time_per_period = 30000;
        }
        if (
          isNaN(black_byoyomi_time_per_period) ||
          black_byoyomi_time_per_period.length < 1 ||
          black_byoyomi_time_per_period < 1
        ) {
          black_byoyomi_time_per_period = 30000;
        }
        white_byoyomi_period_count = parseInt(
          $("#whitebyoyomiperiodcount").value,
        );
        black_byoyomi_period_count = parseInt(
          $("#blackbyoyomiperiodcount").value,
        );
        if (
          isNaN(white_byoyomi_period_count) ||
          white_byoyomi_period_count.length < 1 ||
          white_byoyomi_period_count < 1
        ) {
          white_byoyomi_period_count = 1;
        }
        if (
          isNaN(black_byoyomi_period_count) ||
          black_byoyomi_period_count.length < 1 ||
          black_byoyomi_period_count < 1
        ) {
          black_byoyomi_period_count = 1;
        }
        white_remaining_byoyomi_periods = white_byoyomi_period_count;
        black_remaining_byoyomi_periods = black_byoyomi_period_count;
        white_time_margin = parseInt($("#whitetimemargin").value);
        black_time_margin = parseInt($("#blacktimemargin").value);
        if (
          isNaN(white_time_margin) ||
          white_time_margin.length < 1 ||
          white_time_margin < 0
        ) {
          white_time_margin = timeout_margin;
        }
        if (
          isNaN(black_time_margin) ||
          black_time_margin.length < 1 ||
          black_time_margin < 0
        ) {
          black_time_margin = timeout_margin;
        }
        white_moving_time_list = [];
        black_moving_time_list = [];
        white_moving_time_list.push(white_remaining_time); //Start time white
        black_moving_time_list.push(black_remaining_time); //Start time black
        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
        if (white_timer_type == "infinite") {
          $("#whitetime").innerHTML = "∞";
        }
        if (black_timer_type == "infinite") {
          $("#blacktime").innerHTML = "∞";
        }
        previous_mover = "";
      };

      const resetTimer = () => {
        $("#whitetime").innerHTML = "--";
        $("#blacktime").innerHTML = "--";
        previous_mover = "";
        $("#timeoutside").value = 0;
      };

      function updateTimer() {
        if ($("#gamestatus").innerHTML == "END") {
          deleteTimer();
          gameEnd();
          return;
        }
        $("#gamestatus").click();
        console.log(`${$("#gamestatus").innerHTML}`);
        if ($("#gamestatus").innerHTML == "PLAYING_WHITE") {
          if (previous_mover == "") {
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            }
            white_moving_time_list.push(white_remaining_time); //Time stamp for white's turn begin
          } else if (previous_mover == "BLACK") {
            black_moving_time_list.push(black_remaining_time); //Time stamp for black's turn end
            if (black_remaining_time < 0) {
              black_remaining_time = 0;
            }
            if (white_timer_type == "tournament") {
              white_remaining_time =
                +white_remaining_time + +white_time_gain + +timer_interval;
            } else if (white_timer_type == "time per move") {
              white_remaining_time =
                +white_moving_time_list[0] + +timer_interval;
            } else if (white_timer_type == "byoyomi") {
              if (
                white_remaining_byoyomi_periods < white_byoyomi_period_count
              ) {
                white_remaining_time =
                  +white_byoyomi_time_per_period + +timer_interval;
              } else {
                white_remaining_time = +white_remaining_time + +timer_interval;
              }
            }
            if (black_timer_type == "hourglass") {
              white_remaining_time =
                +white_remaining_time +
                +black_moving_time_list.at(-2) -
                +black_moving_time_list.at(-1) +
                +timer_interval;
            }
            white_moving_time_list.push(white_remaining_time); //Time stamp for white's turn begin
          }
          if (white_timer_type == "infinite") {
            previous_mover = "WHITE";
            return;
          }
          white_remaining_time = white_remaining_time - timer_interval;
          if (white_timer_type == "byoyomi" && white_remaining_time <= 0) {
            if (white_remaining_byoyomi_periods == 0) {
            } else {
              white_remaining_byoyomi_periods--;
              white_remaining_time = +white_byoyomi_time_per_period;
              console.log(
                "WHITE byoyomi remaining periods: " +
                  white_remaining_byoyomi_periods,
              );
            }
          }
          if (white_remaining_time < -white_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 1;
            timeIsUpFor("WHITE");
            return;
          }
          if (white_timer_type == "infinite") {
            $("#whitetime").innerHTML = "∞";
          } else if (white_remaining_time >= 10000) {
            $("#whitetime").innerHTML = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            $("#whitetime").innerHTML = `${
              parseInt(Math.max(white_remaining_time, 0) / 100) / 10
            }`;
          }
          if (black_timer_type == "infinite") {
            $("#blacktime").innerHTML = "∞";
          } else if (black_remaining_time >= 10000) {
            $("#blacktime").innerHTML = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            $("#blacktime").innerHTML = `${
              parseInt(Math.max(black_remaining_time, 0) / 100) / 10
            }`;
          }
          if (white_timer_type == "byoyomi") {
            $("#whitetime").innerText +=
              ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            $("#blacktime").innerText +=
              ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "WHITE";
        } else if ($("#gamestatus").innerHTML == "PLAYING_BLACK") {
          if (previous_mover == "") {
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            }
            black_moving_time_list.push(black_remaining_time); //Time stamp for black's turn begin
          } else if (previous_mover == "WHITE") {
            white_moving_time_list.push(white_remaining_time); //Time stamp for white's turn end
            if (white_remaining_time < 0) {
              white_remaining_time = 0;
            }
            if (black_timer_type == "tournament") {
              black_remaining_time =
                +black_remaining_time + +black_time_gain + +timer_interval;
            } else if (black_timer_type == "time per move") {
              black_remaining_time =
                +black_moving_time_list[0] + +timer_interval;
            } else if (black_timer_type == "byoyomi") {
              if (
                black_remaining_byoyomi_periods < black_byoyomi_period_count
              ) {
                black_remaining_time =
                  +black_byoyomi_time_per_period + +timer_interval;
              } else {
                black_remaining_time = +black_remaining_time + +timer_interval;
              }
            }
            if (white_timer_type == "hourglass") {
              black_remaining_time =
                +black_remaining_time +
                +white_moving_time_list.at(-2) -
                +white_moving_time_list.at(-1) +
                +timer_interval;
            }
            black_moving_time_list.push(black_remaining_time); //Time stamp for black's turn begin
          }
          if (black_timer_type == "infinite") {
            previous_mover = "BLACK";
            return;
          }
          black_remaining_time = black_remaining_time - timer_interval;
          if (black_timer_type == "byoyomi" && black_remaining_time <= 0) {
            if (black_remaining_byoyomi_periods == 0) {
            } else {
              black_remaining_byoyomi_periods--;
              black_remaining_time = +black_byoyomi_time_per_period;
              console.log(
                "BLACK byoyomi remaining periods: " +
                  black_remaining_byoyomi_periods,
              );
            }
          }
          if (black_remaining_time < -black_time_margin) {
            deleteTimer();
            $("#timeoutside").value = 2;
            timeIsUpFor("BLACK");
            return;
          }
          if (white_timer_type == "infinite") {
            $("#whitetime").innerHTML = "∞";
          } else if (white_remaining_time >= 10000) {
            $("#whitetime").innerHTML = `${parseInt(
              white_remaining_time / 1000,
            )}`;
          } else {
            $("#whitetime").innerHTML = `${
              parseInt(Math.max(white_remaining_time, 0) / 100) / 10
            }`;
          }
          if (black_timer_type == "infinite") {
            $("#blacktime").innerHTML = "∞";
          } else if (black_remaining_time >= 10000) {
            $("#blacktime").innerHTML = `${parseInt(
              black_remaining_time / 1000,
            )}`;
          } else {
            $("#blacktime").innerHTML = `${
              parseInt(Math.max(black_remaining_time, 0) / 100) / 10
            }`;
          }
          if (white_timer_type == "byoyomi") {
            $("#whitetime").innerText +=
              ` (${white_remaining_byoyomi_periods})`;
          }
          if (black_timer_type == "byoyomi") {
            $("#blacktime").innerText +=
              ` (${black_remaining_byoyomi_periods})`;
          }
          previous_mover = "BLACK";
        }
      }

      const createTimer = () => {
        timer = setInterval(() => {
          updateTimer();
        }, timer_interval);
        console.log(`${timer}`);
      };

      const deleteTimer = () => {
        console.log("Timer delete!");
        clearInterval(timer);
      };

      const timeIsUpFor = (side) => {
        force_stop();
        if (side == "WHITE") {
          white_remaining_time = 0;
          $("#timeoutside").value = 1;
          $("#whitetime").innerHTML = "Out Of Time";
        } else if (side == "BLACK") {
          black_remaining_time = 0;
          $("#timeoutside").value = 2;
          $("#blacktime").innerHTML = "Out Of Time";
        }
        $("#gamestatus").click();
        gameEnd();
      };

      const gameEnd = () => {
        during_play = false;
        //advanced_time_control = false;
        force_stop();
        $("#currentposition").click();
        $("#input").style.display = "";
        $("#input2").style.display = "";
        $("#posvariantdiv").style.display = "";
      };

      const gameAbort = () => {
        deleteTimer();
        $("#gamestatus").innerHTML = "END";
        gameEnd();
      };

      const goWithTimeControl = () => {
        if ($("#gamestatus").innerHTML != "END") {
          return;
        }
        //We need to prevent user from doing unnecessary actions during countdown, so we'll hide these divs
        $("#input").style.display = "none"; //These divs are unable to be hidden by {hidden: during_play}
        $("#input2").style.display = "none";
        $("#posvariantdiv").style.display = "none";
        //$("#movecontrol").style.display = "none";
        resetTimer();
        setupTimer();
        $("#gamestatus").click();
        during_play = true;
        $("#currentposition").click();
        createTimer();
        const stm = $("#label-stm").innerText;
        console.log(
          `white: ${play_white} black: ${play_black} move: ${
            (play_white && stm == "white") || (play_black && stm == "black")
          }`,
        );
        if ((play_white && stm == "white") || (play_black && stm == "black")) {
          console.log("Go!");
          go();
        }
      };

      const stop = () => {
        stockfish.postMessage(`stop`);
      };

      const force_stop = () => {
        play_white = play_black = false;
        stop();
      };

      const changePieces = (onlyChangeWhenInvalid) => {
        let index = 0;
        let themename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          themename = "default";
        } else {
          classes = themes[1][index];
          if (classes.length < 1) {
            classes = themes[1][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[1]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change piece.");
              updateThemeDropdowns(DOMListValue[1], null);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          themename = classes[index];
        } else {
          themename = "default";
        }
        DOMListValue[1] = themename;
        el.classList.value = DOMListValue.join(" ");
        console.log(`Piece theme: ${themename}`);
        updateThemeDropdowns(themename, null);
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const changeBoard = (onlyChangeWhenInvalid) => {
        let index = 0;
        let boardthemename = "";
        let classes = [];
        let DOMListValue = "";
        const el = $("#chessground-container-div");
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          boardthemename = "defaultboard";
        } else {
          classes = themes[2][index];
          if (classes.length < 1) {
            classes = themes[2][themes[0].indexOf("")];
          }
        }
        DOMListValue = el.classList.value.split(" ");
        if (classes.length > 0) {
          index = classes.indexOf(DOMListValue[0]) + 1;
          if (onlyChangeWhenInvalid) {
            if (index != 0) {
              console.log("No need to change board.");
              updateThemeDropdowns(null, DOMListValue[0]);
              return;
            }
          }
          if (index >= classes.length) {
            index = 0;
          }
          boardthemename = classes[index];
        } else {
          boardthemename = "defaultboard";
        }
        DOMListValue[0] = boardthemename;
        el.classList.value = DOMListValue.join(" ");
        console.log(`Board theme: ${boardthemename}`);
        updateThemeDropdowns(null, boardthemename);
        //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
        //const nextIndex = (activeIndex + 1) % classes.length;
        //el.classList.replace(classes[activeIndex], classes[nextIndex]);
      };

      const setupThemeDropdowns = () => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        while (piecethemedropdown.options.length > 0) {
          piecethemedropdown.remove(0);
        }
        while (boardthemedropdown.options.length > 0) {
          boardthemedropdown.remove(0);
        }
        let index = 0;
        let piececlasses = [];
        let boardclasses = [];
        index = themes[0].indexOf($("#dropdown-variant").value);
        if (index < 0 || $("#dropdown-variant").value == "") {
          index = themes[0].indexOf("");
        }
        if (index < 0) {
          null;
        } else {
          piececlasses = themes[1][index];
          if (piececlasses.length < 1) {
            piececlasses = themes[1][themes[0].indexOf("")];
          }
          boardclasses = themes[2][index];
          if (boardclasses.length < 1) {
            boardclasses = themes[2][themes[0].indexOf("")];
          }
        }
        if (piececlasses.length > 0) {
          piececlasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            piecethemedropdown.add(newOption);
            console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Pieces";
          newOption.value = "default";
          piecethemedropdown.add(newOption);
          newOption = document.createElement("option");
          newOption.text = getThemeName("userdefined");
          newOption.value = "userdefined";
          piecethemedropdown.add(newOption);
        }
        if (boardclasses.length > 0) {
          boardclasses.forEach((val) => {
            let newOption = document.createElement("option");
            newOption.text = getThemeName(val);
            newOption.value = val;
            boardthemedropdown.add(newOption);
            console.log(val);
          });
        } else {
          let newOption = document.createElement("option");
          newOption.text = "Default Board";
          newOption.value = "defaultboard";
          boardthemedropdown.add(newOption);
        }
      };

      const updateThemeDropdowns = (piecethemeid, boardthemeid) => {
        let piecethemedropdown = $("#dropdown-piecetheme");
        let boardthemedropdown = $("#dropdown-boardtheme");
        let i = 0;
        if (piecethemeid) {
          for (i = 0; i < piecethemedropdown.options.length; i++) {
            if (piecethemedropdown[i].value == piecethemeid) {
              piecethemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == piecethemedropdown.options.length) {
            piecethemedropdown.selectedIndex = -1;
          }
        }
        if (boardthemeid) {
          for (i = 0; i < boardthemedropdown.options.length; i++) {
            if (boardthemedropdown[i].value == boardthemeid) {
              boardthemedropdown.selectedIndex = i;
              break;
            }
          }
          if (i == boardthemedropdown.options.length) {
            boardthemedropdown.selectedIndex = -1;
          }
        }
      };

      const scrollOutput = () => {
        $("#output2").scrollTo({
          top: $("#output2").scrollHeight,
          behavior: "smooth",
        });
      };

      const displayGameResult = () => {
        let i = 0;
        let chi = document.getElementsByTagName("spangameresult");
        for (i = 0; i < chi.length; i++) {
          document.body.removeChild(chi[i]);
        }
        if (review_mode) {
          return;
        }
        var span = document.createElement("spangameresult");
        span.innerHTML = $("#gameresult").value;
        span.style.left = window.innerWidth / 2 + "px";
        span.style.top = window.innerHeight / 2 + "px";
        setTimeout(function () {
          span.style.opacity = "1";
          span.style.transform = "scale(40)";
        }, 100);
        setTimeout(function () {
          span.style.opacity = "0";
          span.style.transform = "scale(0.02)";
        }, 2600);
        document.body.appendChild(span);
      };

      // Make error catchable
      const loadStockfish = async (params) => {
        return await Stockfish(params);
      };

      const onFinishDownload = (data) => {
        if (!data) {
          stockfish_state = "FAILED";
          m.redraw();
          return;
        }

        loadStockfish({ wasmBinary: data })
          .then((_stockfish) => {
            stockfish = _stockfish;
            stockfish_state = "READY";
            stockfish.addMessageListener((line) => {
              if (line.startsWith("option")) {
                if (line.startsWith("option name UCI_Variant")) {
                  variants = line
                    .replace(
                      "option name UCI_Variant type combo default chess var ",
                      "",
                    )
                    .replace(/ var /g, " ")
                    .split(" ");
                }
              } else if (line.startsWith(" ")) {
              } else {
                if (!review_mode && line.startsWith("bestmove") && play_move) {
                  play_move = false;
                  $("#move").value += " " + line.split(" ")[1];
                  $("#set").click();
                }
                output2 += line + "\n";
                $("#engineoutputline").value = line;
                $("#engineoutputline").click();
              }
              m.redraw();
            });
            getVariants();
          })
          .catch((e) => {
            stockfish_state = "FAILED";
            throw e;
          })
          .finally(() => m.redraw());
      };

      const onSelectNnueFile = async (e) => {
        const selected = e.currentTarget.files[0];
        if (selected) {
          //
          // TODO:
          // On Archlinux Chromium 92.0.4515.107, most of times this code fails with the error saying:
          //   TypeError: Failed to execute 'decode' on 'TextDecoder': The provided ArrayBufferView value must not be shared.
          // On the other hand, either Chrome with the same version or Firefox never fail.
          //
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`setoption name EvalFile value ${filename}`);
          // Automatically set variant
          const variant = selected.name.split(/[_.-]+/)[0];
          $("#dropdown-variant").value = variant;
          $("#dropdown-variant").dispatchEvent(new Event("change"));
        }
      };

      const onSelectVariantsFile = async (e) => {
        const selected = e.currentTarget.files[0];
        //console.log(`${selected}`);
        if (selected) {
          const FS = stockfish.FS;
          const buffer = await selected.arrayBuffer();
          const array = new Uint8Array(buffer);
          const filename = "/" + selected.name;
          FS.writeFile(filename, array);
          stockfish.postMessage(`check ${filename}`);
          stockfish.postMessage(`load ${filename}`);
          getVariants();
        }
      };

      function isLetter(str) {
        return str.length === 1 && str.match(/[a-z]/i);
      }

      function changePieceSet(piece_set) {
        const el = $("#chessground-container-div");
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[1] = piece_set;
        el.classList.value = DOMListValue.join(" ");
        updateThemeDropdowns(piece_set, null);
      }

      function changeBoardSet(board_set) {
        const el = $("#chessground-container-div");
        let DOMListValue = el.classList.value.split(" ");
        DOMListValue[0] = board_set;
        el.classList.value = DOMListValue.join(" ");
        updateThemeDropdowns(null, board_set);
      }

      const onSelectUserGraphics = async (e) => {
        var files_count = e.currentTarget.files.length;
        var files = [];

        if (!e.currentTarget.files.length) {
        } else {
          style = document.createElement("style");

          // See what files are being loaded.
          for (let i = 0; i < files_count; i++) {
            const selected = e.currentTarget.files[i];
            var filename = e.currentTarget.files[i].name.toLowerCase();

            files[files.length] = e.currentTarget.files[i];
          }

          console.log("File count: " + files.length);

          for (let i = 0; i < files.length; i++) {
            const selected = files[i];
            var bloburl = URL.createObjectURL(selected);
            var filename = files[i].name.split(".")[0].toLowerCase();
            var piececolor = filename.substr(0, 1);
            var pieceletter = filename.substr(1, 2).replace("+", "p");
            // Skip the file if it does not match the naming convention.
            if (piececolor == "b") {
              piececolor = "black";
            } else if (piececolor == "w") {
              piececolor = "white";
            } else {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length != 2 && filename.length != 3) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 2 && !isLetter(filename.substr(1, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && filename.substr(1, 1) != "+") {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            if (filename.length == 3 && !isLetter(filename.substr(2, 1))) {
              console.log(
                `File '${filename}' does not match naming convention.`,
              );
              continue;
            }
            //console.log(filename);
            //console.log(piececolor);
            //console.log(pieceletter);
            console.log(`${bloburl}`);
            //console.log(`${selected}`);
            if (selected) {
              style.textContent =
                style.textContent +
                `.userdefined .cg-wrap piece.${pieceletter}-piece.${piececolor} { background-image: url('${bloburl}');} `;
            }
          }

          //console.log(`${style.textContent}`);
          document.head.appendChild(style);

          changePieceSet("userdefined");
        }
      };

      const oninit = () => {
        stockfish_state = "LOADING";
      };

      const view = () => {
        const is_ready = stockfish_state == "READY";

        return m("main", [
          m("p#pagetitle", "Advanced analysis"),
          m("div#misc", { hidden: during_play }, [
            m("div", [
              `Fairy-Stockfish: ${stockfish_state} - download: `,
              m(RequestProgress, {
                url: "./lib/stockfish.wasm",
                onFinishDownload,
              }),
            ]),
            m("div", { hidden: during_play }, [
              "- nnue file: ",
              m("input", {
                type: "file",
                disabled: !is_ready,
                onchange: onSelectNnueFile,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload a Fairy-Stockfish compatible .nnue file. Downloads: https://fairy-stockfish.github.io/nnue/#current-best-nnue-networks.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- variants.ini: ",
              m("input#variants-ini", {
                type: "file",
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: onSelectVariantsFile,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload a Fairy-Stockfish compatible variants.ini file. See here for details: https://github.com/ianfab/Fairy-Stockfish/wiki/Variant-configuration.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- positionvariants.txt: ",
              m("input#posvariant-txt", {
                type: "file",
                disabled: !is_ready || review_mode || board_setup_mode,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can select a Position Variant file to load different positions for different variants. Contents will be appended to the position variants provided by the server.",
                    ),
                },
                "[?]",
              ),
            ]),
            m("div", { hidden: during_play }, [
              "- User Piece Graphics: ",
              m("input#user-graphics", {
                type: "file",
                multiple: true,
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: onSelectUserGraphics,
              }),
              m(
                "span",
                {
                  style: "cursor: pointer;",
                  onclick: () =>
                    window.alert(
                      "You can upload user defined piece graphics. They must be named as follows [piece colour][+][piece letter].svg.",
                    ),
                },
                "[?]",
              ),
            ]),
          ]),
          m("div#posvariantdiv", [
            m("p", "Variant:"),
            m(
              "select#dropdown-variant",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                onchange: (e) => {
                  window.setTimeout(setVariant, 10);
                },
              },
              [
                m("option", { value: "" }, "    (default)    "),
                ...variants.map((ex, index) => m("option", { value: ex }, ex)),
              ],
            ),
            m("p", "Custom Position Type:"),
            m(
              "select#dropdown-posvarianttype",
              {
                disabled: !is_ready || review_mode,
              },
              [m("option", { value: "(default)" }, "(default)")],
            ),
            m("p", "Custom Position Name:"),
            m(
              "select#dropdown-posvariantname",
              {
                disabled: !is_ready || review_mode,
              },
              [],
            ),
            m(
              "button#aboutposition",
              {
                disabled: !is_ready || review_mode,
              },
              "About this position",
            ),
          ]),
          m("div#input", { hidden: during_play }, [
            m("p", "Position:"),
            m("input#fen", {
              placeholder: "Input FEN Here",
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen();
              },
            }),
            m("input#move", {
              placeholder: "Input Move Here",
              disabled: !is_ready || review_mode,
              onkeyup: (e) => {
                if (e.keyCode != 13) {
                  e.redraw = false;
                  return;
                }
                setFen();
              },
            }),
            m(
              "button#setpos",
              {
                disabled: !is_ready || review_mode,
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  resetTimer();
                  window.setTimeout(setFen, 10);
                  $("#currentposition").click();
                },
              },
              "☑️Set",
            ),
            m(
              "button#reset",
              { disabled: !is_ready, onclick: reset },
              "⏏️Reset",
            ),
            m(
              "button#undo",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
                hidden: review_mode,
                onclick: undo,
              },
              "◀️Undo",
            ),
          ]),
          m("div#input2", { hidden: during_play }, [
            m("p", "Settings:"),
            m("input[type=number]#depth", {
              placeholder: "Depth",
              disabled: !is_ready || analysis_mode,
              min: 1,
              max: 255,
            }),
            m("input[type=number]#movetime", {
              placeholder: "Movetime",
              disabled: !is_ready || analysis_mode,
              min: 0,
            }),
            m("input[type=number]#nodes", {
              placeholder: "Nodes",
              disabled: !is_ready || analysis_mode,
              min: 1,
            }),
            m("input[type=number]#threads", {
              placeholder: "Threads",
              disabled: !is_ready,
              min: 1,
              max: 512,
            }),
            m("input[type=number]#hash", {
              placeholder: "Hash",
              disabled: !is_ready,
              min: 1,
              max: 33554432,
            }),
            m("input[type=number]#multipv", {
              placeholder: "MultiPV",
              disabled: !is_ready,
              min: 1,
              max: 500,
            }),
            m(
              "button#go",
              {
                disabled: !is_ready,
                onclick: () => {
                  if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                  }
                  go();
                },
              },
              "▶️Go",
            ),
            m(
              "button#stop",
              { disabled: !is_ready, onclick: force_stop },
              "⏹Stop",
            ),
            m(
              "label#label-analysis",
              m("input[type=checkbox]#analysis", {
                checked: analysis_mode,
                disabled:
                  play_white ||
                  play_black ||
                  advanced_time_control ||
                  board_setup_mode,
                onclick: () => {
                  analysis_mode = !analysis_mode;
                },
              }),
              "Analysis",
            ),
            m(
              "label",
              m("input[type=checkbox]#playwhite", {
                checked: play_white,
                disabled: analysis_mode || review_mode || board_setup_mode,
                onclick: () => {
                  play_white = !play_white;
                },
              }),
              "Engine white",
            ),
            m(
              "label",
              m("input[type=checkbox]#playblack", {
                checked: play_black,
                disabled: analysis_mode || review_mode || board_setup_mode,
                onclick: () => {
                  play_black = !play_black;
                },
              }),
              "Engine black",
            ),
            m(
              "label#label-advtimectrl",
              m("input[type=checkbox]#advtimectrl", {
                checked: advanced_time_control,
                disabled: analysis_mode || review_mode || board_setup_mode,
                onclick: () => {
                  advanced_time_control = !advanced_time_control;
                },
              }),
              "Advanced Time Control",
            ),
            m(
              "label#label-boardsetup",
              m("input[type=checkbox]#isboardsetup", {
                checked: board_setup_mode,
                disabled: analysis_mode || review_mode || advanced_time_control,
                onclick: () => {
                  board_setup_mode = !board_setup_mode;
                },
              }),
              "Board Setup",
            ),
            m("p#label-stm", { hidden: true }),
            m("input#displaymoves", {
              placeholder: "Moves displayed on board for analysis",
              hidden: true,
            }),
            m("input[type=number]#displayready", {
              placeholder: "Board display update ready status",
              hidden: true,
            }),
            m("input[type=number]#isreviewmode", {
              placeholder: "Stores value to judge whether it is in review mode",
              hidden: true,
            }),
            m("input#gameresult", {
              placeholder: "The game result",
              hidden: true,
              onclick: () => {
                displayGameResult();
              },
            }),
            m(
              "p#gamestatus",
              {
                hidden: true,
              },
              "END",
            ),
            m("input#engineoutputline", { hidden: true }),
            m("input[type=number]#timeoutside", {
              placeholder: "Stores value that the side that run out of time",
              hidden: true,
            }),
            m(
              "p#set",
              {
                onclick: () => {
                  if (review_mode) {
                    return;
                  }
                  window.setTimeout(setFen, 10);
                },
                hidden: true,
              },
              "Set position (internal)",
            ),
            m(
              "p#loadthemes",
              {
                hidden: true,
                onclick: () => {
                  LoadThemes();
                },
              },
              "Load Themes (internal)",
            ),
            m(
              "p#initializethemes",
              {
                hidden: true,
                onclick: () => {
                  setupThemeDropdowns();
                  changePieces(true);
                  changeBoard(true);
                },
              },
              "Initialize Themes (internal)",
            ),
            m(
              "p#copysetfen",
              {
                hidden: true,
                onclick: () => {
                  copyText($("#fen").value);
                },
              },
              "Copy Set FEN (internal)",
            ),
          ]),
          m(
            "div#advancedtimesettings",
            { hidden: !advanced_time_control || during_play },
            [
              m("div#whitetimesettings", [
                m("p", "White Time Settings:  "),
                m(
                  "select#dropdown-whitetimemode",
                  {
                    disabled: !is_ready || review_mode,
                    onchange: () => {
                      $("#whitetimetype").innerHTML = $(
                        "#dropdown-whitetimemode",
                      ).value;
                      white_timer_type = $("#dropdown-whitetimemode").value;
                    },
                  },
                  [
                    m("option", { value: "infinite" }, "Infinite"),
                    m("option", { value: "tournament" }, "Tournament"),
                    m("option", { value: "time per move" }, "Time Per Move"),
                    m("option", { value: "hourglass" }, "Hourglass"),
                    m("option", { value: "byoyomi" }, "Byo-yomi"),
                  ],
                ),
                m("input[type=number]#whitestarttime", {
                  placeholder: "Start time (ms)",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#whitetimegain", {
                  placeholder: "Time gain (ms)",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    white_timer_type != "tournament",
                  hidden: white_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#whitebyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitebyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  disabled:
                    !is_ready || review_mode || white_timer_type != "byoyomi",
                  hidden: white_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#whitetimemargin", {
                  placeholder: "Timeout margin (ms)",
                  disabled:
                    !is_ready || review_mode || white_timer_type == "infinite",
                  hidden: white_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#blacktimesettings", [
                m("p", "Black Time Settings:  "),
                m(
                  "select#dropdown-blacktimemode",
                  {
                    disabled: !is_ready || review_mode,
                    onchange: () => {
                      $("#blacktimetype").innerHTML = $(
                        "#dropdown-blacktimemode",
                      ).value;
                      black_timer_type = $("#dropdown-blacktimemode").value;
                    },
                  },
                  [
                    m("option", { value: "infinite" }, "Infinite"),
                    m("option", { value: "tournament" }, "Tournament"),
                    m("option", { value: "time per move" }, "Time Per Move"),
                    m("option", { value: "hourglass" }, "Hourglass"),
                    m("option", { value: "byoyomi" }, "Byo-yomi"),
                  ],
                ),
                m("input[type=number]#blackstarttime", {
                  placeholder: "Start time (ms)",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 1,
                }),
                m("input[type=number]#blacktimegain", {
                  placeholder: "Time gain (ms)",
                  disabled:
                    !is_ready ||
                    review_mode ||
                    black_timer_type != "tournament",
                  hidden: black_timer_type != "tournament",
                  min: 0,
                }),
                m("input[type=number]#blackbyoyomitime", {
                  placeholder: "Byoyomi period length (ms)",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blackbyoyomiperiodcount", {
                  placeholder: "Byoyomi period count",
                  disabled:
                    !is_ready || review_mode || black_timer_type != "byoyomi",
                  hidden: black_timer_type != "byoyomi",
                  min: 1,
                }),
                m("input[type=number]#blacktimemargin", {
                  placeholder: "Timeout margin (ms)",
                  disabled:
                    !is_ready || review_mode || black_timer_type == "infinite",
                  hidden: black_timer_type == "infinite",
                  min: 0,
                }),
              ]),
              m("div#gamecontrol-start", [
                m(
                  "button#gamestart",
                  {
                    disabled: !is_ready || review_mode,
                    onclick: goWithTimeControl,
                  },
                  "Start Game",
                ),
                m(
                  "p",
                  {
                    onclick: () => {
                      alert(
                        'This time control system allows user select different time modes for two sides and gives user more choice on time odds settings.\nThe time modes are:\nInfinite: Selected side has infinite time.\nTournament: Selected side has limited time and may get a time increment after a move.\nTime per move: Selected side need to make each move within a fixed time limit.\nHourglass: Selected side has limited time and used time will be added to opponent\'s time.\nByo-yomi: Selected side will enter the countdown(byoyomi) period(s) after their initial time runs out. During countdown periods, if the player make a move before the countdown period time runs out, the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"), otherwise the remaining period count will be decreased by 1 and the time will be reset to full time of countdown periods(Specified in "Byoyomi period length"). If there\'s no countdown periods (Specified in "Byoyomi period count") left and the remaining time runs out, this side runs out of time.\nNote: if you set engine\'s time mode to infinite, it will think forever!',
                      );
                    },
                  },
                  "[Why can I choose different time modes for two sides?]",
                ),
                m(
                  "p",
                  {
                    onclick: () => {
                      alert(
                        "Start time: The initial time (in milliseconds) at the beginning of the game. Not applicable to infinite.\nTime gain: Get a time increment of this many milliseconds after every move. Only applicable to tournament.\nByoyomi period length: The time (in milliseconds) of each period when in extra countdown(byoyomi) periods. Only applicable to byo-yomi.\nByoyomi period count: The count of countdown(byoyomi) periods. Only applicable to byo-yomi.\nTimeout margin: The time can be exceeded by this many milliseconds. The remaining time will be shown as minus numbers if exceeded. Not applicable to infinite.",
                      );
                    },
                  },
                  "  [What are these parameters?]",
                ),
              ]),
            ],
          ),
          m("div#gamesettings", [
            m("p", {}, "Quick promote/demote to piece: "),
            m(
              "select#dropdown-quickpromotion",
              {
                disabled: !is_ready || review_mode || board_setup_mode,
              },
              [
                m("option", { value: "" }, "<DISABLED>"),
                m("option", { value: "a" }, "a"),
                m("option", { value: "b" }, "b"),
                m("option", { value: "c" }, "c"),
                m("option", { value: "d" }, "d"),
                m("option", { value: "e" }, "e"),
                m("option", { value: "f" }, "f"),
                m("option", { value: "g" }, "g"),
                m("option", { value: "h" }, "h"),
                m("option", { value: "i" }, "i"),
                m("option", { value: "j" }, "j"),
                m("option", { value: "k" }, "k"),
                m("option", { value: "l" }, "l"),
                m("option", { value: "m" }, "m"),
                m("option", { value: "n" }, "n"),
                m("option", { value: "o" }, "o"),
                m("option", { value: "p" }, "p"),
                m("option", { value: "q" }, "q"),
                m("option", { value: "r" }, "r"),
                m("option", { value: "s" }, "s"),
                m("option", { value: "t" }, "t"),
                m("option", { value: "u" }, "u"),
                m("option", { value: "v" }, "v"),
                m("option", { value: "w" }, "w"),
                m("option", { value: "x" }, "x"),
                m("option", { value: "y" }, "y"),
                m("option", { value: "z" }, "z"),
                m("option", { value: "+" }, "Promote (+)"),
                m("option", { value: "-" }, "Demote (-)"),
                m("option", { value: "=" }, "Keep (=)"),
              ],
            ),
            m(
              "label",
              m("input[type=checkbox]#clickclickmove", {
                disabled: review_mode,
              }),
              "Click-click move",
            ),
            m("button#passmove", { disabled: !is_ready }, "🔄Pass This Turn"),
          ]),
          m("div#boardsetupsettings", { hidden: !board_setup_mode }, [
            m("p", "Board Setup:"),
            m("div#boardpiecechange", { disabled: !is_ready }, [
              m("select#dropdown-setpiece", [
                m("option", { value: "<move>" }, "<move>"),
                m("option", { value: "<delete>" }, "<delete>"),
                m("option", { value: "b" }, "b"),
                m("option", { value: "k" }, "k"),
                m("option", { value: "n" }, "n"),
                m("option", { value: "p" }, "p"),
                m("option", { value: "q" }, "q"),
                m("option", { value: "r" }, "r"),
                m("option", { value: "B" }, "B"),
                m("option", { value: "K" }, "K"),
                m("option", { value: "N" }, "N"),
                m("option", { value: "P" }, "P"),
                m("option", { value: "Q" }, "Q"),
                m("option", { value: "R" }, "R"),
              ]),
              m(
                "button#addtopocket",
                { disabled: !is_ready },
                "Add piece to pocket",
              ),
              m("button#clearboard", { disabled: !is_ready }, "Clear Board"),
              m("button#initboardpos", { disabled: !is_ready }, "Reset Board"),
              m(
                "button#validatepos",
                { disabled: !is_ready },
                "Validate Position",
              ),
              m("button#boardsetupcopyfen", { disabled: !is_ready }, "Apply"),
            ]),
            m("div#pocketpiecechange", { hidden: true }, [
              m("form#pieceinpocket", { disabled: !is_ready }, [
                m("table#tablepieceinpocket", [
                  m("tr", [m("td", "Piece ID"), m("td", "Amount")]),
                ]),
              ]),
            ]),
          ]),
          m("div#outputs", [
            m("div", [
              m("div#chessground-container-div.defaultboard.default.board8x8", [
                m("div.cg-wrap.pocket-top", [m("div#pocket-top")]),
                m("div#chessground-board"),
                m("div.cg-wrap.pocket-bottom", [m("div#pocket-bottom")]),
              ]),
              m("div#boardsetupsettings2", { hidden: !board_setup_mode }, [
                m("div", [
                  m("p", "Side to move:"),
                  m("select#dropdown-sidetomove", [
                    m("option", { value: "white/red/sente" }, "First Mover"),
                    m("option", { value: "black/black/gote" }, "Second Mover"),
                  ]),
                ]),
                m("div", [
                  m(
                    "label",
                    m("input[type=checkbox]#whitekingsidecastle"),
                    "White O-O",
                  ),
                  m(
                    "label",
                    m("input[type=checkbox]#whitequeensidecastle"),
                    "White O-O-O",
                  ),
                  m(
                    "label",
                    m("input[type=checkbox]#blackkingsidecastle"),
                    "Black O-O",
                  ),
                  m(
                    "label",
                    m("input[type=checkbox]#blackqueensidecastle"),
                    "Black O-O-O",
                  ),
                ]),
                m("div", [
                  m("input[type=number]#halfmoveclock", {
                    placeholder: "Half move clock",
                    min: 0,
                  }),
                  m("input[type=number]#whiteremainingchecks", {
                    placeholder: "White remaining checks",
                    min: 0,
                  }),
                  m("input[type=number]#blackremainingchecks", {
                    placeholder: "Black remaining checks",
                    min: 0,
                  }),
                  m("input[type=number]#currentmovenum", {
                    placeholder: "Current move number",
                    min: 1,
                  }),
                ]),
                m("div", [
                  m("input[type=number]#enpassantfile", {
                    placeholder: "En passant file number",
                    min: 1,
                  }),
                  m("input[type=number]#enpassantrank", {
                    placeholder: "En passant rank number",
                    min: 1,
                  }),
                ]),
                m("div", [
                  m("input#seirwangatingfiles", {
                    placeholder: "Seirawan gating files (e.g. ABab)",
                  }),
                ]),
              ]),
              m("div#movecontrol", { hidden: during_play }, [
                m(
                  "button#initialposition",
                  { onclick: displayInitialPosition, disabled: !is_ready },
                  "⏮Initial Position",
                ),
                m(
                  "button#currentposition",
                  { onclick: displayCurrentPosition, disabled: !is_ready },
                  "⏭Current Position",
                ),
                m(
                  "button#previousposition",
                  { onclick: displayPreviousMove, disabled: !is_ready },
                  "⏪Previous Position",
                ),
                m(
                  "button#nextposition",
                  { onclick: displayNextMove, disabled: !is_ready },
                  "⏩Next Position",
                ),
                m("input[type=number]#gotomovenum", {
                  placeholder: "Half Move Number",
                  disabled: !is_ready,
                  min: 0,
                }),
                m(
                  "button#specifiedposition",
                  { onclick: displaySpecifiedPosition, disabled: !is_ready },
                  "↩️Go to Move",
                ),
              ]),
              m("p", { hidden: !review_mode }, "Review mode enabled."),
              m(
                "p",
                { hidden: !review_mode },
                "You can go to previous moves played to analyze your game, but you cannot make changes to the game. To exit review mode, click <reset> or <current position>.",
              ),
              m("div#controls", [
                m("div", [
                  m(
                    "button",
                    {
                      onclick: () => {
                        changePieces(false);
                      },
                    },
                    "Change pieces",
                  ),
                  m(
                    "select#dropdown-piecetheme",
                    {
                      onchange: () => {
                        changePieceSet(
                          $("#dropdown-piecetheme")[
                            $("#dropdown-piecetheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [
                      m("option", { value: "default" }, "Default Pieces"),
                      m(
                        "option",
                        { value: "userdefined" },
                        getThemeName("userdefined"),
                      ),
                    ],
                  ),
                  m(
                    "button",
                    {
                      onclick: () => {
                        changeBoard(false);
                      },
                    },
                    "Change board",
                  ),
                  m(
                    "select#dropdown-boardtheme",
                    {
                      onchange: () => {
                        changeBoardSet(
                          $("#dropdown-boardtheme")[
                            $("#dropdown-boardtheme").selectedIndex
                          ].value,
                        );
                      },
                    },
                    [m("option", { value: "defaultboard" }, "Default Board")],
                  ),
                  m("button#button-flip", "🔃Flip Board"),
                ]),
                m("div", [
                  m(
                    "input[type=range]#range-volume",
                    { min: 0, max: 1, step: 0.05 },
                    "range",
                  ),
                  m(
                    "label",
                    m("input[type=checkbox]#check-dests", {
                      checked: show_dests,
                      onclick: () => {
                        show_dests = !show_dests;
                      },
                    }),
                    "Show Legal Moves & Drops",
                  ),
                  m(
                    "label",
                    m("input[type=checkbox]#check-adjudicate", {
                      checked: adjudicate,
                      onclick: () => {
                        adjudicate = !adjudicate;
                      },
                    }),
                    "Adjudicate",
                  ),
                ]),
              ]),
              m("div#links", [
                m("a[href='./index.html']", "play"),
                m("a[href='./advanced.html']", "advanced"),
                m("a[href='https://github.com/ianfab/fairyground']", "github"),
              ]),
            ]),
            m("div#info", [
              m("p#positioninfo", ""),
              m("div#timers", { hidden: !advanced_time_control }, [
                m("div#whitetimer", [
                  m("p", "White Time"),
                  m("p#whitetime", "--"),
                  m("p#whitetimetype", "infinite"),
                ]),
                m("div#blacktimer", [
                  m("p", "Black Time"),
                  m("p#blacktime", "--"),
                  m("p#blacktimetype", "infinite"),
                ]),
              ]),
              m(
                "div#timecontrolduringplay",
                { hidden: !advanced_time_control || !during_play },
                [
                  m(
                    "button#addtimeforwhite",
                    {
                      onclick: () => {
                        white_remaining_time = +white_remaining_time + 10000;
                      },
                    },
                    "Add 10s for white",
                  ),
                  m(
                    "button#addtimeforblack",
                    {
                      onclick: () => {
                        black_remaining_time = +black_remaining_time + 10000;
                      },
                    },
                    "Add 10s for black",
                  ),
                  m(
                    "button#gameabort",
                    {
                      onclick: () => {
                        if (confirm("Are you sure to abort the game?")) {
                          gameAbort();
                        }
                      },
                    },
                    "ABORT GAME",
                  ),
                ],
              ),
              m("div#evaluation", { hidden: !analysis_mode }, [
                m("div#evalbar", [m("p#cp", "0.00"), m("div#evalbarprogress")]),
                m("p#evalinfo", ""),
                m("p#pvinfo", ""),
              ]),
              m("p#currentboardfen"),
              m("p#label-pgn"),
              m("div#output2", { onupdate: scrollOutput }, m("pre", output2)),
              m("div#enginecmddiv", [
                m("input#enginecmd", {
                  placeholder: "Send command to engine...",
                  disabled: !is_ready || during_play,
                  onkeyup: (e) => {
                    if (e.keyCode != 13) {
                      e.redraw = false;
                      return;
                    }
                    if (during_play) {
                      return;
                    }
                    sendCommandToEngine();
                  },
                }),
                m(
                  "button#sendenginecmd",
                  {
                    onclick: () => {
                      if (during_play) {
                        return;
                      }
                      sendCommandToEngine();
                    },
                  },
                  "SEND",
                ),
              ]),
            ]),
          ]),
        ]);
      };

      return { oninit, view };
    };

    if (!isSupported()) {
      window.alert(
        "Your browser is not supported. For more information, please take a look at https://github.com/hi-ogawa/Stockfish/wiki.",
      );
    } else {
      m.mount($("#root"), App);
    }
  </script>
</body>
