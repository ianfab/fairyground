"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    name: "tetris",
    description: "Classic Tetris - use arrow keys to play",
    code: "\nfunction initGameClient(container, socket, roomId, emitAction) {\n  const canvas = document.createElement('canvas');\n  canvas.width = 300;\n  canvas.height = 600;\n  canvas.style.cssText = 'display: block; margin: 20px auto; background: #000; border: 2px solid #fff;';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  const BLOCK_SIZE = 30;\n\n  const statusDiv = document.createElement('div');\n  statusDiv.style.cssText = 'text-align: center; margin-top: 20px; font-size: 18px; color: #fff;';\n  container.appendChild(statusDiv);\n\n  const COLORS = {\n    I: '#00f0f0',\n    O: '#f0f000',\n    T: '#a000f0',\n    S: '#00f000',\n    Z: '#f00000',\n    J: '#0000f0',\n    L: '#f0a000'\n  };\n\n  let keysPressed = {};\n\n  document.addEventListener('keydown', (e) => {\n    if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', 'Space'].includes(e.code)) {\n      e.preventDefault();\n    }\n\n    if (!keysPressed[e.code]) {\n      keysPressed[e.code] = true;\n\n      if (e.code === 'ArrowLeft') emitAction('move', { direction: 'left' });\n      if (e.code === 'ArrowRight') emitAction('move', { direction: 'right' });\n      if (e.code === 'ArrowDown') emitAction('move', { direction: 'down' });\n      if (e.code === 'ArrowUp') emitAction('rotate', {});\n      if (e.code === 'Space') emitAction('hardDrop', {});\n    }\n  });\n\n  document.addEventListener('keyup', (e) => {\n    keysPressed[e.code] = false;\n  });\n\n  function render(state) {\n    ctx.fillStyle = '#000';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw grid\n    ctx.strokeStyle = '#222';\n    for (let x = 0; x < 10; x++) {\n      for (let y = 0; y < 20; y++) {\n        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n      }\n    }\n\n    // Draw placed blocks\n    if (state.grid) {\n      for (let y = 0; y < 20; y++) {\n        for (let x = 0; x < 10; x++) {\n          if (state.grid[y][x]) {\n            ctx.fillStyle = COLORS[state.grid[y][x]] || '#888';\n            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n            ctx.strokeStyle = '#000';\n            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n          }\n        }\n      }\n    }\n\n    // Draw current piece\n    if (state.currentPiece && state.currentPiece.shape) {\n      ctx.fillStyle = COLORS[state.currentPiece.type] || '#fff';\n      const piece = state.currentPiece;\n      for (let y = 0; y < piece.shape.length; y++) {\n        for (let x = 0; x < piece.shape[y].length; x++) {\n          if (piece.shape[y][x]) {\n            ctx.fillRect(\n              (piece.x + x) * BLOCK_SIZE,\n              (piece.y + y) * BLOCK_SIZE,\n              BLOCK_SIZE,\n              BLOCK_SIZE\n            );\n            ctx.strokeStyle = '#000';\n            ctx.strokeRect(\n              (piece.x + x) * BLOCK_SIZE,\n              (piece.y + y) * BLOCK_SIZE,\n              BLOCK_SIZE,\n              BLOCK_SIZE\n            );\n          }\n        }\n      }\n    }\n\n    // Update status\n    const isPlayer = state.playerId === socket.id;\n    if (state.gameOver) {\n      statusDiv.innerHTML = '<span style=\"color: #f00;\">GAME OVER</span><br>Score: ' + (state.score || 0) + '<br>Lines: ' + (state.lines || 0);\n    } else if (isPlayer) {\n      statusDiv.innerHTML = 'Score: ' + (state.score || 0) + '<br>Lines: ' + (state.lines || 0) + '<br><span style=\"color: #0f0;\">You are playing</span>';\n    } else {\n      statusDiv.innerHTML = 'Score: ' + (state.score || 0) + '<br>Lines: ' + (state.lines || 0) + '<br><span style=\"color: #888;\">Spectating</span>';\n    }\n  }\n\n  return {\n    onStateUpdate: (state) => render(state)\n  };\n}\n\nconst serverLogic = {\n  initialState: {\n    grid: Array(20).fill(null).map(() => Array(10).fill(null)),\n    currentPiece: null,\n    nextPiece: null,\n    score: 0,\n    lines: 0,\n    level: 1,\n    gameOver: false,\n    playerId: null,\n    dropCounter: 0,\n    dropInterval: 1000,\n    lastDropTime: Date.now()\n  },\n  moves: {\n    playerJoined: (state, payload, playerId) => {\n      // First player becomes the active player\n      if (!state.playerId) {\n        state.playerId = playerId;\n\n        // Spawn first piece\n        if (!state.currentPiece) {\n          state.currentPiece = spawnPiece(state);\n          state.nextPiece = getRandomPiece();\n        }\n      }\n    },\n\n    move: (state, payload, playerId) => {\n      if (state.gameOver || state.playerId !== playerId) return;\n\n      const piece = state.currentPiece;\n      if (!piece) return;\n\n      if (payload.direction === 'left') {\n        piece.x--;\n        if (checkCollision(state, piece)) piece.x++;\n      } else if (payload.direction === 'right') {\n        piece.x++;\n        if (checkCollision(state, piece)) piece.x--;\n      } else if (payload.direction === 'down') {\n        piece.y++;\n        if (checkCollision(state, piece)) {\n          piece.y--;\n          lockPiece(state);\n        }\n      }\n    },\n\n    rotate: (state, payload, playerId) => {\n      if (state.gameOver || state.playerId !== playerId) return;\n\n      const piece = state.currentPiece;\n      if (!piece) return;\n\n      // Store original\n      const originalShape = piece.shape;\n\n      // Rotate 90 degrees clockwise\n      piece.shape = piece.shape[0].map((_, i) =>\n        piece.shape.map(row => row[i]).reverse()\n      );\n\n      // Check if rotation is valid\n      if (checkCollision(state, piece)) {\n        // Try wall kicks\n        const kicks = [\n          { x: -1, y: 0 },\n          { x: 1, y: 0 },\n          { x: 0, y: -1 }\n        ];\n\n        let kicked = false;\n        for (const kick of kicks) {\n          piece.x += kick.x;\n          piece.y += kick.y;\n          if (!checkCollision(state, piece)) {\n            kicked = true;\n            break;\n          }\n          piece.x -= kick.x;\n          piece.y -= kick.y;\n        }\n\n        if (!kicked) {\n          piece.shape = originalShape;\n        }\n      }\n    },\n\n    hardDrop: (state, payload, playerId) => {\n      if (state.gameOver || state.playerId !== playerId) return;\n\n      const piece = state.currentPiece;\n      if (!piece) return;\n\n      while (!checkCollision(state, piece)) {\n        piece.y++;\n      }\n      piece.y--;\n      lockPiece(state);\n    },\n\n    tick: (state) => {\n      if (state.gameOver || !state.playerId || !state.currentPiece) return;\n\n      const now = Date.now();\n      const deltaTime = now - state.lastDropTime;\n\n      if (deltaTime > state.dropInterval) {\n        state.lastDropTime = now;\n\n        const piece = state.currentPiece;\n        piece.y++;\n\n        if (checkCollision(state, piece)) {\n          piece.y--;\n          lockPiece(state);\n        }\n      }\n    }\n  }\n};\n\n// Tetris pieces\nconst PIECES = {\n  I: [[1, 1, 1, 1]],\n  O: [[1, 1], [1, 1]],\n  T: [[0, 1, 0], [1, 1, 1]],\n  S: [[0, 1, 1], [1, 1, 0]],\n  Z: [[1, 1, 0], [0, 1, 1]],\n  J: [[1, 0, 0], [1, 1, 1]],\n  L: [[0, 0, 1], [1, 1, 1]]\n};\n\nfunction getRandomPiece() {\n  const types = Object.keys(PIECES);\n  const type = types[Math.floor(Math.random() * types.length)];\n  return { type, shape: PIECES[type] };\n}\n\nfunction spawnPiece(state) {\n  const piece = state.nextPiece || getRandomPiece();\n  state.nextPiece = getRandomPiece();\n\n  return {\n    ...piece,\n    x: Math.floor(10 / 2) - Math.floor(piece.shape[0].length / 2),\n    y: 0\n  };\n}\n\nfunction checkCollision(state, piece) {\n  for (let y = 0; y < piece.shape.length; y++) {\n    for (let x = 0; x < piece.shape[y].length; x++) {\n      if (piece.shape[y][x]) {\n        const newX = piece.x + x;\n        const newY = piece.y + y;\n\n        // Check bounds\n        if (newX < 0 || newX >= 10 || newY >= 20) {\n          return true;\n        }\n\n        // Check collision with placed blocks\n        if (newY >= 0 && state.grid[newY][newX]) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction lockPiece(state) {\n  const piece = state.currentPiece;\n\n  // Place piece on grid\n  for (let y = 0; y < piece.shape.length; y++) {\n    for (let x = 0; x < piece.shape[y].length; x++) {\n      if (piece.shape[y][x]) {\n        const gridY = piece.y + y;\n        const gridX = piece.x + x;\n        if (gridY >= 0 && gridY < 20 && gridX >= 0 && gridX < 10) {\n          state.grid[gridY][gridX] = piece.type;\n        }\n      }\n    }\n  }\n\n  // Check for completed lines\n  let linesCleared = 0;\n  for (let y = 19; y >= 0; y--) {\n    if (state.grid[y].every(cell => cell !== null)) {\n      state.grid.splice(y, 1);\n      state.grid.unshift(Array(10).fill(null));\n      linesCleared++;\n      y++; // Check same row again\n    }\n  }\n\n  if (linesCleared > 0) {\n    state.lines += linesCleared;\n    state.score += [0, 100, 300, 500, 800][linesCleared] * state.level;\n    state.level = Math.floor(state.lines / 10) + 1;\n    state.dropInterval = Math.max(100, 1000 - (state.level - 1) * 100);\n  }\n\n  // Spawn next piece\n  state.currentPiece = spawnPiece(state);\n\n  // Check game over\n  if (checkCollision(state, state.currentPiece)) {\n    state.gameOver = true;\n  }\n}\n"
};
