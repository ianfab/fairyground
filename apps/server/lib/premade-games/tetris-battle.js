"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    name: "tetris-battle",
    description: "Competitive Tetris - clear lines to attack your opponent!",
    code: "\nfunction initGameClient(container, socket, roomId, emitAction) {\n  const BOARD_WIDTH = 10;\n  const BOARD_HEIGHT = 20;\n  const BLOCK_SIZE = 25;\n\n  // Tetromino shapes\n  const SHAPES = {\n    I: [[1,1,1,1]],\n    O: [[1,1],[1,1]],\n    T: [[0,1,0],[1,1,1]],\n    S: [[0,1,1],[1,1,0]],\n    Z: [[1,1,0],[0,1,1]],\n    J: [[1,0,0],[1,1,1]],\n    L: [[0,0,1],[1,1,1]]\n  };\n\n  const COLORS = {\n    I: '#00f0f0',\n    O: '#f0f000',\n    T: '#a000f0',\n    S: '#00f000',\n    Z: '#f00000',\n    J: '#0000f0',\n    L: '#f0a000'\n  };\n\n  container.innerHTML = `\n    <div style=\"display: flex; justify-content: center; align-items: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); gap: 40px; padding: 20px;\">\n      <div style=\"text-align: center;\">\n        <h2 style=\"color: #fff; margin-bottom: 10px;\">Player 1</h2>\n        <canvas id=\"canvas1\" width=\"${BOARD_WIDTH * BLOCK_SIZE}\" height=\"${BOARD_HEIGHT * BLOCK_SIZE}\" style=\"border: 3px solid #fff; background: #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);\"></canvas>\n        <div id=\"score1\" style=\"color: #fff; font-size: 24px; margin-top: 10px; font-weight: bold;\">Score: 0</div>\n      </div>\n      <div style=\"color: #fff; font-size: 18px; max-width: 200px; text-align: center;\">\n        <div style=\"background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;\">\n          <div style=\"margin-bottom: 10px;\">\u2B05\uFE0F\u27A1\uFE0F Move</div>\n          <div style=\"margin-bottom: 10px;\">\u2B06\uFE0F Rotate</div>\n          <div style=\"margin-bottom: 10px;\">\u2B07\uFE0F Soft Drop</div>\n          <div style=\"margin-bottom: 10px;\">Space: Hard Drop</div>\n          <div style=\"margin-top: 20px; font-size: 14px; opacity: 0.8;\">Clear lines to send garbage to opponent!</div>\n        </div>\n      </div>\n      <div style=\"text-align: center;\">\n        <h2 style=\"color: #fff; margin-bottom: 10px;\">Player 2</h2>\n        <canvas id=\"canvas2\" width=\"${BOARD_WIDTH * BLOCK_SIZE}\" height=\"${BOARD_HEIGHT * BLOCK_SIZE}\" style=\"border: 3px solid #fff; background: #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);\"></canvas>\n        <div id=\"score2\" style=\"color: #fff; font-size: 24px; margin-top: 10px; font-weight: bold;\">Score: 0</div>\n      </div>\n    </div>\n  `;\n\n  const canvas1 = document.getElementById('canvas1');\n  const ctx1 = canvas1.getContext('2d');\n  const canvas2 = document.getElementById('canvas2');\n  const ctx2 = canvas2.getContext('2d');\n  const score1El = document.getElementById('score1');\n  const score2El = document.getElementById('score2');\n\n  let myPlayerId = socket.id;\n\n  // Input handling\n  const pressedKeys = new Set();\n\n  document.addEventListener('keydown', (e) => {\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space'].includes(e.code)) {\n      e.preventDefault();\n    }\n\n    if (pressedKeys.has(e.code)) return;\n    pressedKeys.add(e.code);\n\n    if (e.code === 'ArrowLeft') emitAction('move', { direction: 'left' });\n    if (e.code === 'ArrowRight') emitAction('move', { direction: 'right' });\n    if (e.code === 'ArrowDown') emitAction('move', { direction: 'down' });\n    if (e.code === 'ArrowUp') emitAction('rotate', {});\n    if (e.code === 'Space') emitAction('hardDrop', {});\n  });\n\n  document.addEventListener('keyup', (e) => {\n    pressedKeys.delete(e.code);\n  });\n\n  function drawBoard(ctx, board, currentPiece, playerNum) {\n    // Clear canvas\n    ctx.fillStyle = '#000';\n    ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);\n\n    // Draw grid\n    ctx.strokeStyle = '#222';\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n      }\n    }\n\n    // Draw placed blocks\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        if (board[y] && board[y][x]) {\n          ctx.fillStyle = board[y][x];\n          ctx.fillRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);\n        }\n      }\n    }\n\n    // Draw current piece\n    if (currentPiece && currentPiece.shapeData) {\n      const shape = currentPiece.shapeData;\n      const color = COLORS[currentPiece.shape];\n      ctx.fillStyle = color;\n\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x]) {\n            const drawX = (currentPiece.x + x) * BLOCK_SIZE;\n            const drawY = (currentPiece.y + y) * BLOCK_SIZE;\n            ctx.fillRect(drawX + 1, drawY + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    onStateUpdate: (state) => {\n      if (!state.players) return;\n\n      const playerIds = Object.keys(state.players);\n      const player1Id = playerIds[0];\n      const player2Id = playerIds[1];\n\n      if (player1Id) {\n        const p1 = state.players[player1Id];\n        drawBoard(ctx1, p1.board, p1.currentPiece, 1);\n        score1El.textContent = 'Score: ' + (p1.score || 0);\n      }\n\n      if (player2Id) {\n        const p2 = state.players[player2Id];\n        drawBoard(ctx2, p2.board, p2.currentPiece, 2);\n        score2El.textContent = 'Score: ' + (p2.score || 0);\n      }\n\n      // Show game over\n      if (state.gameOver) {\n        const winner = state.winner;\n        const winnerNum = playerIds.indexOf(winner) + 1;\n        [ctx1, ctx2].forEach(ctx => {\n          ctx.fillStyle = 'rgba(0,0,0,0.7)';\n          ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);\n          ctx.fillStyle = '#fff';\n          ctx.font = 'bold 20px Arial';\n          ctx.textAlign = 'center';\n          ctx.fillText('Game Over!', BOARD_WIDTH * BLOCK_SIZE / 2, BOARD_HEIGHT * BLOCK_SIZE / 2 - 20);\n          ctx.fillText('Player ' + winnerNum + ' Wins!', BOARD_WIDTH * BLOCK_SIZE / 2, BOARD_HEIGHT * BLOCK_SIZE / 2 + 10);\n        });\n      }\n    }\n  };\n}\n\nconst serverLogic = {\n  initialState: {\n    players: {},\n    gameStarted: false,\n    gameOver: false,\n    winner: null,\n    lastTickTime: Date.now()\n  },\n  moves: {\n    playerJoined: (state, payload, playerId) => {\n      const shapes = {\n        I: [[1,1,1,1]],\n        O: [[1,1],[1,1]],\n        T: [[0,1,0],[1,1,1]],\n        S: [[0,1,1],[1,1,0]],\n        Z: [[1,1,0],[0,1,1]],\n        J: [[1,0,0],[1,1,1]],\n        L: [[0,0,1],[1,1,1]]\n      };\n      const shapeKeys = Object.keys(shapes);\n      const randomShape = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];\n\n      state.players[playerId] = {\n        board: Array(20).fill(null).map(() => Array(10).fill(null)),\n        currentPiece: {\n          shape: randomShape,\n          shapeData: shapes[randomShape],  // Store actual shape data\n          x: 3,\n          y: 0,\n          rotation: 0\n        },\n        score: 0,\n        gameOver: false\n      };\n\n      // Start game when 2 players join\n      if (Object.keys(state.players).length === 2) {\n        state.gameStarted = true;\n      }\n    },\n\n    move: (state, payload, playerId) => {\n      const player = state.players[playerId];\n      if (!player || player.gameOver || state.gameOver) return;\n\n      const piece = player.currentPiece;\n      const shape = piece.shapeData;\n\n      const canMove = (dx, dy) => {\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x]) {\n              const newX = piece.x + x + dx;\n              const newY = piece.y + y + dy;\n              if (newX < 0 || newX >= 10 || newY >= 20) return false;\n              if (newY >= 0 && player.board[newY][newX]) return false;\n            }\n          }\n        }\n        return true;\n      };\n\n      if (payload.direction === 'left' && canMove(-1, 0)) {\n        piece.x -= 1;\n      } else if (payload.direction === 'right' && canMove(1, 0)) {\n        piece.x += 1;\n      } else if (payload.direction === 'down' && canMove(0, 1)) {\n        piece.y += 1;\n      }\n    },\n\n    rotate: (state, payload, playerId) => {\n      const player = state.players[playerId];\n      if (!player || player.gameOver || state.gameOver) return;\n\n      const piece = player.currentPiece;\n      if (piece.shape === 'O') return; // O piece doesn't rotate\n\n      // Rotate the shape data (transpose and reverse rows)\n      const rotated = piece.shapeData[0].map((_, i) =>\n        piece.shapeData.map(row => row[i]).reverse()\n      );\n\n      // Check if rotation is valid\n      const canRotate = () => {\n        for (let y = 0; y < rotated.length; y++) {\n          for (let x = 0; x < rotated[y].length; x++) {\n            if (rotated[y][x]) {\n              const newX = piece.x + x;\n              const newY = piece.y + y;\n              if (newX < 0 || newX >= 10 || newY >= 20) return false;\n              if (newY >= 0 && player.board[newY][newX]) return false;\n            }\n          }\n        }\n        return true;\n      };\n\n      if (canRotate()) {\n        piece.shapeData = rotated;  // Update the shape data\n      }\n    },\n\n    hardDrop: (state, payload, playerId) => {\n      const player = state.players[playerId];\n      if (!player || player.gameOver || state.gameOver) return;\n\n      const piece = player.currentPiece;\n      const shape = piece.shapeData;\n      const baseShapes = {\n        I: [[1,1,1,1]],\n        O: [[1,1],[1,1]],\n        T: [[0,1,0],[1,1,1]],\n        S: [[0,1,1],[1,1,0]],\n        Z: [[1,1,0],[0,1,1]],\n        J: [[1,0,0],[1,1,1]],\n        L: [[0,0,1],[1,1,1]]\n      };\n      const colors = {\n        I: '#00f0f0',\n        O: '#f0f000',\n        T: '#a000f0',\n        S: '#00f000',\n        Z: '#f00000',\n        J: '#0000f0',\n        L: '#f0a000'\n      };\n\n      // Drop until collision\n      while (true) {\n        let canMove = true;\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x]) {\n              const newY = piece.y + y + 1;\n              const newX = piece.x + x;\n              if (newY >= 20 || (newY >= 0 && player.board[newY][newX])) {\n                canMove = false;\n                break;\n              }\n            }\n          }\n          if (!canMove) break;\n        }\n        if (!canMove) break;\n        piece.y += 1;\n      }\n\n      // Lock piece\n      const color = colors[piece.shape];\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x]) {\n            const boardY = piece.y + y;\n            const boardX = piece.x + x;\n            if (boardY >= 0) {\n              player.board[boardY][boardX] = color;\n            }\n          }\n        }\n      }\n\n      // Check for completed lines\n      let linesCleared = 0;\n      for (let y = 19; y >= 0; y--) {\n        if (player.board[y].every(cell => cell !== null)) {\n          player.board.splice(y, 1);\n          player.board.unshift(Array(10).fill(null));\n          linesCleared++;\n          y++; // Check same row again\n        }\n      }\n\n      if (linesCleared > 0) {\n        player.score += linesCleared * 100;\n\n        // Send garbage to opponent\n        const opponentId = Object.keys(state.players).find(id => id !== playerId);\n        if (opponentId) {\n          const opponent = state.players[opponentId];\n          // Add garbage lines (incomplete lines with random holes)\n          for (let i = 0; i < linesCleared; i++) {\n            opponent.board.shift(); // Remove top line\n            const garbageLine = Array(10).fill('#666');\n            const holePos = Math.floor(Math.random() * 10);\n            garbageLine[holePos] = null; // Create hole\n            opponent.board.push(garbageLine);\n          }\n        }\n      }\n\n      // Spawn new piece\n      const shapeKeys = Object.keys(baseShapes);\n      const randomShape = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];\n      piece.shape = randomShape;\n      piece.shapeData = baseShapes[randomShape];  // Reset to base shape\n      piece.x = 3;\n      piece.y = 0;\n\n      // Check game over\n      const newShape = piece.shapeData;\n      for (let y = 0; y < newShape.length; y++) {\n        for (let x = 0; x < newShape[y].length; x++) {\n          if (newShape[y][x] && player.board[y][piece.x + x]) {\n            player.gameOver = true;\n            state.gameOver = true;\n            state.winner = opponentId;\n          }\n        }\n      }\n    },\n\n    tick: (state) => {\n      if (!state.gameStarted || state.gameOver) return;\n\n      const now = Date.now();\n      if (now - state.lastTickTime < 1000) return; // Tick every 1 second\n      state.lastTickTime = now;\n\n      const baseShapes = {\n        I: [[1,1,1,1]],\n        O: [[1,1],[1,1]],\n        T: [[0,1,0],[1,1,1]],\n        S: [[0,1,1],[1,1,0]],\n        Z: [[1,1,0],[0,1,1]],\n        J: [[1,0,0],[1,1,1]],\n        L: [[0,0,1],[1,1,1]]\n      };\n      const colors = {\n        I: '#00f0f0',\n        O: '#f0f000',\n        T: '#a000f0',\n        S: '#00f000',\n        Z: '#f00000',\n        J: '#0000f0',\n        L: '#f0a000'\n      };\n\n      // Auto drop pieces\n      Object.entries(state.players).forEach(([playerId, player]) => {\n        if (player.gameOver) return;\n\n        const piece = player.currentPiece;\n        const shape = piece.shapeData;\n\n        // Check if can move down\n        let canMoveDown = true;\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x]) {\n              const newY = piece.y + y + 1;\n              const newX = piece.x + x;\n              if (newY >= 20 || (newY >= 0 && player.board[newY][newX])) {\n                canMoveDown = false;\n                break;\n              }\n            }\n          }\n          if (!canMoveDown) break;\n        }\n\n        if (canMoveDown) {\n          piece.y += 1;\n        } else {\n          // Lock piece\n          const color = colors[piece.shape];\n          for (let y = 0; y < shape.length; y++) {\n            for (let x = 0; x < shape[y].length; x++) {\n              if (shape[y][x]) {\n                const boardY = piece.y + y;\n                const boardX = piece.x + x;\n                if (boardY >= 0) {\n                  player.board[boardY][boardX] = color;\n                }\n              }\n            }\n          }\n\n          // Check for completed lines\n          let linesCleared = 0;\n          for (let y = 19; y >= 0; y--) {\n            if (player.board[y].every(cell => cell !== null)) {\n              player.board.splice(y, 1);\n              player.board.unshift(Array(10).fill(null));\n              linesCleared++;\n              y++;\n            }\n          }\n\n          if (linesCleared > 0) {\n            player.score += linesCleared * 100;\n\n            // Send garbage\n            const opponentId = Object.keys(state.players).find(id => id !== playerId);\n            if (opponentId) {\n              const opponent = state.players[opponentId];\n              for (let i = 0; i < linesCleared; i++) {\n                opponent.board.shift();\n                const garbageLine = Array(10).fill('#666');\n                const holePos = Math.floor(Math.random() * 10);\n                garbageLine[holePos] = null;\n                opponent.board.push(garbageLine);\n              }\n            }\n          }\n\n          // Spawn new piece\n          const shapeKeys = Object.keys(baseShapes);\n          const randomShape = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];\n          piece.shape = randomShape;\n          piece.shapeData = baseShapes[randomShape];  // Reset to base shape\n          piece.x = 3;\n          piece.y = 0;\n\n          // Check game over\n          const newShape = piece.shapeData;\n          for (let y = 0; y < newShape.length; y++) {\n            for (let x = 0; x < newShape[y].length; x++) {\n              if (newShape[y][x] && player.board[y] && player.board[y][piece.x + x]) {\n                player.gameOver = true;\n                state.gameOver = true;\n                const opponentId = Object.keys(state.players).find(id => id !== playerId);\n                state.winner = opponentId;\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n};\n"
};
